<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Learning LARC · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Learning LARC">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">docs</a> / <a href="#">books</a> / <a href="#">learning-larc</a> / <a href="#">build</a> / <a href="#">temp</a> / <span>learning-larc-complete</span>
      </div>
      <article class="docs-content">
        <h1>Learning LARC</h1>
<h2>Building Modern Web Applications with the Page Area Network Architecture</h2>
<hr>
<strong>By the LARC Team</strong>
<em>First Edition, 2025</em>
<hr>
<h2>Praise for Learning LARC</h2>
<em>"LARC represents a return to web fundamentals while embracing modern capabilities. This book beautifully explains why that matters."</em>
— <strong>David B. - Software Engineer</strong>
<em>"Finally, a framework that respects the browser. Learning LARC shows you how to build without fighting the platform."</em>
— <strong>Jon W. - App Developer</strong>
<em>"The PAN bus architecture is elegant and powerful. This book makes it accessible to everyone."</em>
— <strong>Mary S. - Designer / Artist</strong>
<hr>
<h2>Copyright</h2>
<p>Copyright © 2025 LARC Team. All rights reserved.</p>
<p>Printed in the United States of America.</p>
<p>Published by LARC Press.</p>
<p>The LARC logo and name are trademarks of the LARC Project.</p>
<p>While the publisher and authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work.</p>
<p>Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.</p>
<hr>
<h2>Table of Contents</h2>
<h3>Preface</h3>
<ul><li>Who This Book Is For</li>
<li>What You'll Learn</li>
<li>Conventions Used in This Book</li>
<li>Using Code Examples</li>
<li>How to Contact Us</li>
<li>Acknowledgments</li>
</ul>
<h3>Part I: Foundations</h3>
<strong>Chapter 1: Philosophy and Background</strong>
<ul><li>The Problem with Modern Web Development</li>
<li>A Return to Fundamentals</li>
<li>The LARC Philosophy</li>
<li>Why "No Build" Matters</li>
<li>When to Use LARC</li>
<li>What You'll Build</li>
</ul>
<strong>Chapter 2: Core Concepts</strong>
<ul><li>Web Components Refresher</li>
<li>The Page Area Network (PAN)</li>
<li>Event-Driven Architecture</li>
<li>State Management Philosophy</li>
<li>Module System</li>
<li>The Component Lifecycle</li>
</ul>
<strong>Chapter 3: Getting Started</strong>
<ul><li>Setting Up Your Development Environment</li>
<li>Your First LARC Application</li>
<li>Project Structure</li>
<li>Import Maps Explained</li>
<li>Development Workflow</li>
<li>Common Patterns</li>
</ul>
<h3>Part II: Building Components</h3>
<strong>Chapter 4: Creating Web Components</strong>
<ul><li>Anatomy of a LARC Component</li>
<li>Shadow DOM Deep Dive</li>
<li>Attributes and Properties</li>
<li>Component Styling</li>
<li>Lifecycle Methods</li>
<li>Testing Components</li>
</ul>
<strong>Chapter 5: The PAN Bus</strong>
<ul><li>Understanding Pub/Sub Architecture</li>
<li>Topics and Namespaces</li>
<li>Publishing Messages</li>
<li>Subscribing to Events</li>
<li>Message Patterns</li>
<li>Debugging PAN Communication</li>
</ul>
<strong>Chapter 6: State Management</strong>
<ul><li>Component-Local State</li>
<li>Shared State Patterns</li>
<li>The pan-store Component</li>
<li>IndexedDB Integration</li>
<li>Persistence Strategies</li>
<li>Offline-First Applications</li>
</ul>
<strong>Chapter 7: Advanced Component Patterns</strong>
<ul><li>Compound Components</li>
<li>Higher-Order Components</li>
<li>Component Composition</li>
<li>Slots and Content Projection</li>
<li>Dynamic Component Loading</li>
<li>Performance Optimization</li>
</ul>
<h3>Part III: Building Applications</h3>
<strong>Chapter 8: Routing and Navigation</strong>
<ul><li>Client-Side Routing</li>
<li>The pan-router Component</li>
<li>Route Parameters</li>
<li>Nested Routes</li>
<li>Route Guards</li>
<li>History Management</li>
</ul>
<strong>Chapter 9: Forms and Validation</strong>
<ul><li>Form Components</li>
<li>Two-Way Data Binding</li>
<li>Validation Strategies</li>
<li>Error Handling</li>
<li>File Uploads</li>
<li>Form Submission</li>
</ul>
<strong>Chapter 10: Data Fetching and APIs</strong>
<ul><li>The pan-fetch Component</li>
<li>REST API Integration</li>
<li>GraphQL Support</li>
<li>WebSocket Communication</li>
<li>Server-Sent Events</li>
<li>Error Handling and Retry Logic</li>
</ul>
<strong>Chapter 11: Authentication and Security</strong>
<ul><li>Authentication Patterns</li>
<li>The pan-auth Component</li>
<li>JWT Token Management</li>
<li>Protected Routes</li>
<li>CORS Considerations</li>
<li>Security Best Practices</li>
</ul>
<h3>Part IV: Advanced Topics</h3>
<strong>Chapter 12: Server Integration</strong>
<ul><li>Backend Architecture</li>
<li>Node.js Integration</li>
<li>PHP Connector</li>
<li>Python/Django Integration</li>
<li>Database Patterns</li>
<li>Real-Time Communication</li>
</ul>
<strong>Chapter 13: Testing</strong>
<ul><li>Unit Testing Components</li>
<li>Integration Testing</li>
<li>End-to-End Testing</li>
<li>Visual Regression Testing</li>
<li>Performance Testing</li>
<li>Continuous Integration</li>
</ul>
<strong>Chapter 14: Performance and Optimization</strong>
<ul><li>Loading Strategies</li>
<li>Code Splitting</li>
<li>Lazy Loading Components</li>
<li>Caching Strategies</li>
<li>Bundle Size Optimization</li>
<li>Performance Monitoring</li>
</ul>
<strong>Chapter 15: Deployment</strong>
<ul><li>Static Hosting</li>
<li>CDN Configuration</li>
<li>Environment Variables</li>
<li>CI/CD Pipelines</li>
<li>Monitoring and Analytics</li>
<li>Production Best Practices</li>
</ul>
<h3>Part V: Ecosystem</h3>
<strong>Chapter 16: Component Library</strong>
<ul><li>Using the Component Registry</li>
<li>Contributing Components</li>
<li>Creating a Component Library</li>
<li>Documentation Strategies</li>
<li>Versioning and Releases</li>
</ul>
<strong>Chapter 17: Tooling</strong>
<ul><li>Development Tools</li>
<li>CLI Tools</li>
<li>VS Code Integration</li>
<li>Browser DevTools</li>
<li>Debugging Techniques</li>
</ul>
<strong>Chapter 18: Real-World Applications</strong>
<ul><li>Case Study: E-Commerce Platform</li>
<li>Case Study: Dashboard Application</li>
<li>Case Study: Blog/CMS</li>
<li>Lessons Learned</li>
<li>Best Practices</li>
</ul>
<h3>Appendices</h3>
<strong>Appendix A: Web Components API Reference</strong>
<ul><li>Custom Elements</li>
<li>Shadow DOM</li>
<li>HTML Templates</li>
<li>ES Modules</li>
</ul>
<strong>Appendix B: PAN Bus API Reference</strong>
<ul><li>Core Methods</li>
<li>Message Formats</li>
<li>Topic Patterns</li>
<li>Configuration Options</li>
</ul>
<strong>Appendix C: Component API Reference</strong>
<ul><li>Built-in Components</li>
<li>Component Properties</li>
<li>Events and Methods</li>
</ul>
<strong>Appendix D: Migration Guides</strong>
<ul><li>From React</li>
<li>From Vue</li>
<li>From Angular</li>
<li>From jQuery</li>
</ul>
<strong>Appendix E: Resources</strong>
<ul><li>Official Documentation</li>
<li>Community Resources</li>
<li>Video Tutorials</li>
<li>Example Projects</li>
</ul>
<h3>Index</h3>
<hr>
<h2>About the Authors</h2>
<p>The LARC Team is a group of developers passionate about web standards, simplicity, and performance. We believe the web platform has evolved to the point where many abstractions are no longer necessary, and we created LARC to prove it.</p>
<hr>
<p>\pagebreak</p>
<h1>Foreword</h1>
<em>by Christopher Robison</em>
<p>I didn't set out to build a framework. I set out to escape one — or at least escape the gravitational pull of the endless build pipeline.</p>
<p>After decades of building things for the web, my machine had become a storage exhibit of Node versions, Python versions, shims, wrappers, and dependency folders with the mass of small moons. Not because any of it was bad. Build tools are fine. For big projects, they're downright amazing. But somewhere along the way, we normalized the idea that even the simplest experiment needed a pipeline, a bundler, a transpiler, and a twelve-step hydration ritual before it could say "Hello, World."</p>
<p>That friction bothered me.</p>
<p>I wanted the feeling I had back in the early days: the joy of dropping a <code><script></code> tag into an HTML file and instantly seeing something come alive. No ceremony. No yak shaving. Just a browser, a file, and an idea.</p>
<p>Web Components felt close to that spirit — native modules, shadow DOM, real encapsulation — but they were oddly isolated. Each component was a self-contained island. Reusable, yes. Architecturally composable? Not really. Nothing tied them together except whatever glue code you wrote yourself. It felt like someone had shipped LEGO bricks without the ability to click them together.</p>
<p>That's when I remembered the CAN bus in cars.</p>
<p>The CAN bus is this beautifully simple ecosystem: dozens of systems — sensors, motors, controllers — all sharing a single communication line. Anybody can broadcast. Anybody can listen. Nobody needs to know who else exists. A message goes out, and the parts that care respond. It's loosely coupled machinery at its finest.</p>
<p>I wanted that for the web.</p>
<p>So I built the PAN bus — the Page Area Network — and started experimenting. Not with the intention of making A Real Framework™, but out of curiosity. How far could I push this idea? What could I build if every component on the page could talk over a shared bus, using nothing but browser-native APIs and one tiny script include?</p>
<p>That little experiment got out of hand in the best way.</p>
<p>I kept pushing it, partly out of stubbornness, partly out of sheer delight. I wanted to see if I could build real, full-blown applications with no build process at all — just a single script tag pointing to LARC and a page full of components chatting over the bus. And it turned out to be… fun. Refreshing. Capable. Liberating, even. A loose, elegant architecture emerged almost on its own.</p>
<p>Along the way, I realized something important: I'm not anti-build-tool. They solve real problems, especially at scale. But they shouldn't be mandatory for everything. And they shouldn't overshadow the fact that the browser today is powerful enough to build serious applications with a simple HTML page, a few components, and a shared message bus.</p>
<p>React, Angular, Vue — they solved problems that absolutely needed solving at the time. The web platform in 2015 was missing big pieces: templating, reactivity, routing, structured components, coherence. These frameworks carried the industry through that era. But the web has evolved since then. Many of those features now exist natively — standardized, built-in, fast, and universally available.</p>
<p>LARC isn't here to replace those frameworks. It complements them. It fills in the 20% Web Components never standardized — the shared communication fabric. The glue that lets components coexist instead of siloing themselves off. It also makes bundle sizes smaller and architectures cleaner, whether you're going framework-free or integrating with your existing stack.</p>
<p>If this book succeeds, you'll see what I saw: the thrill of rediscovering the browser as a first-class app platform. The joy of building big things out of small, decoupled pieces. And the surprising power of an architecture that starts with a simple HTML file and one script include.</p>
<p>The web grew up. Now we get to build like it.</p>
<p>— <em>Christopher Robison</em></p>
<p>\pagebreak</p>
<h1>Chapter 1: Philosophy and Background</h1>
<h2>The Problem with Modern Web Development</h2>
<p>If you've been building web applications for the past decade, you've likely experienced what many developers call "JavaScript fatigue." The modern web development landscape has become increasingly complex, with countless tools, frameworks, and build processes standing between you and shipping working code.</p>
<p>Consider a typical modern web project setup:</p>
<li>Initialize your project with a framework CLI (<code>create-react-app</code>, <code>vue create</code>, etc.)</li>
<li>Install hundreds or thousands of npm dependencies</li>
<li>Configure webpack, Babel, TypeScript, ESLint, Prettier</li>
<li>Set up build scripts for development, production, testing</li>
<li>Wait for builds to complete (sometimes minutes)</li>
<li>Debug build configuration issues when something breaks</li>
<li>Update dependencies regularly to patch security vulnerabilities</li>
<li>Repeat the cycle when frameworks release breaking changes</li>
<p>This complexity wasn't always necessary. In the early days of the web, you could create an HTML file, add some CSS and JavaScript, and open it directly in a browser. No build step. No toolchain. No configuration. Just code that runs.</p>
<p>What happened?</p>
<h3>The Rise of Complexity</h3>
<p>!<a href="../images/12-traditional-vs-larc-1.png"><strong>Figure 1.1:</strong> Development Workflow - Traditional vs LARC</a></p>
<strong><em>Figure 1.1:</strong> Development Workflow - Traditional vs LARC</em>
<p>!<a href="../images/12-traditional-vs-larc-1.png"><strong>Figure 1.1:</strong> Development Workflow - Traditional vs LARC</a>
<strong><em>Figure 1.1:</strong> Development Workflow - Traditional vs LARC</em></p>
<p>The web platform evolved, but it didn't evolve fast enough for ambitious developers. We wanted:</p>
<ul><li><strong>Component-based architecture</strong> — but HTML didn't have custom elements yet</li>
<li><strong>Module systems</strong> — but JavaScript didn't have native imports</li>
<li><strong>Reactive data binding</strong> — but the DOM wasn't designed for it</li>
<li><strong>Advanced syntax</strong> — like JSX, TypeScript, or class properties</li>
</ul>
Frameworks filled these gaps by building abstractions on top of the web platform. But these abstractions came with costs:
<ul><li><strong>Build toolchains</strong> became mandatory to transpile code</li>
<li><strong>Bundle sizes</strong> grew as framework code was shipped to browsers</li>
<li><strong>Learning curves</strong> steepened as developers had to learn both the framework and the tools</li>
<li><strong>Debugging</strong> became harder with source maps and transpiled code</li>
<li><strong>Performance</strong> suffered from unnecessary abstraction layers</li>
</ul>
The irony? While we were busy building these elaborate toolchains, the web platform itself was evolving to support many of the features we wanted natively.
<h3>The Platform Has Caught Up</h3>
<p>!<a href="../images/12-traditional-vs-larc-3.png"><strong>Figure 1.3:</strong> Bundle Size Comparison</a></p>
<strong><em>Figure 1.3:</strong> Bundle Size Comparison</em>
<p>!<a href="../images/01-architecture-overview-3.png"><strong>Figure 1.2:</strong> LARC No-Build Architecture</a></p>
<strong><em>Figure 1.2:</strong> LARC No-Build Architecture</em>
<p>!<a href="../images/01-architecture-overview-3.png"><strong>Figure 1.3:</strong> LARC No-Build Architecture</a>
<strong><em>Figure 1.3:</strong> LARC No-Build Architecture</em></p>
<p>Today's web platform is remarkably capable. Modern browsers support:</p>
<ul><li><strong>Custom Elements</strong> — native component definition</li>
<li><strong>Shadow DOM</strong> — true style encapsulation</li>
<li><strong>ES Modules</strong> — native JavaScript modules with imports</li>
<li><strong>Import Maps</strong> — dependency management without bundlers</li>
<li><strong>Template Literals</strong> — dynamic HTML without JSX</li>
<li><strong>Proxy and Reflect</strong> — reactive data patterns</li>
<li><strong>CSS Custom Properties</strong> — themeable components</li>
<li><strong>Web Components</strong> — standards-based component architecture</li>
</ul>
These aren't polyfills or experimental features. They're stable, well-supported standards that work across all modern browsers. Yet most web frameworks continue to build elaborate abstractions on top of the platform, ignoring these native capabilities.
<h3>A Common Scenario</h3>
<p>Let's look at a real-world example. Imagine you're building a simple dashboard with a few interactive components: a card, a button, and a data table. Here's what this might look like in a typical React project:</p>
<strong>The Setup:</strong>
<pre><code class="language-bash">npx create-react-app my-dashboard
cd my-dashboard
npm install styled-components react-router axios redux
# Wait 5-10 minutes for installation
# Project size: ~300MB, ~1000+ dependencies</code></pre>
<strong>The Code:</strong>
<pre><code class="language-jsx">// Card.jsx
import React from &#039;react&#039;;
import styled from &#039;styled-components&#039;;

const StyledCard = styled.div`
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
`;

export default function Card({ title, children }) {
  return (
    &lt;StyledCard&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      {children}
    &lt;/StyledCard&gt;
  );
}</code></pre>
<strong>The Build:</strong>
<pre><code class="language-bash">npm run build
# Wait 30-60 seconds
# Output: Minified, bundled, transpiled code
# Bundle size: 200-500KB (before your actual code)</code></pre>
<p>Now, here's the same thing with native Web Components and LARC:</p>
<strong>The Setup:</strong>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;script type=&quot;importmap&quot;&gt;
  {
    &quot;imports&quot;: {
      &quot;@larcjs/ui&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/components@2.0.0/pan-card.mjs&quot;
    }
  }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;pan-card title=&quot;Dashboard&quot;&gt;
    &lt;p&gt;Your content here&lt;/p&gt;
  &lt;/pan-card&gt;

  &lt;script type=&quot;module&quot;&gt;
    import &#039;@larcjs/ui&#039;;
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<strong>The Build:</strong>
<pre><code class="language-bash"># There is no build step. Open the HTML file. It works.</code></pre>
<p>Same functionality. Zero dependencies. No build process. No toolchain. Just HTML, CSS, and JavaScript working together as the platform intended.</p>
<h2>A Return to Fundamentals</h2>
<p>LARC (Lightweight Autonomous Reactive Components) represents a philosophical shift back to web fundamentals. But this isn't about going backward—it's about recognizing that the platform has evolved to the point where many of our abstractions are no longer necessary.</p>
<h3>What LARC Is</h3>
<p>LARC is a set of conventions, patterns, and utilities for building modern web applications using native web standards:</p>
<ul><li><strong>Web Components</strong> for encapsulated, reusable UI elements</li>
<li><strong>ES Modules</strong> for code organization and imports</li>
<li><strong>Import Maps</strong> for dependency management</li>
<li><strong>The PAN Bus</strong> for component communication</li>
<li><strong>Native APIs</strong> for state, routing, and data fetching</li>
</ul>
LARC provides guidance and utilities, but it doesn't abstract away the platform. When you write LARC code, you're writing standard JavaScript, HTML, and CSS that runs directly in the browser.
<h3>What LARC Is Not</h3>
<p>LARC is deliberately minimal. It is <strong>not</strong>:</p>
<ul><li>A framework with proprietary APIs you must learn</li>
<li>A template language that requires compilation</li>
<li>A state management system with complex rules</li>
<li>A build tool that transforms your code</li>
<li>A runtime that interprets your components</li>
</ul>
If you know HTML, CSS, and JavaScript, you already know most of LARC.
<h3>Core Principles</h3>
<p>LARC is built on several core principles:</p>
<p>#### 1. Standards First</p>
<p>LARC embraces web standards rather than fighting them. Every LARC component is a valid Web Component. Every LARC module is a valid ES Module. If you understand the standards, you understand LARC.</p>
<p>#### 2. Zero Build for Development</p>
<p>During development, you should be able to edit a file and refresh the browser. No build step. No waiting. No configuration. The browser is your development environment.</p>
<p>This doesn't mean builds are forbidden—you can still optimize for production if needed. But they should be optional enhancements, not requirements.</p>
<p>#### 3. Progressive Enhancement</p>
<p>Start simple and add complexity only when needed. A basic component can be a few lines of JavaScript. As requirements grow, add features incrementally: state management, routing, server integration, etc.</p>
<p>You're never locked into architectural decisions made at project initialization. LARC applications evolve naturally.</p>
<p>#### 4. Local First, Network Aware</p>
<p>Components should work independently with local state. Network communication happens through explicit, observable patterns (the PAN bus). This makes components:</p>
<ul><li>Easier to test (no mocking required)</li>
<li>More reusable (fewer dependencies)</li>
<li>More resilient (graceful degradation)</li>
</ul>
#### 5. Developer Experience Through Simplicity
<p>Good DX doesn't require complex tooling. It comes from:</p>
<ul><li>Clear, predictable patterns</li>
<li>Minimal abstractions</li>
<li>Fast feedback loops</li>
<li>Easy debugging</li>
<li>Comprehensive documentation</li>
</ul>
When something breaks in LARC, you can open browser DevTools and debug standard JavaScript. No source maps. No transpiled code. No framework internals.
<h2>The LARC Philosophy</h2>
<p>At its heart, LARC is about <strong>respecting the platform</strong>. The web is incredibly powerful, yet we've spent years building layers of abstraction that hide its capabilities. LARC removes those layers.</p>
<h3>Composition Over Configuration</h3>
<p>Rather than configuring a framework through JSON or CLI flags, LARC applications are composed from standard parts:</p>
<pre><code class="language-html">&lt;!-- Composition: Combine standard elements --&gt;
&lt;pan-router&gt;
  &lt;pan-route path=&quot;/&quot; component=&quot;home-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/dashboard&quot; component=&quot;dashboard-page&quot;&gt;&lt;/pan-route&gt;
&lt;/pan-router&gt;</code></pre>
<p>Each element is understandable in isolation. There's no magic configuration file that controls behavior across your entire application.</p>
<h3>Convention Over Prescription</h3>
<p>LARC suggests patterns but doesn't enforce them. There's no "one true way" to structure a LARC application. The conventions exist to make common tasks easier, but you can always drop down to standard APIs when needed.</p>
<p>For example, LARC recommends the PAN bus for component communication, but you can also use:</p>
<ul><li>Custom events</li>
<li>Direct property access</li>
<li>Shared state objects</li>
<li>URL parameters</li>
<li>LocalStorage</li>
<li>Any other standard browser API</li>
</ul>
Choose the right tool for your specific use case.
<h3>Explicit Over Implicit</h3>
<p>LARC favors explicitness. When a component fetches data, you see the fetch call. When state changes, you see the assignment. When events are dispatched, you see the dispatch.</p>
<p>Compare these two approaches:</p>
<strong>Implicit (typical framework):</strong>
<pre><code class="language-jsx">function UserProfile() {
  const [user, loading, error] = useUser(userId);

  if (loading) return &lt;Spinner /&gt;;
  if (error) return &lt;Error message={error} /&gt;;

  return &lt;ProfileCard user={user} /&gt;;
}</code></pre>
<p>Magic happens in <code>useUser</code>. Where does the data come from? When does it refetch? What triggers updates? You need to understand the framework's mental model.</p>
<strong>Explicit (LARC):</strong>
<pre><code class="language-javascript">class UserProfile extends HTMLElement {
  async connectedCallback() {
    this.render({ loading: true });

    try {
      const response = await fetch(`/api/users/${this.userId}`);
      const user = await response.json();
      this.render({ user });
    } catch (error) {
      this.render({ error: error.message });
    }
  }

  render(state) {
    if (state.loading) {
      this.innerHTML = &#039;&lt;loading-spinner&gt;&lt;/loading-spinner&gt;&#039;;
    } else if (state.error) {
      this.innerHTML = `&lt;error-message text=&quot;${state.error}&quot;&gt;&lt;/error-message&gt;`;
    } else {
      this.innerHTML = `&lt;profile-card .user=&quot;${state.user}&quot;&gt;&lt;/profile-card&gt;`;
    }
  }
}</code></pre>
<p>Every step is visible. You can trace exactly what happens and when. Debugging is straightforward because you're working with standard JavaScript.</p>
<h2>Why "No Build" Matters</h2>
<p>The "no build" philosophy isn't about being purist or rejecting tools. It's about removing unnecessary complexity and its associated costs.</p>
<h3>Development Speed</h3>
<p>Without a build step, your development cycle is:</p>
<li>Edit code</li>
<li>Refresh browser</li>
<li>See changes</li>
<p>That's it. No waiting for webpack to rebuild. No watching file watchers fail. No debugging build configurations.</p>
<p>This might seem like a small thing, but it compounds. Over a day of development, those 10-30 second build times add up to significant lost productivity. More importantly, they break flow state.</p>
<h3>Debugging Simplicity</h3>
<p>When you open browser DevTools in a LARC application, you see your actual code. No source maps needed. No transpiled output. No minified framework internals.</p>
<p>Set a breakpoint in your component's <code>connectedCallback</code>. It stops exactly where you expect. The call stack is readable. Variables are named as you wrote them.</p>
<p>This makes debugging accessible to junior developers and reduces time spent fighting tools.</p>
<h3>Deployment Simplicity</h3>
<p>A LARC application can be deployed to any static host:</p>
<ul><li>GitHub Pages</li>
<li>Netlify</li>
<li>Vercel</li>
<li>Amazon S3</li>
<li>Any web server</li>
</ul>
No server-side rendering. No Node.js runtime. No build artifacts to manage. Just upload HTML, CSS, and JavaScript files.
<p>Want to deploy to a CDN? Your entire application is already CDN-friendly because it's just static files.</p>
<h3>Lower Barrier to Entry</h3>
<p>New developers can learn web development by:</p>
<li>Creating an HTML file</li>
<li>Adding some CSS and JavaScript</li>
<li>Opening it in a browser</li>
<p>No installation. No environment setup. No project configuration. This is how the web should work.</p>
<p>With build tools, new developers face:</p>
<li>Install Node.js</li>
<li>Learn npm/yarn</li>
<li>Understand package.json</li>
<li>Configure webpack/Babel</li>
<li>Troubleshoot build errors</li>
<li>Learn framework-specific tooling</li>
<p>Before writing a single line of application code, they've already encountered dozens of concepts unrelated to actual web development.</p>
<h3>Sustainability</h3>
<p>Build tools and frameworks change rapidly. A React application from 2015 likely needs significant updates to run today. Build configurations break. Dependencies become unmaintained. Migration guides are incomplete.</p>
<p>LARC applications use web standards. A LARC application from 2025 will still run in 2035 because it's built on stable browser APIs, not framework-specific abstractions.</p>
<p>This doesn't mean LARC applications never need updates—APIs evolve, best practices change. But the core architecture is built on a foundation that changes slowly and deliberately through standards processes.</p>
<h2>When to Use LARC</h2>
<p>LARC isn't the right choice for every project. Understanding when to use it (and when not to) helps you make informed decisions.</p>
<h3>LARC Excels At</h3>
<strong>Small to Medium Applications</strong>
Projects with 10-100 components where simplicity and maintainability matter more than framework ecosystem size.
<strong>Dashboard and Admin Panels</strong>
Internal tools where the development team controls the environment and values fast iteration.
<strong>Progressive Web Apps</strong>
Applications that benefit from offline-first architecture and minimal JavaScript overhead.
<strong>Learning Projects</strong>
Teaching web development without the complexity of modern toolchains.
<strong>Embedded Widgets</strong>
Reusable components that need to work in any environment without framework dependencies.
<strong>Prototypes and MVPs</strong>
Quickly validating ideas without upfront tooling investment.
<h3>Consider Alternatives When</h3>
<strong>Very Large Teams</strong>
If you have 50+ developers working on a single codebase, framework opinions and tooling might provide valuable guardrails.
<strong>Heavy Framework Ecosystem Dependencies</strong>
If your project critically relies on a specific framework's ecosystem (e.g., React Native integration, specific UI libraries), switching costs may be prohibitive.
<strong>Server-Side Rendering is Critical</strong>
While LARC supports SSR, frameworks like Next.js have more mature SSR/SSG ecosystems.
<strong>Team Expertise</strong>
If your entire team is deeply experienced in React/Vue/Angular and inexperienced with Web Components, the learning curve might slow initial development.
<p>That said, LARC's simplicity often means the learning curve is shorter than expected. Most experienced developers can become productive with LARC in days, not weeks.</p>
<h3>Hybrid Approaches</h3>
<p>You don't have to go all-in on LARC. Consider hybrid approaches:</p>
<strong>Progressive Migration</strong>
Build new features in LARC while maintaining existing framework code. Web Components can coexist with React, Vue, or Angular.
<strong>Micro-frontends</strong>
Use LARC for some micro-frontends and other frameworks for others. Web Components provide clean boundaries.
<strong>Component Libraries</strong>
Build a LARC component library that can be consumed by any framework or vanilla JavaScript.
<h2>What You'll Build</h2>
<p>Throughout this book, you'll build several progressively complex applications:</p>
<h3>Chapter Examples</h3>
<p>Each chapter includes focused examples demonstrating specific concepts:</p>
<ul><li>A <strong>counter component</strong> (Chapter 4) to understand component basics</li>
<li>A <strong>todo list</strong> (Chapter 5) to learn PAN bus communication</li>
<li>A <strong>user profile form</strong> (Chapter 9) to master form handling</li>
<li>A <strong>data table</strong> (Chapter 10) to work with APIs and data</li>
</ul>
<h3>Capstone Project: TaskFlow</h3>
<p>In the final chapters, you'll build <strong>TaskFlow</strong>, a complete project management application featuring:</p>
<ul><li>User authentication and authorization</li>
<li>Real-time collaboration via WebSockets</li>
<li>Offline-first architecture with IndexedDB</li>
<li>Drag-and-drop task boards</li>
<li>File attachments and comments</li>
<li>Search and filtering</li>
<li>Data visualization</li>
<li>Mobile-responsive design</li>
</ul>
TaskFlow will demonstrate how LARC patterns scale to production applications while remaining maintainable and performant.
<h3>What You'll Learn</h3>
<p>By the end of this book, you'll be able to:</p>
<ul><li>Build complex, maintainable applications using Web Components</li>
<li>Design effective component communication patterns with the PAN bus</li>
<li>Manage application state without external frameworks</li>
<li>Integrate with backend APIs and real-time services</li>
<li>Handle routing, forms, and authentication</li>
<li>Write testable, reusable components</li>
<li>Optimize performance and bundle size</li>
<li>Deploy LARC applications to production</li>
<li>Make informed decisions about when to use LARC vs. other approaches</li>
</ul>
<h2>Looking Ahead</h2>
<p>The next chapter dives into LARC's core concepts: Web Components, the PAN bus, and event-driven architecture. You'll learn the fundamental patterns that make LARC applications work.</p>
<p>But before we get technical, take a moment to consider what drew you to this book. Perhaps you're tired of build tool complexity. Perhaps you want to understand how the web really works. Perhaps you're curious about a different approach.</p>
<p>Whatever your motivation, LARC offers something increasingly rare in modern web development: simplicity without sacrificing capability. You're about to learn how to build serious web applications using the platform itself, not abstractions on top of it.</p>
<p>Let's begin.</p>
<hr>
<h2>Summary</h2>
<ul><li>Modern web development has become unnecessarily complex with build tools, frameworks, and abstractions</li>
<li>The web platform has evolved to support features natively that once required frameworks</li>
<li>LARC uses web standards (Web Components, ES Modules, Import Maps) to build applications without build steps</li>
<li>Core principles: standards first, zero build for development, progressive enhancement, local first</li>
<li>"No build" matters for development speed, debugging simplicity, deployment, and sustainability</li>
<li>LARC works best for small-to-medium applications, dashboards, PWAs, and prototypes</li>
<li>You'll build real applications throughout this book, culminating in a production-ready project management app</li>
</ul>
\pagebreak
<h1>Chapter 2: Core Concepts</h1>
<p>Now that you understand LARC's philosophy, let's explore the technical foundation that makes it work. This chapter introduces the core concepts you'll use throughout the book: Web Components, the PAN bus, event-driven architecture, and the component lifecycle.</p>
<p>Don't worry if some of these concepts are new to you. We'll build understanding progressively, starting with the basics and working toward more sophisticated patterns.</p>
<h2>Web Components Refresher</h2>
<p>!<a href="../images/01-architecture-overview-1.png"><strong>Figure 2.1:</strong> LARC High-Level Architecture</a></p>
<strong><em>Figure 2.1:</strong> LARC High-Level Architecture</em>
<p>Web Components are a suite of browser APIs that let you create custom, reusable HTML elements. Unlike framework components, Web Components are browser standards supported natively across all modern browsers.</p>
<h3>The Three Pillars</h3>
<p>Web Components rest on three main technologies:</p>
<p>#### 1. Custom Elements</p>
<p>!<a href="../images/02-component-structure-2.png"><strong>Figure 2.2:</strong> Web Component Anatomy</a></p>
<strong><em>Figure 2.2:</strong> Web Component Anatomy</em>
<p>Custom Elements let you define new HTML tags with custom behavior:</p>
<pre><code class="language-javascript">// Define a custom element
class HelloWorld extends HTMLElement {
  connectedCallback() {
    this.textContent = &#039;Hello, World!&#039;;
  }
}

// Register it
customElements.define(&#039;hello-world&#039;, HelloWorld);</code></pre>
<p>Now you can use <code><hello-world></hello-world></code> in your HTML, and it works like any built-in element.</p>
<strong>Key Points:</strong>
<ul><li>Element names must contain a hyphen (e.g., <code>my-component</code>, not <code>mycomponent</code>)</li>
<li>Custom elements inherit from <code>HTMLElement</code> or another HTML element</li>
<li>They have lifecycle callbacks for creation, connection, and removal</li>
</ul>
#### 2. Shadow DOM
<p>!<a href="../images/02-component-structure-4.png"><strong>Figure 2.3:</strong> Shadow DOM Tree Structure</a></p>
<strong><em>Figure 2.3:</strong> Shadow DOM Tree Structure</em>
<p>!<a href="../images/02-component-structure-4.png"><strong>Figure 2.4:</strong> Shadow DOM Tree Structure</a>
<strong><em>Figure 2.4:</strong> Shadow DOM Tree Structure</em></p>
<p>Shadow DOM provides style and markup encapsulation:</p>
<pre><code class="language-javascript">class FancyButton extends HTMLElement {
  constructor() {
    super();
    // Create shadow root
    this.attachShadow({ mode: &#039;open&#039; });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button {
          background: blue;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
        }
      &lt;/style&gt;
      &lt;button&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/button&gt;
    `;
  }
}

customElements.define(&#039;fancy-button&#039;, FancyButton);</code></pre>
<p>The styles inside Shadow DOM don't leak out, and external styles don't leak in:</p>
<pre><code class="language-html">&lt;!-- This button is blue (from shadow DOM) --&gt;
&lt;fancy-button&gt;Click Me&lt;/fancy-button&gt;

&lt;!-- This button is not affected by fancy-button&#039;s styles --&gt;
&lt;button&gt;Regular Button&lt;/button&gt;

&lt;style&gt;
  /* This won&#039;t affect fancy-button&#039;s internal button */
  button { background: red; }
&lt;/style&gt;</code></pre>
<strong>Key Points:</strong>
<ul><li>Shadow DOM creates an isolated scope for styles and DOM</li>
<li>Use <code><slot></code> elements to project content from light DOM into shadow DOM</li>
<li><code>mode: 'open'</code> makes shadow root accessible via <code>element.shadowRoot</code></li>
</ul>
#### 3. HTML Templates
<p>Templates define reusable chunks of markup that aren't rendered until activated:</p>
<pre><code class="language-html">&lt;template id=&quot;card-template&quot;&gt;
  &lt;style&gt;
    .card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 16px;
    }
  &lt;/style&gt;
  &lt;div class=&quot;card&quot;&gt;
    &lt;h2 class=&quot;title&quot;&gt;&lt;/h2&gt;
    &lt;p class=&quot;content&quot;&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  class SimpleCard extends HTMLElement {
    connectedCallback() {
      const template = document.getElementById(&#039;card-template&#039;);
      const clone = template.content.cloneNode(true);

      clone.querySelector(&#039;.title&#039;).textContent = this.getAttribute(&#039;title&#039;);
      clone.querySelector(&#039;.content&#039;).textContent = this.getAttribute(&#039;content&#039;);

      this.attachShadow({ mode: &#039;open&#039; });
      this.shadowRoot.appendChild(clone);
    }
  }

  customElements.define(&#039;simple-card&#039;, SimpleCard);
&lt;/script&gt;</code></pre>
<strong>Key Points:</strong>
<ul><li>Template content is inert (scripts don't run, images don't load)</li>
<li>Templates can be defined in HTML or created programmatically</li>
<li>Clone template content before using it</li>
</ul>
<h3>Web Components vs Framework Components</h3>
<p>It's worth understanding how Web Components differ from framework components:</p>
<p>| Aspect | Web Components | React Components |
|--------|---------------|------------------|
| <strong>Definition</strong> | Browser standard | Library-specific |
| <strong>Syntax</strong> | JavaScript classes | JSX or functions |
| <strong>Lifecycle</strong> | Native callbacks | Virtual DOM lifecycle |
| <strong>Reusability</strong> | Works everywhere | Requires React |
| <strong>Build step</strong> | Optional | Required (for JSX) |
| <strong>Encapsulation</strong> | Shadow DOM | CSS Modules/CSS-in-JS |</p>
<p>Both approaches have their place. Web Components excel at true reusability and standards-based development. Framework components often provide better ergonomics within their specific ecosystem.</p>
<p>LARC chooses Web Components because they align with the "standards first" principle.</p>
<h2>The Page Area Network (PAN)</h2>
<p>!<a href="../images/01-architecture-overview-2.png"><strong>Figure 2.4:</strong> Component Communication Flow</a></p>
<strong><em>Figure 2.4:</strong> Component Communication Flow</em>
<p>The Page Area Network, or PAN bus, is LARC's event-driven communication system. It's inspired by microservices architecture but designed for browser components.</p>
<h3>The Problem It Solves</h3>
<p>In a traditional component tree, communication flows up and down:</p>
<pre><code class="language-plaintext">App
├── Header
│   └── UserMenu
│       └── LogoutButton
└── Content
    └── UserProfile</code></pre>
<p>If <code>LogoutButton</code> needs to notify <code>UserProfile</code> that the user logged out, you have several options:</p>
<li><strong>Pass callbacks down</strong> through props (prop drilling)</li>
<li><strong>Lift state up</strong> to a common ancestor</li>
<li><strong>Use context</strong> or global state</li>
<li><strong>Dispatch custom events</strong> that bubble up</li>
<p>Each approach has tradeoffs. Prop drilling creates tight coupling. Global state makes testing harder. Event bubbling is limited by DOM structure.</p>
<h3>The PAN Bus Approach</h3>
<p>The PAN bus provides a <strong>decoupled pub/sub system</strong>:</p>
<pre><code class="language-javascript">// LogoutButton publishes an event
pan.publish(&#039;user.logout&#039;, { userId: 123 });

// UserProfile subscribes to events (anywhere in the app)
pan.subscribe(&#039;user.logout&#039;, (data) =&gt; {
  console.log(&#039;User logged out:&#039;, data.userId);
  this.clearUserData();
});</code></pre>
<p>Components don't need to know about each other. They communicate through topics (like <code>'user.logout'</code>) with no direct coupling.</p>
<h3>Topic Namespaces</h3>
<p>Topics use dot notation for organization:</p>
<pre><code class="language-javascript">&#039;user.login&#039;          // User logged in
&#039;user.logout&#039;         // User logged out
&#039;user.profile.update&#039; // Profile was updated

&#039;cart.item.add&#039;       // Item added to cart
&#039;cart.item.remove&#039;    // Item removed
&#039;cart.checkout&#039;       // Checkout initiated

&#039;app.theme.change&#039;    // Theme changed
&#039;app.error&#039;           // Application error</code></pre>
<p>You can subscribe to specific topics or use wildcards:</p>
<pre><code class="language-javascript">// Specific topic
pan.subscribe(&#039;user.login&#039;, handler);

// Wildcard (all user events)
pan.subscribe(&#039;user.*&#039;, handler);

// All events (useful for debugging)
pan.subscribe(&#039;*&#039;, handler);</code></pre>
<h3>Message Patterns</h3>
<p>The PAN bus supports several messaging patterns:</p>
<p>#### 1. Fire and Forget</p>
<p>Most common pattern. Publish a message and continue:</p>
<pre><code class="language-javascript">pan.publish(&#039;notification.show&#039;, {
  type: &#039;success&#039;,
  message: &#039;Saved successfully&#039;
});</code></pre>
<p>#### 2. Request/Response</p>
<p>Publish a message and wait for a response:</p>
<pre><code class="language-javascript">const result = await pan.request(&#039;api.fetch&#039;, {
  url: &#039;/api/users&#039;,
  method: &#039;GET&#039;
});</code></pre>
<p>A subscriber handles the request and returns data:</p>
<pre><code class="language-javascript">pan.respond(&#039;api.fetch&#039;, async (data) =&gt; {
  const response = await fetch(data.url, { method: data.method });
  return response.json();
});</code></pre>
<p>#### 3. State Broadcast</p>
<p>Publish state changes that multiple components need:</p>
<pre><code class="language-javascript">// Theme switcher publishes
pan.publish(&#039;app.theme.change&#039;, { theme: &#039;dark&#039; });

// Multiple components subscribe
class Header extends HTMLElement {
  connectedCallback() {
    pan.subscribe(&#039;app.theme.change&#039;, ({ theme }) =&gt; {
      this.applyTheme(theme);
    });
  }
}

class Sidebar extends HTMLElement {
  connectedCallback() {
    pan.subscribe(&#039;app.theme.change&#039;, ({ theme }) =&gt; {
      this.applyTheme(theme);
    });
  }
}</code></pre>
<h3>Why PAN Bus?</h3>
<p>The PAN bus provides several advantages:</p>
<strong>Loose Coupling</strong>
Components don't need references to each other. Add or remove components without changing others.
<strong>Testability</strong>
Test components in isolation. Mock the bus or test actual pub/sub behavior.
<strong>Debuggability</strong>
Subscribe to <code>'*'</code> to log all messages. Visualize message flow easily.
<strong>Scalability</strong>
Add new features by subscribing to existing topics. No need to modify existing code.
<strong>Flexibility</strong>
Mix different communication patterns (events, requests, broadcasts) as needed.
<h2>Event-Driven Architecture</h2>
<p>LARC applications use event-driven architecture (EDA) at multiple levels:</p>
<h3>Browser Events</h3>
<p>Standard DOM events for user interaction:</p>
<pre><code class="language-javascript">class ClickCounter extends HTMLElement {
  constructor() {
    super();
    this.count = 0;
  }

  connectedCallback() {
    this.innerHTML = `
      &lt;button id=&quot;btn&quot;&gt;Clicked ${this.count} times&lt;/button&gt;
    `;

    this.querySelector(&#039;#btn&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.count++;
      this.querySelector(&#039;#btn&#039;).textContent = `Clicked ${this.count} times`;
    });
  }
}</code></pre>
<h3>Custom Events</h3>
<p>Components can dispatch custom events for parent components:</p>
<pre><code class="language-javascript">class ColorPicker extends HTMLElement {
  selectColor(color) {
    // Dispatch custom event
    this.dispatchEvent(new CustomEvent(&#039;colorchange&#039;, {
      detail: { color },
      bubbles: true,
      composed: true  // Cross shadow DOM boundary
    }));
  }
}

// Parent can listen
document.querySelector(&#039;color-picker&#039;).addEventListener(&#039;colorchange&#039;, (e) =&gt; {
  console.log(&#039;Selected color:&#039;, e.detail.color);
});</code></pre>
<h3>PAN Bus Events</h3>
<p>For cross-component communication:</p>
<pre><code class="language-javascript">class SearchBox extends HTMLElement {
  handleInput(value) {
    pan.publish(&#039;search.query&#039;, { query: value });
  }
}

class SearchResults extends HTMLElement {
  connectedCallback() {
    pan.subscribe(&#039;search.query&#039;, ({ query }) =&gt; {
      this.search(query);
    });
  }
}</code></pre>
<h3>When to Use Each</h3>
<strong>Use DOM Events when:</strong>
<ul><li>Handling user interactions (click, input, focus, etc.)</li>
<li>Communication is parent-child relationship</li>
<li>Following HTML semantics matters</li>
</ul>
<strong>Use Custom Events when:</strong>
<ul><li>Component needs to notify parent/ancestors</li>
<li>Event should bubble up the DOM tree</li>
<li>Mimicking native element behavior</li>
</ul>
<strong>Use PAN Bus when:</strong>
<ul><li>Components are not in parent-child relationship</li>
<li>Multiple unrelated components need the same data</li>
<li>Decoupling is more important than DOM semantics</li>
<li>Building cross-cutting concerns (logging, analytics, etc.)</li>
</ul>
<h2>State Management Philosophy</h2>
<p>LARC takes a pragmatic approach to state management: use the simplest solution that works, then scale up if needed.</p>
<h3>State Hierarchy</h3>
<p>State can exist at different levels:</p>
<p>#### 1. Component-Local State</p>
<p>State that only matters to one component:</p>
<pre><code class="language-javascript">class TodoItem extends HTMLElement {
  constructor() {
    super();
    this.completed = false;  // Local state
  }

  toggle() {
    this.completed = !this.completed;
    this.render();
  }

  render() {
    this.classList.toggle(&#039;completed&#039;, this.completed);
  }
}</code></pre>
<strong>When to use:</strong> UI state, temporary values, component-specific configuration.
<p>#### 2. Shared State</p>
<p>State that multiple components need:</p>
<pre><code class="language-javascript">// Simple shared state object
const appState = {
  user: null,
  theme: &#039;light&#039;,
  notifications: []
};

// Components read from it
class UserMenu extends HTMLElement {
  connectedCallback() {
    this.render(appState.user);
  }
}

// Components write to it and notify via PAN
function updateTheme(theme) {
  appState.theme = theme;
  pan.publish(&#039;app.theme.change&#039;, { theme });
}</code></pre>
<strong>When to use:</strong> Application-wide settings, user data, feature flags.
<p>#### 3. Persistent State</p>
<p>State that survives page reloads:</p>
<pre><code class="language-javascript">class TodoList extends HTMLElement {
  loadTodos() {
    const saved = localStorage.getItem(&#039;todos&#039;);
    return saved ? JSON.parse(saved) : [];
  }

  saveTodos(todos) {
    localStorage.setItem(&#039;todos&#039;, JSON.stringify(todos));
  }
}</code></pre>
<strong>When to use:</strong> User preferences, draft content, offline data.
<p>#### 4. Server State</p>
<p>State that comes from and syncs with a server:</p>
<pre><code class="language-javascript">class UserProfile extends HTMLElement {
  async loadProfile() {
    const response = await fetch(&#039;/api/profile&#039;);
    this.profile = await response.json();
    this.render();
  }

  async saveProfile(updates) {
    await fetch(&#039;/api/profile&#039;, {
      method: &#039;PUT&#039;,
      body: JSON.stringify(updates)
    });
  }
}</code></pre>
<strong>When to use:</strong> Database records, API data, real-time updates.
<h3>Reactive State (Optional)</h3>
<p>For more complex state needs, LARC provides reactive patterns using JavaScript Proxies:</p>
<pre><code class="language-javascript">function createStore(initialState) {
  const listeners = new Set();

  const state = new Proxy(initialState, {
    set(target, property, value) {
      target[property] = value;
      listeners.forEach(fn =&gt; fn(property, value));
      return true;
    }
  });

  return {
    state,
    subscribe(fn) {
      listeners.add(fn);
      return () =&gt; listeners.delete(fn);
    }
  };
}

// Usage
const store = createStore({ count: 0 });

class Counter extends HTMLElement {
  connectedCallback() {
    // Subscribe to changes
    this.unsubscribe = store.subscribe((prop, value) =&gt; {
      if (prop === &#039;count&#039;) this.render();
    });

    this.render();
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  render() {
    this.textContent = `Count: ${store.state.count}`;
  }
}

// Update state (automatically notifies subscribers)
store.state.count++;</code></pre>
<p>This is similar to MobX or Vue's reactivity, but built with standard JavaScript.</p>
<h2>Module System</h2>
<p>LARC uses ES Modules, the native JavaScript module system.</p>
<h3>Import/Export Basics</h3>
<p>Export from a module:</p>
<pre><code class="language-javascript">// components/button.js
export class PanButton extends HTMLElement {
  // ...
}

export const BUTTON_TYPES = [&#039;primary&#039;, &#039;secondary&#039;, &#039;danger&#039;];

export default PanButton;</code></pre>
<p>Import into another module:</p>
<pre><code class="language-javascript">// app.js
import PanButton, { BUTTON_TYPES } from &#039;./components/button.js&#039;;

// Or import everything
import * as Button from &#039;./components/button.js&#039;;</code></pre>
<h3>Import Maps</h3>
<p>Import Maps let you define aliases for module paths:</p>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@2.0.0/pan.mjs&quot;,
    &quot;@larcjs/ui&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/components@2.0.0/pan-card.mjs&quot;,
    &quot;app/&quot;: &quot;/src/&quot;,
    &quot;components/&quot;: &quot;/&quot;
  }
}
&lt;/script&gt;

&lt;script type=&quot;module&quot;&gt;
  // Use aliases
  import { pan } from &#039;@larcjs/core&#039;;
  import { PanButton } from &#039;@larcjs/ui&#039;;
  import { Header } from &#039;components/header.js&#039;;
&lt;/script&gt;</code></pre>
<p>This is similar to webpack's resolve aliases, but it's a browser standard.</p>
<h3>Module Organization</h3>
<p>A typical LARC project structure:</p>
<pre><code class="language-plaintext">src/
├── components/
│   ├── header.js
│   ├── footer.js
│   └── sidebar.js
├── lib/
│   ├── api.js
│   ├── auth.js
│   └── utils.js
├── pages/
│   ├── home.js
│   ├── dashboard.js
│   └── profile.js
└── app.js</code></pre>
<p>Each file is a module with clear responsibilities:</p>
<pre><code class="language-javascript">// src/lib/api.js
export async function fetchJSON(url, options = {}) {
  const response = await fetch(url, {
    ...options,
    headers: {
      &#039;Content-Type&#039;: &#039;application/json&#039;,
      ...options.headers
    }
  });

  if (!response.ok) {
    throw new Error(`API error: ${response.status}`);
  }

  return response.json();
}

// src/components/user-list.js
import { fetchJSON } from &#039;../lib/api.js&#039;;

export class UserList extends HTMLElement {
  async connectedCallback() {
    const users = await fetchJSON(&#039;/api/users&#039;);
    this.render(users);
  }
}

customElements.define(&#039;user-list&#039;, UserList);</code></pre>
<h2>The Component Lifecycle</h2>
<p>Understanding the component lifecycle is essential for building robust LARC applications.</p>
<h3>Lifecycle Callbacks</h3>
<p>Web Components provide several lifecycle callbacks:</p>
<p>#### constructor()</p>
<p>Called when an instance is created:</p>
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  constructor() {
    // MUST call super() first
    super();

    // Initialize instance properties
    this.count = 0;
    this.data = null;

    // Attach shadow DOM if needed
    this.attachShadow({ mode: &#039;open&#039; });

    // DON&#039;T access attributes or children here
    // They might not be set yet
  }
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Always call <code>super()</code> first</li>
<li>Initialize instance properties</li>
<li>Attach shadow DOM</li>
<li>Don't access attributes, children, or parent elements</li>
<li>Don't render here (use <code>connectedCallback</code> instead)</li>
</ul>
#### connectedCallback()
<p>Called when the element is inserted into the DOM:</p>
<pre><code class="language-javascript">connectedCallback() {
  // Now it&#039;s safe to access attributes, children, parent
  const title = this.getAttribute(&#039;title&#039;);

  // Render initial content
  this.render();

  // Add event listeners
  this.addEventListener(&#039;click&#039;, this.handleClick);

  // Fetch data
  this.loadData();

  // Subscribe to PAN events
  this.unsubscribe = pan.subscribe(&#039;data.update&#039;, this.handleUpdate);
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Render initial content</li>
<li>Add event listeners</li>
<li>Subscribe to events</li>
<li>Fetch initial data</li>
<li>Can be called multiple times if element is moved</li>
</ul>
#### disconnectedCallback()
<p>Called when the element is removed from the DOM:</p>
<pre><code class="language-javascript">disconnectedCallback() {
  // Clean up event listeners
  this.removeEventListener(&#039;click&#039;, this.handleClick);

  // Unsubscribe from PAN events
  if (this.unsubscribe) {
    this.unsubscribe();
  }

  // Cancel pending operations
  if (this.fetchController) {
    this.fetchController.abort();
  }

  // Clear timers
  if (this.timer) {
    clearInterval(this.timer);
  }
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Remove event listeners to prevent memory leaks</li>
<li>Unsubscribe from PAN events</li>
<li>Cancel pending async operations</li>
<li>Clear timers and intervals</li>
</ul>
#### attributeChangedCallback(name, oldValue, newValue)
<p>Called when observed attributes change:</p>
<pre><code class="language-javascript">static get observedAttributes() {
  return [&#039;title&#039;, &#039;count&#039;, &#039;active&#039;];
}

attributeChangedCallback(name, oldValue, newValue) {
  // Called for each observed attribute that changes
  if (name === &#039;title&#039;) {
    this.updateTitle(newValue);
  } else if (name === &#039;count&#039;) {
    this.updateCount(Number(newValue));
  } else if (name === &#039;active&#039;) {
    this.updateActive(newValue !== null);
  }
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Only observe attributes you actually use</li>
<li>Convert string values to appropriate types</li>
<li>Handle null/undefined values</li>
<li>Update only what changed (don't re-render everything)</li>
</ul>
#### adoptedCallback()
<p>Called when the element is moved to a new document (rare):</p>
<pre><code class="language-javascript">adoptedCallback() {
  // Usually not needed
  // Called when element is moved between documents
  // (e.g., iframe scenarios)
}</code></pre>
<h3>Complete Lifecycle Example</h3>
<p>Here's a full component showing proper lifecycle management:</p>
<pre><code class="language-javascript">class DataTable extends HTMLElement {
  // Define which attributes to observe
  static get observedAttributes() {
    return [&#039;url&#039;, &#039;page-size&#039;];
  }

  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });

    // Initialize state
    this.data = [];
    this.pageSize = 10;
    this.currentPage = 1;
  }

  async connectedCallback() {
    // Initial render
    this.render();

    // Load data if URL is set
    const url = this.getAttribute(&#039;url&#039;);
    if (url) {
      await this.loadData(url);
    }

    // Subscribe to events
    this.unsubscribePan = pan.subscribe(&#039;table.refresh&#039;, () =&gt; {
      this.refresh();
    });

    // Set up event listeners
    this.addEventListener(&#039;page-change&#039;, this.handlePageChange);
  }

  disconnectedCallback() {
    // Clean up subscriptions
    if (this.unsubscribePan) {
      this.unsubscribePan();
    }

    // Remove event listeners
    this.removeEventListener(&#039;page-change&#039;, this.handlePageChange);

    // Cancel pending fetch
    if (this.fetchController) {
      this.fetchController.abort();
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    if (name === &#039;url&#039; &amp;&amp; newValue) {
      this.loadData(newValue);
    } else if (name === &#039;page-size&#039;) {
      this.pageSize = Number(newValue) || 10;
      this.render();
    }
  }

  async loadData(url) {
    // Cancel previous fetch if any
    if (this.fetchController) {
      this.fetchController.abort();
    }

    this.fetchController = new AbortController();

    try {
      const response = await fetch(url, {
        signal: this.fetchController.signal
      });
      this.data = await response.json();
      this.render();
    } catch (error) {
      if (error.name !== &#039;AbortError&#039;) {
        console.error(&#039;Failed to load data:&#039;, error);
      }
    }
  }

  render() {
    // Render logic here
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
      &lt;/style&gt;
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Status&lt;/th&gt;&lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          ${this.data.map(row =&gt; `
            &lt;tr&gt;
              &lt;td&gt;${row.id}&lt;/td&gt;
              &lt;td&gt;${row.name}&lt;/td&gt;
              &lt;td&gt;${row.status}&lt;/td&gt;
            &lt;/tr&gt;
          `).join(&#039;&#039;)}
        &lt;/tbody&gt;
      &lt;/table&gt;
    `;
  }

  handlePageChange = (event) =&gt; {
    this.currentPage = event.detail.page;
    this.render();
  }

  async refresh() {
    const url = this.getAttribute(&#039;url&#039;);
    if (url) {
      await this.loadData(url);
    }
  }
}

customElements.define(&#039;data-table&#039;, DataTable);</code></pre>
<h2>Summary</h2>
<p>This chapter introduced LARC's core concepts:</p>
<ul><li><strong>Web Components</strong> provide standard, reusable elements with Custom Elements, Shadow DOM, and Templates</li>
<li><strong>The PAN Bus</strong> enables decoupled pub/sub communication between components</li>
<li><strong>Event-Driven Architecture</strong> uses DOM events, custom events, and PAN messages for different scenarios</li>
<li><strong>State Management</strong> starts simple (local state) and scales to shared, persistent, and server state</li>
<li><strong>ES Modules</strong> organize code with standard imports/exports and import maps</li>
<li><strong>Component Lifecycle</strong> provides callbacks for creation, connection, attribute changes, and cleanup</li>
</ul>
In the next chapter, we'll put these concepts into practice by setting up a development environment and building your first LARC application.
<hr>
<h2>Key Takeaways</h2>
<ul><li>Web Components are browser standards, not framework abstractions</li>
<li>Shadow DOM provides true style encapsulation</li>
<li>The PAN bus decouples components through pub/sub messaging</li>
<li>Use the simplest state management that works, then scale up</li>
<li>ES Modules and Import Maps replace build-time bundling</li>
<li>Proper lifecycle management prevents bugs and memory leaks</li>
<li>Components should be self-contained but composable</li>
</ul>
\pagebreak
<h1>Chapter 3: Getting Started</h1>
<p>Theory is important, but there's no substitute for hands-on experience. In this chapter, you'll set up your development environment and build your first LARC application. By the end, you'll have a working project and understand the basic development workflow.</p>
<h2>Setting Up Your Development Environment</h2>
<p>One of LARC's strengths is minimal setup requirements. You don't need complex tooling or configuration—just a browser, a text editor, and a way to serve files.</p>
<h3>Requirements</h3>
<strong>Essential:</strong>
<ul><li><strong>Modern browser</strong> — Chrome, Firefox, Safari, or Edge (latest version)</li>
<li><strong>Text editor</strong> — VS Code, Sublime Text, Atom, or any editor you prefer</li>
<li><strong>Local web server</strong> — Python's SimpleHTTPServer, Node's <code>http-server</code>, or VS Code's Live Server extension</li>
</ul>
<strong>Optional but Recommended:</strong>
<ul><li><strong>VS Code</strong> with the LARC extension for snippets and IntelliSense</li>
<li><strong>Browser DevTools</strong> familiarity for debugging</li>
<li><strong>Git</strong> for version control</li>
</ul>
<h3>Quick Start with create-larc-app</h3>
<p>The fastest way to start is using the LARC CLI:</p>
<pre><code class="language-bash"># Install globally
npm install -g create-larc-app

# Create a new project
create-larc-app my-first-app

# Start development server
cd my-first-app
larc dev</code></pre>
<p>Open <code>http://localhost:3000</code> and you'll see your new LARC application running.</p>
<h3>Manual Setup (No CLI)</h3>
<p>Don't want to install Node.js? You can set up a LARC project manually:</p>
<strong>1. Create project structure:</strong>
<pre><code class="language-bash">mkdir my-first-app
cd my-first-app
mkdir src
mkdir src/components
mkdir public</code></pre>
<strong>2. Create <code>index.html</code>:</strong>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;My First LARC App&lt;/title&gt;

  &lt;!-- Import Map for dependencies --&gt;
  &lt;script type=&quot;importmap&quot;&gt;
  {
    &quot;imports&quot;: {
      &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@2.0.0/pan.mjs&quot;
    }
  }
  &lt;/script&gt;

  &lt;style&gt;
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

  &lt;script type=&quot;module&quot; src=&quot;src/app.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<strong>3. Create <code>src/app.js</code>:</strong>
<pre><code class="language-javascript">import { pan } from &#039;@larcjs/core&#039;;

// Import your components
import &#039;./components/hello-world.js&#039;;

// Initialize app
console.log(&#039;LARC app initialized&#039;);
pan.publish(&#039;app.ready&#039;);

// Add component to page
document.getElementById(&#039;app&#039;).innerHTML = &#039;&lt;hello-world&gt;&lt;/hello-world&gt;&#039;;</code></pre>
<strong>4. Create <code>src/components/hello-world.js</code>:</strong>
<pre><code class="language-javascript">class HelloWorld extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;div style=&quot;
        background: white;
        padding: 40px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        text-align: center;
      &quot;&gt;
        &lt;h1&gt;Hello, LARC!&lt;/h1&gt;
        &lt;p&gt;Welcome to your first LARC application.&lt;/p&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;hello-world&#039;, HelloWorld);</code></pre>
<strong>5. Serve the files:</strong>
<pre><code class="language-bash"># Python 3
python3 -m http.server 3000

# Or Python 2
python -m SimpleHTTPServer 3000

# Or with Node.js
npx http-server -p 3000

# Or use VS Code Live Server extension
# (right-click index.html → &quot;Open with Live Server&quot;)</code></pre>
<p>Open <code>http://localhost:3000</code> and you should see "Hello, LARC!" displayed.</p>
<strong>That's it.</strong> No build step. No transpilation. No bundling. Just HTML, CSS, and JavaScript.
<h3>Development Tools</h3>
<p>#### VS Code Extensions</p>
<p>Install these extensions for the best experience:</p>
<strong>LARC Extension:</strong>
<ul><li>Snippets for components and PAN patterns</li>
<li>IntelliSense for LARC APIs</li>
<li>Commands for creating components</li>
</ul>
Install: Search "LARC" in VS Code extensions marketplace
<strong>Live Server:</strong>
<ul><li>Auto-reload when files change</li>
<li>Simple local web server</li>
<li>Right-click HTML file to start</li>
</ul>
Install: Search "Live Server" by Ritwick Dey
<strong>ES6 String HTML:</strong>
<ul><li>Syntax highlighting for template literals</li>
<li>Makes component templates more readable</li>
</ul>
Install: Search "ES6 String HTML"
<p>#### Browser DevTools</p>
<p>Learn these DevTools features for LARC development:</p>
<strong>Elements Panel:</strong>
<p>- Inspect shadow DOM (enable "Show user agent shadow DOM" in settings)
    - View Custom Elements with their properties
    - Debug CSS in shadow roots</p>
<strong>Console:</strong>
<p>- Subscribe to all PAN messages: <code>pan.subscribe('*', console.log)</code>
    - Test components directly: <code>document.querySelector('my-component')</code>
    - Check Custom Elements registry: <code>customElements.get('my-component')</code></p>
<strong>Network Panel:</strong>
<p>- Verify ES modules load correctly
    - Check import map resolution
    - Monitor API calls</p>
<strong>Sources Panel:</strong>
<p>- Set breakpoints in your source code (no source maps needed!)
    - Step through component lifecycle
    - Watch variables and state</p>
<h2>Your First LARC Application</h2>
<p>Let's build something more interesting than "Hello World"—a simple counter application with multiple components communicating via the PAN bus.</p>
<h3>Project Goal</h3>
<p>We'll create:</p>
<p>- A counter display component
    - Increment and decrement buttons
    - A reset button
    - Communication via PAN bus (no prop drilling!)</p>
<h3>Step 1: Update index.html</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Counter App - LARC&lt;/title&gt;

  &lt;script type=&quot;importmap&quot;&gt;
  {
    &quot;imports&quot;: {
      &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@2.0.0/pan.mjs&quot;
    }
  }
  &lt;/script&gt;

  &lt;style&gt;
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, &#039;Segoe UI&#039;, Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #app {
      background: white;
      padding: 40px;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      min-width: 400px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;counter-display&gt;&lt;/counter-display&gt;
    &lt;counter-controls&gt;&lt;/counter-controls&gt;
  &lt;/div&gt;

  &lt;script type=&quot;module&quot; src=&quot;src/app.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3>Step 2: Create app.js</h3>
<pre><code class="language-javascript">// src/app.js
import { pan } from &#039;@larcjs/core&#039;;

// Import components
import &#039;./components/counter-display.js&#039;;
import &#039;./components/counter-controls.js&#039;;

// Initialize application state
let count = 0;

// Listen for increment requests
pan.subscribe(&#039;counter.increment&#039;, () =&gt; {
  count++;
  pan.publish(&#039;counter.updated&#039;, { count });
});

// Listen for decrement requests
pan.subscribe(&#039;counter.decrement&#039;, () =&gt; {
  count--;
  pan.publish(&#039;counter.updated&#039;, { count });
});

// Listen for reset requests
pan.subscribe(&#039;counter.reset&#039;, () =&gt; {
  count = 0;
  pan.publish(&#039;counter.updated&#039;, { count });
});

// Publish initial state
pan.publish(&#039;counter.updated&#039;, { count });

console.log(&#039;Counter app initialized&#039;);</code></pre>
<h3>Step 3: Create counter-display.js</h3>
<pre><code class="language-javascript">// src/components/counter-display.js
import { pan } from &#039;@larcjs/core&#039;;

class CounterDisplay extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.count = 0;
  }

  connectedCallback() {
    // Subscribe to count updates
    this.unsubscribe = pan.subscribe(&#039;counter.updated&#039;, ({ count }) =&gt; {
      this.count = count;
      this.render();
    });

    this.render();
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          text-align: center;
          margin-bottom: 30px;
        }

        .display {
          font-size: 72px;
          font-weight: bold;
          color: #667eea;
          margin-bottom: 10px;
          font-variant-numeric: tabular-nums;
        }

        .label {
          font-size: 18px;
          color: #666;
          text-transform: uppercase;
          letter-spacing: 2px;
        }
      &lt;/style&gt;

      &lt;div class=&quot;display&quot;&gt;${this.count}&lt;/div&gt;
      &lt;div class=&quot;label&quot;&gt;Current Count&lt;/div&gt;
    `;
  }
}

customElements.define(&#039;counter-display&#039;, CounterDisplay);</code></pre>
<h3>Step 4: Create counter-controls.js</h3>
<pre><code class="language-javascript">// src/components/counter-controls.js
import { pan } from &#039;@larcjs/core&#039;;

class CounterControls extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  connectedCallback() {
    this.render();
    this.attachEventListeners();
  }

  attachEventListeners() {
    this.shadowRoot.querySelector(&#039;#increment&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      pan.publish(&#039;counter.increment&#039;);
    });

    this.shadowRoot.querySelector(&#039;#decrement&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      pan.publish(&#039;counter.decrement&#039;);
    });

    this.shadowRoot.querySelector(&#039;#reset&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      pan.publish(&#039;counter.reset&#039;);
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
        }

        .controls {
          display: flex;
          gap: 10px;
          margin-bottom: 15px;
        }

        button {
          flex: 1;
          padding: 15px;
          font-size: 16px;
          font-weight: 600;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.2s;
        }

        button:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        button:active {
          transform: translateY(0);
        }

        #increment {
          background: #48bb78;
          color: white;
        }

        #increment:hover {
          background: #38a169;
        }

        #decrement {
          background: #f56565;
          color: white;
        }

        #decrement:hover {
          background: #e53e3e;
        }

        #reset {
          background: #4a5568;
          color: white;
          width: 100%;
        }

        #reset:hover {
          background: #2d3748;
        }
      &lt;/style&gt;

      &lt;div class=&quot;controls&quot;&gt;
        &lt;button id=&quot;decrement&quot;&gt;− Decrement&lt;/button&gt;
        &lt;button id=&quot;increment&quot;&gt;+ Increment&lt;/button&gt;
      &lt;/div&gt;
      &lt;button id=&quot;reset&quot;&gt;Reset&lt;/button&gt;
    `;
  }
}

customElements.define(&#039;counter-controls&#039;, CounterControls);</code></pre>
<h3>Step 5: Test Your App</h3>
<p>Start your local server and open the page. You should see:</p>
<p>- A large counter display showing "0"
    - Increment and decrement buttons
    - A reset button</p>
<p>Click the buttons. Notice how:</p>
<p>- Components update immediately
    - State is managed centrally in <code>app.js</code>
    - Components don't reference each other directly
    - Adding new components is trivial (just subscribe to <code>counter.updated</code>)</p>
<h3>What Just Happened?</h3>
<p>Let's examine the architecture:</p>
<strong>Data Flow:</strong>
<pre><code class="language-plaintext">User clicks button
     ↓
Controls component publishes event
     ↓
App.js receives event and updates state
     ↓
App.js publishes updated state
     ↓
Display component receives update and re-renders</code></pre>
<strong>Key Points:</strong>
<li><strong>Decoupled Components:</strong> Display and controls don't know about each other</li>
<li><strong>Central State:</strong> State lives in <code>app.js</code>, not in components</li>
<li><strong>Pub/Sub Communication:</strong> All communication via PAN bus topics</li>
<li><strong>No Props:</strong> No prop drilling or lifting state up</li>
<li><strong>Easy Testing:</strong> Each component can be tested in isolation</li>
<h2>Project Structure</h2>
<p>!<a href="../images/01-architecture-overview-5.png"><strong>Figure 3.2:</strong> LARC Deployment Architecture</a></p>
<strong><em>Figure 3.2:</strong> LARC Deployment Architecture</em>
<p>As your application grows, organization becomes important. Here's a recommended structure:</p>
<pre><code class="language-plaintext">my-app/
├── index.html              # Entry point
├── larc.config.json        # Optional config
├── src/
│   ├── app.js              # Main application logic
│   ├── components/         # Reusable components
│   │   ├── ui/             # Generic UI components
│   │   │   ├── button.js
│   │   │   ├── card.js
│   │   │   └── modal.js
│   │   ├── features/       # Feature-specific components
│   │   │   ├── user-profile.js
│   │   │   ├── todo-list.js
│   │   │   └── dashboard.js
│   │   └── layout/         # Layout components
│   │       ├── header.js
│   │       ├── sidebar.js
│   │       └── footer.js
│   ├── lib/                # Utilities and helpers
│   │   ├── api.js          # API client
│   │   ├── auth.js         # Authentication
│   │   ├── router.js       # Routing logic
│   │   └── utils.js        # General utilities
│   ├── pages/              # Page-level components
│   │   ├── home.js
│   │   ├── dashboard.js
│   │   └── settings.js
│   └── styles/             # Global styles
│       ├── reset.css
│       ├── variables.css
│       └── utilities.css
├── public/                 # Static assets
│   ├── images/
│   ├── fonts/
│   └── icons/
└── tests/                  # Test files
    ├── components/
    └── integration/</code></pre>
<h3>File Organization Principles</h3>
<strong>Components:</strong>
<p>- One component per file
    - File name matches component name: <code>user-profile.js</code> defines <code><user-profile></code>
    - Keep related components together in subdirectories</p>
<strong>Lib:</strong>
<p>- Utilities that don't render UI
    - API clients, helpers, formatters
    - Pure functions when possible</p>
<strong>Pages:</strong>
<p>- Top-level route components
    - Compose smaller components
    - Handle page-specific logic</p>
<strong>Styles:</strong>
<p>- Global styles in <code>styles/</code>
    - Component-specific styles in Shadow DOM
    - CSS custom properties for theming</p>
<h2>Import Maps Explained</h2>
<p>!<a href="../images/01-architecture-overview-4.png"><strong>Figure 3.1:</strong> Module Loading with Import Maps</a></p>
<strong><em>Figure 3.1:</strong> Module Loading with Import Maps</em>
<p>Import Maps are a browser standard that replaces the need for bundlers to resolve module paths.</p>
<h3>Basic Import Map</h3>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;lodash&quot;: &quot;https://cdn.jsdelivr.net/npm/lodash-es@4/lodash.js&quot;,
    &quot;dayjs&quot;: &quot;https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js&quot;
  }
}
&lt;/script&gt;

&lt;script type=&quot;module&quot;&gt;
  // Use package names instead of URLs
  import _ from &#039;lodash&#039;;
  import dayjs from &#039;dayjs&#039;;

  console.log(dayjs().format(&#039;YYYY-MM-DD&#039;));
&lt;/script&gt;</code></pre>
<h3>Path Aliases</h3>
<p>Create shortcuts for your own modules:</p>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;@/&quot;: &quot;/src/&quot;,
    &quot;components/&quot;: &quot;/&quot;,
    &quot;lib/&quot;: &quot;/src/lib/&quot;,
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@2.0.0/pan.mjs&quot;
  }
}
&lt;/script&gt;

&lt;script type=&quot;module&quot;&gt;
  // Instead of: import { api } from &#039;../../../lib/api.js&#039;;
  import { api } from &#039;lib/api.js&#039;;

  // Instead of: import Button from &#039;../components/ui/button.js&#039;;
  import Button from &#039;components/ui/button.js&#039;;

  // Instead of: import something from &#039;../../../src/utils.js&#039;;
  import something from &#039;@/utils.js&#039;;
&lt;/script&gt;</code></pre>
<h3>Version Management</h3>
<p>Pin dependencies to specific versions:</p>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@2.0.0/dist/index.js&quot;,
    &quot;@larcjs/ui&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/ui@2.0.1/dist/index.js&quot;
  }
}</code></pre>
<p>Or use version ranges for automatic updates:</p>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@2.0.0/pan.mjs&quot;,
    &quot;@larcjs/ui&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/ui@2/dist/index.js&quot;
  }
}</code></pre>
<h3>Multiple CDNs</h3>
<p>Add fallbacks for reliability:</p>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;react&quot;: &quot;https://esm.sh/react@18&quot;,
    &quot;react-fallback&quot;: &quot;https://cdn.skypack.dev/react@18&quot;
  }
}</code></pre>
<p>Then in code:</p>
<pre><code class="language-javascript">let React;
try {
  React = await import(&#039;react&#039;);
} catch {
  React = await import(&#039;react-fallback&#039;);
}</code></pre>
<h3>Development vs Production</h3>
<p>Use different import maps for different environments:</p>
<strong>development.importmap.json:</strong>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;/node_modules/@larcjs/core/dist/index.js&quot;,
    &quot;app/&quot;: &quot;/src/&quot;
  }
}</code></pre>
<strong>production.importmap.json:</strong>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@2.0.0/dist/index.js&quot;,
    &quot;app/&quot;: &quot;/assets/js/&quot;
  }
}</code></pre>
<p>Load the appropriate map:</p>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot; src=&quot;/config/production.importmap.json&quot;&gt;&lt;/script&gt;</code></pre>
<h2>Development Workflow</h2>
<h3>Daily Development</h3>
<p>A typical development session:</p>
<strong>1. Start dev server:</strong>
<pre><code class="language-bash">larc dev</code></pre>
<p>This starts a local server with hot reload.</p>
<strong>2. Edit files:</strong>
Open your editor and make changes. The browser automatically reloads when you save.
<strong>3. Check the console:</strong>
Open browser DevTools and check for errors or warnings.
<strong>4. Test in browser:</strong>
Interact with your app, verify behavior, check responsive design.
<strong>5. Debug as needed:</strong>
Set breakpoints, inspect elements, monitor network requests.
<strong>6. Repeat:</strong>
The edit-refresh cycle is instant with no build step.
<h3>Debugging Tips</h3>
<strong>Log all PAN messages:</strong>
<pre><code class="language-javascript">pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
  console.log(`[PAN] ${topic}:`, data);
});</code></pre>
<strong>Inspect custom elements:</strong>
<pre><code class="language-javascript">// Get element
const el = document.querySelector(&#039;my-component&#039;);

// Check if defined
console.log(customElements.get(&#039;my-component&#039;));

// Access shadow root
console.log(el.shadowRoot);

// Call methods directly
el.someMethod();</code></pre>
<strong>Monitor attribute changes:</strong>
<pre><code class="language-javascript">// Create observer
const observer = new MutationObserver((mutations) =&gt; {
  mutations.forEach(mutation =&gt; {
    console.log(&#039;Attribute changed:&#039;, mutation.attributeName);
  });
});

// Watch element
observer.observe(element, { attributes: true });</code></pre>
<h3>Testing</h3>
<p>Run tests without a build step:</p>
<pre><code class="language-html">&lt;!-- tests/counter.test.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Counter Tests&lt;/title&gt;
  &lt;script type=&quot;importmap&quot;&gt;
  {
    &quot;imports&quot;: {
      &quot;@larcjs/core&quot;: &quot;../node_modules/@larcjs/core/dist/index.js&quot;
    }
  }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;test-container&quot;&gt;&lt;/div&gt;

  &lt;script type=&quot;module&quot;&gt;
    import { pan } from &#039;@larcjs/core&#039;;
    import &#039;../counter-display.js&#039;;

    // Simple test framework
    function test(name, fn) {
      try {
        fn();
        console.log(`✓ ${name}`);
      } catch (error) {
        console.error(`✗ ${name}:`, error);
      }
    }

    function assert(condition, message) {
      if (!condition) throw new Error(message || &#039;Assertion failed&#039;);
    }

    // Tests
    test(&#039;counter-display renders initial count&#039;, () =&gt; {
      const el = document.createElement(&#039;counter-display&#039;);
      document.getElementById(&#039;test-container&#039;).appendChild(el);

      const display = el.shadowRoot.querySelector(&#039;.display&#039;);
      assert(display.textContent === &#039;0&#039;, &#039;Initial count should be 0&#039;);

      el.remove();
    });

    test(&#039;counter-display updates on PAN message&#039;, async () =&gt; {
      const el = document.createElement(&#039;counter-display&#039;);
      document.getElementById(&#039;test-container&#039;).appendChild(el);

      // Wait for component to connect
      await new Promise(resolve =&gt; setTimeout(resolve, 10));

      // Publish update
      pan.publish(&#039;counter.updated&#039;, { count: 42 });

      // Wait for render
      await new Promise(resolve =&gt; setTimeout(resolve, 10));

      const display = el.shadowRoot.querySelector(&#039;.display&#039;);
      assert(display.textContent === &#039;42&#039;, &#039;Count should update to 42&#039;);

      el.remove();
    });

    console.log(&#039;All tests complete&#039;);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Open <code>tests/counter.test.html</code> in your browser to run tests.</p>
<h2>Common Patterns</h2>
<h3>Pattern 1: Loading States</h3>
<pre><code class="language-javascript">class DataComponent extends HTMLElement {
  async connectedCallback() {
    this.render({ loading: true });

    try {
      const data = await this.fetchData();
      this.render({ data });
    } catch (error) {
      this.render({ error: error.message });
    }
  }

  render(state) {
    if (state.loading) {
      this.innerHTML = &#039;&lt;loading-spinner&gt;&lt;/loading-spinner&gt;&#039;;
    } else if (state.error) {
      this.innerHTML = `&lt;error-message&gt;${state.error}&lt;/error-message&gt;`;
    } else {
      this.innerHTML = `&lt;data-display .data=&quot;${state.data}&quot;&gt;&lt;/data-display&gt;`;
    }
  }
}</code></pre>
<h3>Pattern 2: Form Handling</h3>
<pre><code class="language-javascript">class LoginForm extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;form&gt;
        &lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt;
        &lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt;
        &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;
      &lt;/form&gt;
    `;

    this.querySelector(&#039;form&#039;).addEventListener(&#039;submit&#039;, async (e) =&gt; {
      e.preventDefault();

      const formData = new FormData(e.target);
      const data = Object.fromEntries(formData);

      pan.publish(&#039;auth.login&#039;, data);
    });
  }
}</code></pre>
<h3>Pattern 3: Conditional Rendering</h3>
<pre><code class="language-javascript">class UserMenu extends HTMLElement {
  constructor() {
    super();
    this.user = null;
  }

  connectedCallback() {
    pan.subscribe(&#039;auth.user.changed&#039;, ({ user }) =&gt; {
      this.user = user;
      this.render();
    });

    this.render();
  }

  render() {
    if (this.user) {
      this.innerHTML = `
        &lt;div class=&quot;logged-in&quot;&gt;
          &lt;span&gt;Hello, ${this.user.name}&lt;/span&gt;
          &lt;button id=&quot;logout&quot;&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
      `;

      this.querySelector(&#039;#logout&#039;).addEventListener(&#039;click&#039;, () =&gt; {
        pan.publish(&#039;auth.logout&#039;);
      });
    } else {
      this.innerHTML = `
        &lt;button id=&quot;login&quot;&gt;Login&lt;/button&gt;
      `;

      this.querySelector(&#039;#login&#039;).addEventListener(&#039;click&#039;, () =&gt; {
        pan.publish(&#039;app.navigate&#039;, { path: &#039;/login&#039; });
      });
    }
  }
}</code></pre>
<h3>Pattern 4: Lists and Iteration</h3>
<pre><code class="language-javascript">class TodoList extends HTMLElement {
  constructor() {
    super();
    this.todos = [];
  }

  connectedCallback() {
    pan.subscribe(&#039;todos.updated&#039;, ({ todos }) =&gt; {
      this.todos = todos;
      this.render();
    });

    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;ul&gt;
        ${this.todos.map(todo =&gt; `
          &lt;li&gt;
            &lt;input type=&quot;checkbox&quot;
                   ${todo.completed ? &#039;checked&#039; : &#039;&#039;}
                   data-id=&quot;${todo.id}&quot;&gt;
            &lt;span class=&quot;${todo.completed ? &#039;completed&#039; : &#039;&#039;}&quot;&gt;
              ${todo.text}
            &lt;/span&gt;
          &lt;/li&gt;
        `).join(&#039;&#039;)}
      &lt;/ul&gt;
    `;

    // Attach event listeners after rendering
    this.querySelectorAll(&#039;input[type=&quot;checkbox&quot;]&#039;).forEach(checkbox =&gt; {
      checkbox.addEventListener(&#039;change&#039;, (e) =&gt; {
        const id = e.target.dataset.id;
        pan.publish(&#039;todos.toggle&#039;, { id });
      });
    });
  }
}</code></pre>
<h2>Summary</h2>
<p>In this chapter, you:</p>
<p>- Set up a LARC development environment (CLI or manual)
    - Built your first multi-component application
    - Learned project structure best practices
    - Mastered Import Maps for dependency management
    - Established an efficient development workflow
    - Explored common component patterns</p>
<p>You now have a solid foundation for building LARC applications. The next chapter dives deeper into creating sophisticated Web Components with proper lifecycle management, styling, and interactivity.</p>
<hr>
<h2>Exercises</h2>
<strong>1. Enhance the Counter App:</strong>
<p>- Add a history component that shows past values
    - Add increment/decrement by custom amounts
    - Persist count to localStorage</p>
<strong>2. Build a Todo List:</strong>
<p>- Add/remove todos
    - Mark as complete/incomplete
    - Filter by status (all/active/completed)
    - Use PAN bus for state management</p>
<strong>3. Create a Theme Switcher:</strong>
<p>- Light/dark theme toggle
    - Publish theme changes via PAN
    - Multiple components respond to theme changes
    - Persist theme preference</p>
<strong>4. Experiment with Import Maps:</strong>
<p>- Try different CDNs (jsDelivr, unpkg, esm.sh)
    - Add path aliases for your components
    - Import an external library (lodash, dayjs, etc.)</p>
<p>Take your time with these exercises. Understanding these patterns now will make the rest of the book much easier.</p>
<p>\pagebreak</p>
<h1>Chapter 4: Creating Web Components</h1>
<p>Now that you've built your first LARC application, it's time to master the art of creating robust, reusable Web Components. This chapter covers everything from basic component anatomy to advanced patterns like composition, slots, and performance optimization.</p>
<p>By the end of this chapter, you'll be able to build production-quality components that are maintainable, testable, and performant.</p>
<h2>Anatomy of a LARC Component</h2>
<p>!<a href="../images/02-component-structure-3.png"><strong>Figure 4.1:</strong> Component Lifecycle Flow</a></p>
<strong><em>Figure 4.1:</strong> Component Lifecycle Flow</em>
<p>Let's dissect a well-structured LARC component to understand its parts:</p>
<pre><code class="language-javascript">// Import dependencies
import { pan } from &#039;@larcjs/core&#039;;
import { formatDate } from &#039;../lib/utils.js&#039;;

/**
 * A card component for displaying user information.
 *
 * @element user-card
 *
 * @attr {string} user-id - The ID of the user to display
 * @attr {boolean} compact - Display in compact mode
 *
 * @fires user-selected - Dispatched when card is clicked
 *
 * @slot - Default slot for additional content
 * @slot actions - Slot for action buttons
 */
class UserCard extends HTMLElement {
  // 1. Define observed attributes
  static get observedAttributes() {
    return [&#039;user-id&#039;, &#039;compact&#039;];
  }

  // 2. Constructor - initialize instance
  constructor() {
    super();

    // Attach shadow DOM
    this.attachShadow({ mode: &#039;open&#039; });

    // Initialize private state
    this._user = null;
    this._loading = false;
    this._error = null;

    // Bind event handlers
    this.handleClick = this.handleClick.bind(this);
  }

  // 3. Lifecycle: connected to DOM
  connectedCallback() {
    this.render();

    // Load user data if ID is provided
    const userId = this.getAttribute(&#039;user-id&#039;);
    if (userId) {
      this.loadUser(userId);
    }

    // Subscribe to PAN events
    this.unsubscribe = pan.subscribe(&#039;user.updated&#039;, this.handleUserUpdate);

    // Add event listeners
    this.shadowRoot.addEventListener(&#039;click&#039;, this.handleClick);
  }

  // 4. Lifecycle: disconnected from DOM
  disconnectedCallback() {
    // Clean up subscriptions
    if (this.unsubscribe) {
      this.unsubscribe();
    }

    // Remove event listeners
    this.shadowRoot.removeEventListener(&#039;click&#039;, this.handleClick);
  }

  // 5. Lifecycle: attributes changed
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    if (name === &#039;user-id&#039; &amp;&amp; newValue) {
      this.loadUser(newValue);
    } else if (name === &#039;compact&#039;) {
      this.render();
    }
  }

  // 6. Public properties with getters/setters
  get user() {
    return this._user;
  }

  set user(value) {
    this._user = value;
    this.render();
  }

  get loading() {
    return this._loading;
  }

  // 7. Public methods
  async loadUser(userId) {
    this._loading = true;
    this._error = null;
    this.render();

    try {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error(&#039;Failed to load user&#039;);

      this._user = await response.json();
      this._loading = false;
      this.render();
    } catch (error) {
      this._error = error.message;
      this._loading = false;
      this.render();
    }
  }

  refresh() {
    const userId = this.getAttribute(&#039;user-id&#039;);
    if (userId) {
      this.loadUser(userId);
    }
  }

  // 8. Private methods
  handleClick(event) {
    if (!this._user) return;

    this.dispatchEvent(new CustomEvent(&#039;user-selected&#039;, {
      detail: { user: this._user },
      bubbles: true,
      composed: true
    }));
  }

  handleUserUpdate = (data) =&gt; {
    if (data.userId === this.getAttribute(&#039;user-id&#039;)) {
      this._user = data.user;
      this.render();
    }
  }

  // 9. Render method
  render() {
    const compact = this.hasAttribute(&#039;compact&#039;);

    if (this._loading) {
      this.shadowRoot.innerHTML = this.renderLoading();
      return;
    }

    if (this._error) {
      this.shadowRoot.innerHTML = this.renderError();
      return;
    }

    if (!this._user) {
      this.shadowRoot.innerHTML = this.renderEmpty();
      return;
    }

    this.shadowRoot.innerHTML = compact
      ? this.renderCompact()
      : this.renderFull();
  }

  renderLoading() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card loading&quot;&gt;
        &lt;div class=&quot;spinner&quot;&gt;&lt;/div&gt;
        &lt;p&gt;Loading...&lt;/p&gt;
      &lt;/div&gt;
    `;
  }

  renderError() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card error&quot;&gt;
        &lt;p class=&quot;error-message&quot;&gt;${this._error}&lt;/p&gt;
        &lt;button class=&quot;retry&quot;&gt;Retry&lt;/button&gt;
      &lt;/div&gt;
    `;
  }

  renderEmpty() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card empty&quot;&gt;
        &lt;p&gt;No user data&lt;/p&gt;
      &lt;/div&gt;
    `;
  }

  renderCompact() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card compact&quot;&gt;
        &lt;img src=&quot;${this._user.avatar}&quot; alt=&quot;${this._user.name}&quot;&gt;
        &lt;div class=&quot;info&quot;&gt;
          &lt;h3&gt;${this._user.name}&lt;/h3&gt;
          &lt;slot name=&quot;actions&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }

  renderFull() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card&quot;&gt;
        &lt;div class=&quot;header&quot;&gt;
          &lt;img src=&quot;${this._user.avatar}&quot; alt=&quot;${this._user.name}&quot; class=&quot;avatar&quot;&gt;
          &lt;div class=&quot;header-content&quot;&gt;
            &lt;h2&gt;${this._user.name}&lt;/h2&gt;
            &lt;p class=&quot;email&quot;&gt;${this._user.email}&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;body&quot;&gt;
          &lt;p class=&quot;bio&quot;&gt;${this._user.bio || &#039;No bio available&#039;}&lt;/p&gt;
          &lt;div class=&quot;meta&quot;&gt;
            &lt;span&gt;Joined ${formatDate(this._user.createdAt)}&lt;/span&gt;
          &lt;/div&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;footer&quot;&gt;
          &lt;slot name=&quot;actions&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }

  // 10. Styles
  styles() {
    return `
      :host {
        display: block;
        cursor: pointer;
      }

      .card {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        padding: 16px;
        transition: box-shadow 0.2s;
      }

      .card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      }

      .header {
        display: flex;
        gap: 12px;
        margin-bottom: 16px;
      }

      .avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        object-fit: cover;
      }

      h2 {
        margin: 0;
        font-size: 18px;
        color: #333;
      }

      .email {
        margin: 4px 0 0 0;
        font-size: 14px;
        color: #666;
      }

      .bio {
        color: #444;
        line-height: 1.5;
      }

      .meta {
        font-size: 12px;
        color: #999;
        margin-top: 12px;
      }

      .loading, .error, .empty {
        text-align: center;
        padding: 40px 20px;
        color: #666;
      }

      .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 16px;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .error-message {
        color: #e53e3e;
      }

      .compact {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
      }

      .compact img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
      }

      .compact h3 {
        margin: 0;
        font-size: 14px;
      }
    `;
  }
}

// 11. Register the custom element
customElements.define(&#039;user-card&#039;, UserCard);

// 12. Export for use in other modules
export default UserCard;</code></pre>
<h3>Component Structure Breakdown</h3>
<strong>1. Documentation:</strong>
<ul><li>JSDoc comments explain usage</li>
<li>Attribute, property, event, and slot documentation</li>
<li>Helps other developers understand the component</li>
</ul>
<strong>2. Static Properties:</strong>
<ul><li><code>observedAttributes</code> defines which attributes trigger <code>attributeChangedCallback</code></li>
<li>Keep this list minimal for performance</li>
</ul>
<strong>3. Constructor:</strong>
<ul><li>Initialize instance variables</li>
<li>Attach shadow DOM</li>
<li>Bind methods (for event handlers)</li>
<li>Don't access attributes or DOM here</li>
</ul>
<strong>4. Lifecycle Methods:</strong>
<ul><li><code>connectedCallback</code>: Setup when added to DOM</li>
<li><code>disconnectedCallback</code>: Cleanup when removed</li>
<li><code>attributeChangedCallback</code>: Respond to attribute changes</li>
</ul>
<strong>5. Properties:</strong>
<ul><li>Use private fields (<code>_user</code>) for internal state</li>
<li>Provide getters/setters for public API</li>
<li>Setters can trigger re-renders</li>
</ul>
<strong>6. Methods:</strong>
<ul><li>Public methods for external use</li>
<li>Private methods (conventionally start with <code>_</code> or use <code>#</code> private fields)</li>
<li>Keep methods focused and single-purpose</li>
</ul>
<strong>7. Rendering:</strong>
<ul><li>Separate render logic from state management</li>
<li>Multiple render methods for different states</li>
<li>Extract styles to a separate method</li>
</ul>
<h2>Shadow DOM Deep Dive</h2>
<p>!<a href="../images/02-component-structure-6.png"><strong>Figure 4.2:</strong> Slots and Content Projection</a></p>
<strong><em>Figure 4.2:</strong> Slots and Content Projection</em>
<p>Shadow DOM is one of the most powerful features of Web Components. It provides true encapsulation for both markup and styles.</p>
<h3>Creating Shadow DOM</h3>
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  constructor() {
    super();

    // Create shadow root
    this.attachShadow({ mode: &#039;open&#039; });

    // mode: &#039;open&#039; - shadow root accessible via element.shadowRoot
    // mode: &#039;closed&#039; - shadow root not accessible (rarely used)
  }
}</code></pre>
<h3>Shadow DOM vs Light DOM</h3>
<pre><code class="language-html">&lt;my-component&gt;
  &lt;!-- This is Light DOM (regular DOM) --&gt;
  &lt;p&gt;Visible content&lt;/p&gt;
&lt;/my-component&gt;

&lt;script&gt;
  class MyComponent extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: &#039;open&#039; });

      // This is Shadow DOM
      this.shadowRoot.innerHTML = `
        &lt;div class=&quot;shadow-content&quot;&gt;
          &lt;h2&gt;Shadow DOM Content&lt;/h2&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
      `;
    }
  }

  customElements.define(&#039;my-component&#039;, MyComponent);
&lt;/script&gt;</code></pre>
<strong>Result:</strong>
<ul><li>Light DOM (<code><p>Visible content</p></code>) is projected into the <code><slot></code></li>
<li>Shadow DOM provides the structure and styling</li>
<li>Styles in shadow DOM don't leak out</li>
<li>Styles from light DOM don't leak in</li>
</ul>
<h3>Style Encapsulation</h3>
<pre><code class="language-javascript">class StyledButton extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        /* These styles only affect this component */
        button {
          background: blue;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
        }

        button:hover {
          background: darkblue;
        }
      &lt;/style&gt;
      &lt;button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;
    `;
  }
}</code></pre>
<strong>Key Points:</strong>
<ul><li>Styles inside shadow DOM are scoped</li>
<li>No conflicts with global styles</li>
<li>No CSS class name collisions</li>
<li>True component encapsulation</li>
</ul>
<h3>The :host Selector</h3>
<p>Style the component itself:</p>
<pre><code class="language-css">:host {
  display: block;
  margin: 16px 0;
}

/* Style host when it has a class */
:host(.highlighted) {
  border: 2px solid gold;
}

/* Style host when it has an attribute */
:host([disabled]) {
  opacity: 0.5;
  pointer-events: none;
}

/* Style host in specific contexts */
:host-context(.dark-theme) {
  background: #333;
  color: white;
}</code></pre>
<h3>CSS Custom Properties (Variables)</h3>
<p>CSS variables pierce the shadow DOM boundary:</p>
<pre><code class="language-javascript">// Component defines and uses variables
class ThemedCard extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          background: var(--card-bg, white);
          color: var(--card-text, black);
          border: 1px solid var(--card-border, #ddd);
          border-radius: var(--card-radius, 8px);
          padding: var(--card-padding, 16px);
        }
      &lt;/style&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;
  }
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;style&gt;
  /* Override component variables from outside */
  themed-card {
    --card-bg: #f0f0f0;
    --card-text: #333;
    --card-border: #ccc;
    --card-radius: 12px;
  }

  themed-card.dark {
    --card-bg: #333;
    --card-text: #fff;
    --card-border: #555;
  }
&lt;/style&gt;

&lt;themed-card&gt;Normal theme&lt;/themed-card&gt;
&lt;themed-card class=&quot;dark&quot;&gt;Dark theme&lt;/themed-card&gt;</code></pre>
<p>This pattern allows theming while maintaining encapsulation.</p>
<h3>Parts and ::part()</h3>
<p>Expose specific shadow DOM elements for styling:</p>
<pre><code class="language-javascript">class FancyButton extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button { /* default styles */ }
        .icon { /* icon styles */ }
      &lt;/style&gt;
      &lt;button part=&quot;button&quot;&gt;
        &lt;span part=&quot;icon&quot; class=&quot;icon&quot;&gt;→&lt;/span&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/button&gt;
    `;
  }
}</code></pre>
<strong>Style from outside:</strong>
<pre><code class="language-css">fancy-button::part(button) {
  background: linear-gradient(135deg, #667eea, #764ba2);
}

fancy-button::part(icon) {
  color: gold;
}</code></pre>
<p>This gives consumers more control while maintaining encapsulation.</p>
<h2>Attributes and Properties</h2>
<p>Understanding the difference between attributes and properties is crucial for component design.</p>
<h3>Attributes vs Properties</h3>
<strong>Attributes:</strong>
<ul><li>HTML attributes (<code><my-el foo="bar"></code>)</li>
<li>Always strings</li>
<li>Visible in HTML</li>
<li>Trigger <code>attributeChangedCallback</code></li>
</ul>
<strong>Properties:</strong>
<ul><li>JavaScript properties (<code>element.foo = 123</code>)</li>
<li>Any type (string, number, object, etc.)</li>
<li>Not visible in HTML</li>
<li>Direct access, no callback</li>
</ul>
<h3>Reflecting Properties to Attributes</h3>
<pre><code class="language-javascript">class ToggleButton extends HTMLElement {
  static get observedAttributes() {
    return [&#039;checked&#039;];
  }

  constructor() {
    super();
    this._checked = false;
  }

  // Property getter
  get checked() {
    return this._checked;
  }

  // Property setter - reflects to attribute
  set checked(value) {
    const isChecked = Boolean(value);

    if (isChecked) {
      this.setAttribute(&#039;checked&#039;, &#039;&#039;);
    } else {
      this.removeAttribute(&#039;checked&#039;);
    }
  }

  // Attribute changed - updates property
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === &#039;checked&#039;) {
      this._checked = newValue !== null;
      this.render();
    }
  }

  render() {
    this.innerHTML = `
      &lt;button class=&quot;${this._checked ? &#039;checked&#039; : &#039;&#039;}&quot;&gt;
        ${this._checked ? &#039;✓&#039; : &#039;○&#039;}
      &lt;/button&gt;
    `;
  }
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;!-- Set via attribute --&gt;
&lt;toggle-button checked&gt;&lt;/toggle-button&gt;

&lt;script&gt;
  const toggle = document.querySelector(&#039;toggle-button&#039;);

  // Set via property
  toggle.checked = true;

  // Get property
  console.log(toggle.checked); // true

  // Check attribute
  console.log(toggle.hasAttribute(&#039;checked&#039;)); // true
&lt;/script&gt;</code></pre>
<h3>When to Use Each</h3>
<strong>Use Attributes for:</strong>
<ul><li>Simple configuration (strings, numbers, booleans)</li>
<li>Values that should be visible in HTML</li>
<li>Initial configuration from HTML</li>
<li>Values that need to work with CSS selectors</li>
</ul>
<strong>Use Properties for:</strong>
<ul><li>Complex data (objects, arrays, functions)</li>
<li>Data that changes frequently</li>
<li>Large data that shouldn't serialize to HTML</li>
<li>Callback functions</li>
</ul>
<h3>Type Conversion</h3>
<p>Attributes are always strings, so convert appropriately:</p>
<pre><code class="language-javascript">attributeChangedCallback(name, oldValue, newValue) {
  if (name === &#039;count&#039;) {
    this._count = Number(newValue) || 0;
  } else if (name === &#039;enabled&#039;) {
    this._enabled = newValue !== null; // Boolean attribute
  } else if (name === &#039;options&#039;) {
    try {
      this._options = JSON.parse(newValue);
    } catch {
      this._options = {};
    }
  }
}</code></pre>
<h3>Boolean Attributes</h3>
<p>Follow HTML conventions:</p>
<pre><code class="language-javascript">// Boolean attribute: presence = true, absence = false
if (this.hasAttribute(&#039;disabled&#039;)) {
  // Is disabled
}

// Set boolean attribute
this.setAttribute(&#039;disabled&#039;, &#039;&#039;); // value doesn&#039;t matter

// Remove boolean attribute
this.removeAttribute(&#039;disabled&#039;);</code></pre>
<h2>Component Styling</h2>
<p>!<a href="../images/02-component-structure-7.png"><strong>Figure 4.3:</strong> CSS Encapsulation with Shadow DOM</a></p>
<strong><em>Figure 4.3:</strong> CSS Encapsulation with Shadow DOM</em>
<h3>Internal Styles</h3>
<p>Most styles should be in shadow DOM:</p>
<pre><code class="language-javascript">styles() {
  return `
    :host {
      display: block;
    }

    .container {
      padding: 16px;
    }

    /* All your component styles */
  `;
}</code></pre>
<h3>External Stylesheets</h3>
<p>For larger components, link external styles:</p>
<pre><code class="language-javascript">connectedCallback() {
  this.attachShadow({ mode: &#039;open&#039; });

  this.shadowRoot.innerHTML = `
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/styles/components/user-card.css&quot;&gt;
    &lt;div class=&quot;user-card&quot;&gt;
      &lt;!-- content --&gt;
    &lt;/div&gt;
  `;
}</code></pre>
<h3>Adoptable Stylesheets</h3>
<p>Share styles between component instances:</p>
<pre><code class="language-javascript">// Create shared stylesheet once
const sheet = new CSSStyleSheet();
sheet.replaceSync(`
  .card {
    padding: 16px;
    border-radius: 8px;
    background: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
`);

class CardComponent extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    // Adopt shared stylesheet (very fast)
    this.shadowRoot.adoptedStyleSheets = [sheet];

    this.shadowRoot.innerHTML = `
      &lt;div class=&quot;card&quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<strong>Benefits:</strong>
<ul><li>Styles parsed once, shared across instances</li>
<li>Better performance with many components</li>
<li>Modify shared styles dynamically</li>
</ul>
<h3>Theming Strategies</h3>
<strong>Strategy 1: CSS Custom Properties</strong>
<pre><code class="language-javascript">class ThemedComponent extends HTMLElement {
  styles() {
    return `
      :host {
        --primary-color: var(--app-primary, #667eea);
        --background: var(--app-bg, white);
        --text: var(--app-text, #333);
      }

      .content {
        background: var(--background);
        color: var(--text);
      }

      button {
        background: var(--primary-color);
      }
    `;
  }
}</code></pre>
<strong>Strategy 2: Class-Based Themes</strong>
<pre><code class="language-javascript">class ThemeAwareComponent extends HTMLElement {
  connectedCallback() {
    // Observe theme changes on documentElement
    const observer = new MutationObserver(() =&gt; {
      this.updateTheme();
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: [&#039;data-theme&#039;]
    });

    this.updateTheme();
  }

  updateTheme() {
    const theme = document.documentElement.dataset.theme || &#039;light&#039;;
    this.setAttribute(&#039;theme&#039;, theme);
  }

  styles() {
    return `
      :host([theme=&quot;light&quot;]) {
        background: white;
        color: black;
      }

      :host([theme=&quot;dark&quot;]) {
        background: #333;
        color: white;
      }
    `;
  }
}</code></pre>
<strong>Strategy 3: PAN-Based Themes</strong>
<pre><code class="language-javascript">import { pan } from &#039;@larcjs/core&#039;;

class PanThemedComponent extends HTMLElement {
  connectedCallback() {
    this.unsubscribe = pan.subscribe(&#039;app.theme.changed&#039;, ({ theme }) =&gt; {
      this.applyTheme(theme);
    });

    // Request current theme
    pan.request(&#039;app.theme.get&#039;).then(theme =&gt; {
      this.applyTheme(theme);
    });
  }

  applyTheme(theme) {
    this.setAttribute(&#039;data-theme&#039;, theme);
  }
}</code></pre>
<h2>Lifecycle Methods (Advanced Patterns)</h2>
<h3>Deferred Rendering</h3>
<p>Wait for dependencies before rendering:</p>
<pre><code class="language-javascript">class DataDisplay extends HTMLElement {
  async connectedCallback() {
    // Wait for dependencies to load
    await customElements.whenDefined(&#039;loading-spinner&#039;);
    await customElements.whenDefined(&#039;error-message&#039;);

    // Now render
    this.render();
  }
}</code></pre>
<h3>Preventing Memory Leaks</h3>
<pre><code class="language-javascript">class WebSocketComponent extends HTMLElement {
  connectedCallback() {
    this.ws = new WebSocket(&#039;wss://api.example.com&#039;);

    this.ws.onmessage = (event) =&gt; {
      this.handleMessage(event.data);
    };

    this.ws.onerror = (error) =&gt; {
      console.error(&#039;WebSocket error:&#039;, error);
    };
  }

  disconnectedCallback() {
    // Clean up WebSocket connection
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}</code></pre>
<h3>Handling Rapid Reconnection</h3>
<p>Components can be disconnected and reconnected quickly:</p>
<pre><code class="language-javascript">class RobustComponent extends HTMLElement {
  connectedCallback() {
    // Might be called multiple times
    // Use a guard to prevent duplicate setup
    if (this._initialized) {
      return;
    }

    this._initialized = true;
    this.setup();
  }

  disconnectedCallback() {
    // Use setTimeout to debounce
    this._cleanupTimer = setTimeout(() =&gt; {
      this.cleanup();
      this._initialized = false;
    }, 100);
  }

  connectedCallback() {
    // Cancel cleanup if reconnected quickly
    if (this._cleanupTimer) {
      clearTimeout(this._cleanupTimer);
      this._cleanupTimer = null;
    }

    if (this._initialized) {
      return;
    }

    this._initialized = true;
    this.setup();
  }
}</code></pre>
<h2>Testing Components</h2>
<h3>Unit Testing</h3>
<p>Test components in isolation:</p>
<pre><code class="language-javascript">// tests/user-card.test.js
import { expect } from &#039;@open-wc/testing&#039;;
import &#039;../user-card.js&#039;;

describe(&#039;UserCard&#039;, () =&gt; {
  let element;

  beforeEach(() =&gt; {
    element = document.createElement(&#039;user-card&#039;);
    document.body.appendChild(element);
  });

  afterEach(() =&gt; {
    element.remove();
  });

  it(&#039;renders empty state by default&#039;, () =&gt; {
    const emptyText = element.shadowRoot.querySelector(&#039;.empty&#039;);
    expect(emptyText).to.exist;
  });

  it(&#039;loads user when user-id attribute is set&#039;, async () =&gt; {
    // Mock fetch
    global.fetch = async () =&gt; ({
      ok: true,
      json: async () =&gt; ({ id: 1, name: &#039;John Doe&#039;, email: &#039;john@example.com&#039; })
    });

    element.setAttribute(&#039;user-id&#039;, &#039;1&#039;);

    // Wait for async operations
    await new Promise(resolve =&gt; setTimeout(resolve, 100));

    const name = element.shadowRoot.querySelector(&#039;h2&#039;);
    expect(name.textContent).to.equal(&#039;John Doe&#039;);
  });

  it(&#039;handles loading state&#039;, async () =&gt; {
    element.setAttribute(&#039;user-id&#039;, &#039;1&#039;);

    const spinner = element.shadowRoot.querySelector(&#039;.spinner&#039;);
    expect(spinner).to.exist;
  });

  it(&#039;dispatches user-selected event on click&#039;, async () =&gt; {
    element._user = { id: 1, name: &#039;John&#039; };
    element.render();

    let eventData = null;
    element.addEventListener(&#039;user-selected&#039;, (e) =&gt; {
      eventData = e.detail;
    });

    element.shadowRoot.querySelector(&#039;.card&#039;).click();

    expect(eventData).to.deep.equal({ user: { id: 1, name: &#039;John&#039; } });
  });
});</code></pre>
<h3>Integration Testing</h3>
<p>Test components working together:</p>
<pre><code class="language-javascript">// tests/counter-integration.test.js
describe(&#039;Counter Integration&#039;, () =&gt; {
  beforeEach(() =&gt; {
    document.body.innerHTML = `
      &lt;counter-display&gt;&lt;/counter-display&gt;
      &lt;counter-controls&gt;&lt;/counter-controls&gt;
    `;
  });

  it(&#039;updates display when controls are clicked&#039;, async () =&gt; {
    const display = document.querySelector(&#039;counter-display&#039;);
    const controls = document.querySelector(&#039;counter-controls&#039;);

    const incrementBtn = controls.shadowRoot.querySelector(&#039;#increment&#039;);
    incrementBtn.click();

    await new Promise(resolve =&gt; setTimeout(resolve, 50));

    const displayValue = display.shadowRoot.querySelector(&#039;.display&#039;).textContent;
    expect(displayValue).to.equal(&#039;1&#039;);
  });
});</code></pre>
<h3>Visual Regression Testing</h3>
<p>Catch visual bugs:</p>
<pre><code class="language-javascript">// tests/visual.test.js
import puppeteer from &#039;puppeteer&#039;;
import pixelmatch from &#039;pixelmatch&#039;;

describe(&#039;Visual Regression&#039;, () =&gt; {
  let browser, page;

  beforeAll(async () =&gt; {
    browser = await puppeteer.launch();
    page = await browser.newPage();
  });

  afterAll(async () =&gt; {
    await browser.close();
  });

  it(&#039;user-card matches snapshot&#039;, async () =&gt; {
    await page.goto(&#039;http://localhost:3000/tests/user-card.html&#039;);

    const screenshot = await page.screenshot({ fullPage: true });
    const baseline = fs.readFileSync(&#039;tests/snapshots/user-card.png&#039;);

    const diff = pixelmatch(screenshot, baseline, null, 800, 600, {
      threshold: 0.1
    });

    expect(diff).to.be.lessThan(100); // Allow small differences
  });
});</code></pre>
<h2>Summary</h2>
<p>This chapter covered:</p>
<ul><li><strong>Component Anatomy</strong>: Structure, lifecycle, and organization</li>
<li><strong>Shadow DOM</strong>: Encapsulation, slots, and styling</li>
<li><strong>Attributes vs Properties</strong>: When to use each and how to reflect them</li>
<li><strong>Component Styling</strong>: Internal styles, theming, and CSS custom properties</li>
<li><strong>Lifecycle Patterns</strong>: Memory management and robust connection handling</li>
<li><strong>Testing</strong>: Unit, integration, and visual regression testing</li>
</ul>
You now know how to build production-quality Web Components. The next chapter explores the PAN bus in depth, showing you how to orchestrate component communication at scale.
<hr>
<h2>Best Practices</h2>
<li><strong>Always clean up in <code>disconnectedCallback</code></strong></li>
   - Remove event listeners
   - Cancel pending operations
   - Unsubscribe from events
<li><strong>Use Shadow DOM for encapsulation</strong></li>
   - Keep styles scoped
   - Avoid global style pollution
   - Use <code>:host</code> and CSS custom properties for theming
<li><strong>Reflect important properties to attributes</strong></li>
   - Makes state visible in HTML
   - Enables CSS selectors
   - Improves debugging
<li><strong>Keep components focused</strong></li>
   - Single responsibility principle
   - Compose larger components from smaller ones
   - Extract shared logic to utilities
<li><strong>Test early and often</strong></li>
   - Write tests as you build components
   - Test both happy paths and error cases
   - Use integration tests for component interaction
<p>\pagebreak</p>
<h1>Chapter 5: The PAN Bus</h1>
<p>The Page Area Network (PAN) bus is LARC's event-driven communication backbone. It enables decoupled, scalable component architectures by providing a pub/sub messaging system that works across your entire application.</p>
<p>In this chapter, you'll master the PAN bus: from basic publish/subscribe patterns to advanced message routing, error handling, and debugging techniques. By the end, you'll be able to build complex applications where components communicate seamlessly without tight coupling.</p>
<h2>Understanding Pub/Sub Architecture</h2>
<p>!<a href="../images/05-pan-bus-1.png"><strong>Figure 5.1:</strong> PAN Bus Pub/Sub Architecture</a></p>
<strong><em>Figure 5.1:</strong> PAN Bus Pub/Sub Architecture</em>
<p>Publish/Subscribe (pub/sub) is a messaging pattern where senders (publishers) don't directly target specific receivers (subscribers). Instead, messages are sent to topics, and any component interested in those topics receives them.</p>
<h3>Traditional Communication</h3>
<p>Without pub/sub, components need direct references:</p>
<pre><code class="language-javascript">// ❌ Tight coupling
class LoginButton {
  handleLogin() {
    const user = this.authenticate();

    // Direct reference to other components
    document.querySelector(&#039;user-menu&#039;).updateUser(user);
    document.querySelector(&#039;sidebar&#039;).showUserPanel();
    document.querySelector(&#039;notification&#039;).show(&#039;Welcome!&#039;);
  }
}</code></pre>
<strong>Problems:</strong>
<ul><li>LoginButton must know about all dependent components</li>
<li>Adding new components requires modifying LoginButton</li>
<li>Components can't work independently</li>
<li>Testing requires mocking all dependencies</li>
</ul>
<h3>Pub/Sub Communication</h3>
<p>With the PAN bus:</p>
<pre><code class="language-javascript">// ✓ Loose coupling
class LoginButton {
  handleLogin() {
    const user = this.authenticate();

    // Publish event - don&#039;t care who listens
    pan.publish(&#039;user.logged-in&#039;, { user });
  }
}

// Separate components subscribe independently
class UserMenu {
  connectedCallback() {
    pan.subscribe(&#039;user.logged-in&#039;, ({ user }) =&gt; {
      this.updateUser(user);
    });
  }
}

class Sidebar {
  connectedCallback() {
    pan.subscribe(&#039;user.logged-in&#039;, () =&gt; {
      this.showUserPanel();
    });
  }
}

class Notification {
  connectedCallback() {
    pan.subscribe(&#039;user.logged-in&#039;, () =&gt; {
      this.show(&#039;Welcome!&#039;);
    });
  }
}</code></pre>
<strong>Benefits:</strong>
<ul><li>LoginButton doesn't know about consumers</li>
<li>Add new subscribers without changing publishers</li>
<li>Components work independently</li>
<li>Easy to test in isolation</li>
</ul>
<h3>The PAN Bus API</h3>
<p>The PAN bus provides three core operations:</p>
<pre><code class="language-javascript">import { pan } from &#039;@larcjs/core&#039;;

// 1. Publish - send a message to a topic
pan.publish(&#039;topic.name&#039;, { data: &#039;value&#039; });

// 2. Subscribe - listen for messages on a topic
const unsubscribe = pan.subscribe(&#039;topic.name&#039;, (data) =&gt; {
  console.log(&#039;Received:&#039;, data);
});

// 3. Unsubscribe - stop listening
unsubscribe();</code></pre>
<p>That's the foundation. Everything else builds on these three operations.</p>
<h2>Topics and Namespaces</h2>
<p>!<a href="../images/05-pan-bus-3.png"><strong>Figure 5.3:</strong> Topic Namespace Structure</a></p>
<strong><em>Figure 5.3:</strong> Topic Namespace Structure</em>
<p>Topics are the routing keys for messages. Well-designed topics make your application's data flow clear and maintainable.</p>
<h3>Topic Naming Conventions</h3>
<p>Use dot notation to create hierarchies:</p>
<pre><code class="language-plaintext">domain.entity.action</code></pre>
<strong>Examples:</strong>
<pre><code class="language-plaintext">user.profile.updated
user.auth.login
user.auth.logout
user.settings.changed

cart.item.added
cart.item.removed
cart.total.calculated
cart.checkout.started
cart.checkout.completed

notification.info.show
notification.warning.show
notification.error.show

app.theme.changed
app.language.changed
app.route.changed</code></pre>
<h3>Namespace Structure</h3>
<p>Organize topics by domain:</p>
<strong>User Domain:</strong>
<pre><code class="language-plaintext">user.auth.login
user.auth.logout
user.auth.refresh
user.profile.fetch
user.profile.update
user.settings.fetch
user.settings.update</code></pre>
<strong>Shopping Cart Domain:</strong>
<pre><code class="language-plaintext">cart.init
cart.item.add
cart.item.remove
cart.item.update
cart.clear
cart.checkout</code></pre>
<strong>Application Domain:</strong>
<pre><code class="language-plaintext">app.ready
app.error
app.navigate
app.theme.change
app.modal.open
app.modal.close</code></pre>
<h3>Wildcards</h3>
<p>!<a href="../images/05-pan-bus-4.png"><strong>Figure 5.4:</strong> Wildcard Subscription Matching</a></p>
<strong><em>Figure 5.4:</strong> Wildcard Subscription Matching</em>
<p>Subscribe to multiple topics using wildcards:</p>
<pre><code class="language-javascript">// Subscribe to all user events
pan.subscribe(&#039;user.*&#039;, (data) =&gt; {
  console.log(&#039;User event:&#039;, data);
});

// Subscribe to all auth events across domains
pan.subscribe(&#039;*.auth.*&#039;, (data) =&gt; {
  console.log(&#039;Auth event:&#039;, data);
});

// Subscribe to ALL events (debugging)
pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
  console.log(`[${topic}]`, data);
});</code></pre>
<strong>Wildcard Patterns:</strong>
<ul><li><code>user.*</code> - All user events (user.login, user.logout, etc.)</li>
<li><code>*.created</code> - All create events (user.created, post.created, etc.)</li>
<li><code>user.*.updated</code> - All user update events (user.profile.updated, user.settings.updated, etc.)</li>
<li><code>*</code> - All events</li>
</ul>
<h3>Topic Best Practices</h3>
<strong>1. Be Specific:</strong>
<pre><code class="language-javascript">// ✓ Good - clear intent
pan.publish(&#039;cart.item.added&#039;, { item, quantity });

// ❌ Bad - vague
pan.publish(&#039;cart.update&#039;, { type: &#039;add&#039;, item, quantity });</code></pre>
<strong>2. Use Consistent Tense:</strong>
<pre><code class="language-javascript">// ✓ Good - past tense for events that happened
pan.publish(&#039;user.logged-in&#039;, { user });
pan.publish(&#039;data.loaded&#039;, { data });

// ❌ Bad - mixed tense
pan.publish(&#039;user.login&#039;, { user });  // Is this a command or event?</code></pre>
<strong>3. Include Context:</strong>
<pre><code class="language-javascript">// ✓ Good - data includes context
pan.publish(&#039;task.completed&#039;, {
  taskId: 123,
  userId: 456,
  completedAt: new Date()
});

// ❌ Bad - missing context
pan.publish(&#039;task.done&#039;, { id: 123 });</code></pre>
<strong>4. Avoid Over-Nesting:</strong>
<pre><code class="language-javascript">// ✓ Good - clear and concise
pan.publish(&#039;user.profile.updated&#039;, { user });

// ❌ Bad - too nested
pan.publish(&#039;app.domain.user.entity.profile.action.updated&#039;, { user });</code></pre>
<h2>Publishing Messages</h2>
<p>!<a href="../images/05-pan-bus-2.png"><strong>Figure 5.2:</strong> Message Flow Sequence</a></p>
<strong><em>Figure 5.2:</strong> Message Flow Sequence</em>
<p>!<a href="../images/05-pan-bus-2.png"><strong>Figure 5.2:</strong> Message Flow Sequence</a>
<strong><em>Figure 5.2:</strong> Message Flow Sequence</em></p>
<p>Publishing is straightforward, but there are patterns and options to understand.</p>
<h3>Basic Publishing</h3>
<pre><code class="language-javascript">pan.publish(&#039;event.name&#039;, { any: &#039;data&#039; });</code></pre>
<p>The data can be anything JSON-serializable:</p>
<pre><code class="language-javascript">// Simple value
pan.publish(&#039;counter.updated&#039;, 42);

// Object
pan.publish(&#039;user.logged-in&#039;, {
  userId: 123,
  username: &#039;john&#039;,
  email: &#039;john@example.com&#039;
});

// Array
pan.publish(&#039;items.loaded&#039;, [
  { id: 1, name: &#039;Item 1&#039; },
  { id: 2, name: &#039;Item 2&#039; }
]);

// Null/undefined
pan.publish(&#039;data.cleared&#039;, null);</code></pre>
<h3>Publishing from Components</h3>
<p>Publish in response to user actions or state changes:</p>
<pre><code class="language-javascript">class AddToCartButton extends HTMLElement {
  connectedCallback() {
    this.addEventListener(&#039;click&#039;, this.handleClick);
  }

  async handleClick() {
    const productId = this.getAttribute(&#039;product-id&#039;);
    const quantity = parseInt(this.getAttribute(&#039;quantity&#039;) || 1);

    // Publish intent
    pan.publish(&#039;cart.item.add-requested&#039;, { productId, quantity });

    try {
      // Perform action
      await this.addToCart(productId, quantity);

      // Publish success
      pan.publish(&#039;cart.item.added&#039;, {
        productId,
        quantity,
        timestamp: Date.now()
      });
    } catch (error) {
      // Publish failure
      pan.publish(&#039;cart.item.add-failed&#039;, {
        productId,
        quantity,
        error: error.message
      });
    }
  }

  async addToCart(productId, quantity) {
    const response = await fetch(&#039;/api/cart/items&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify({ productId, quantity })
    });

    if (!response.ok) {
      throw new Error(&#039;Failed to add item to cart&#039;);
    }

    return response.json();
  }
}</code></pre>
<h3>Event Metadata</h3>
<p>Include metadata for debugging and auditing:</p>
<pre><code class="language-javascript">function publishWithMetadata(topic, data) {
  pan.publish(topic, {
    ...data,
    _meta: {
      timestamp: Date.now(),
      source: &#039;UserComponent&#039;,
      userId: currentUser?.id,
      sessionId: sessionId
    }
  });
}

// Usage
publishWithMetadata(&#039;order.placed&#039;, {
  orderId: 12345,
  total: 99.99
});</code></pre>
<h3>Batch Publishing</h3>
<p>Publish multiple events efficiently:</p>
<pre><code class="language-javascript">function syncLocalChanges(changes) {
  changes.forEach(change =&gt; {
    switch (change.type) {
      case &#039;add&#039;:
        pan.publish(&#039;data.item.added&#039;, change.item);
        break;
      case &#039;update&#039;:
        pan.publish(&#039;data.item.updated&#039;, change.item);
        break;
      case &#039;delete&#039;:
        pan.publish(&#039;data.item.deleted&#039;, { id: change.id });
        break;
    }
  });

  // Publish batch complete
  pan.publish(&#039;data.sync.completed&#039;, {
    changesCount: changes.length,
    timestamp: Date.now()
  });
}</code></pre>
<h2>Subscribing to Events</h2>
<p>Subscriptions are how components react to events they care about.</p>
<h3>Basic Subscription</h3>
<pre><code class="language-javascript">const unsubscribe = pan.subscribe(&#039;event.name&#039;, (data) =&gt; {
  console.log(&#039;Received:&#039;, data);
});

// Later, when done
unsubscribe();</code></pre>
<h3>Component Lifecycle Integration</h3>
<p>Subscribe in <code>connectedCallback</code>, unsubscribe in <code>disconnectedCallback</code>:</p>
<pre><code class="language-javascript">class NotificationDisplay extends HTMLElement {
  connectedCallback() {
    // Subscribe to notification events
    this.unsubscribeInfo = pan.subscribe(&#039;notification.info&#039;, this.showInfo);
    this.unsubscribeWarning = pan.subscribe(&#039;notification.warning&#039;, this.showWarning);
    this.unsubscribeError = pan.subscribe(&#039;notification.error&#039;, this.showError);
  }

  disconnectedCallback() {
    // Clean up subscriptions
    this.unsubscribeInfo();
    this.unsubscribeWarning();
    this.unsubscribeError();
  }

  showInfo = (data) =&gt; {
    this.showNotification(&#039;info&#039;, data.message);
  }

  showWarning = (data) =&gt; {
    this.showNotification(&#039;warning&#039;, data.message);
  }

  showError = (data) =&gt; {
    this.showNotification(&#039;error&#039;, data.message);
  }

  showNotification(type, message) {
    // Render notification UI
  }
}</code></pre>
<h3>Multiple Subscriptions Helper</h3>
<p>Manage multiple subscriptions easily:</p>
<pre><code class="language-javascript">class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }

  subscribe(topic, handler) {
    const unsubscribe = pan.subscribe(topic, handler);
    this.subscriptions.push(unsubscribe);
    return unsubscribe;
  }

  unsubscribeAll() {
    this.subscriptions.forEach(unsubscribe =&gt; unsubscribe());
    this.subscriptions = [];
  }
}

// Usage in component
class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.subs = new SubscriptionManager();
  }

  connectedCallback() {
    this.subs.subscribe(&#039;user.login&#039;, this.handleLogin);
    this.subs.subscribe(&#039;user.logout&#039;, this.handleLogout);
    this.subs.subscribe(&#039;app.theme.changed&#039;, this.handleThemeChange);
  }

  disconnectedCallback() {
    this.subs.unsubscribeAll();
  }

  handleLogin = (data) =&gt; { /* ... */ }
  handleLogout = (data) =&gt; { /* ... */ }
  handleThemeChange = (data) =&gt; { /* ... */ }
}</code></pre>
<h3>Conditional Subscriptions</h3>
<p>Subscribe only when conditions are met:</p>
<pre><code class="language-javascript">class UserDashboard extends HTMLElement {
  connectedCallback() {
    // Subscribe to user-specific events only when user is logged in
    this.unsubscribeAuth = pan.subscribe(&#039;auth.state.changed&#039;, ({ isAuthenticated, user }) =&gt; {
      if (isAuthenticated) {
        this.subscribeToUserEvents(user.id);
      } else {
        this.unsubscribeFromUserEvents();
      }
    });
  }

  subscribeToUserEvents(userId) {
    this.unsubscribeUserActivity = pan.subscribe(&#039;user.activity&#039;, (data) =&gt; {
      if (data.userId === userId) {
        this.updateActivity(data);
      }
    });

    this.unsubscribeUserNotifications = pan.subscribe(&#039;user.notifications&#039;, (data) =&gt; {
      if (data.userId === userId) {
        this.showNotification(data);
      }
    });
  }

  unsubscribeFromUserEvents() {
    if (this.unsubscribeUserActivity) {
      this.unsubscribeUserActivity();
      this.unsubscribeUserActivity = null;
    }

    if (this.unsubscribeUserNotifications) {
      this.unsubscribeUserNotifications();
      this.unsubscribeUserNotifications = null;
    }
  }
}</code></pre>
<h3>Filtering Events</h3>
<p>Filter events in the subscriber:</p>
<pre><code class="language-javascript">pan.subscribe(&#039;task.updated&#039;, (task) =&gt; {
  // Only handle tasks assigned to current user
  if (task.assignedTo === currentUser.id) {
    this.updateTaskDisplay(task);
  }
});

pan.subscribe(&#039;notification.*&#039;, (notification) =&gt; {
  // Only show high-priority notifications
  if (notification.priority &gt;= 3) {
    this.showNotification(notification);
  }
});</code></pre>
<h2>Message Patterns</h2>
<p>!<a href="../images/05-pan-bus-6.png"><strong>Figure 5.6:</strong> Event Pattern Comparison</a></p>
<strong><em>Figure 5.6:</strong> Event Pattern Comparison</em>
<p>The PAN bus supports several messaging patterns for different use cases.</p>
<h3>1. Fire and Forget</h3>
<p>Most common pattern. Publish and continue without waiting:</p>
<pre><code class="language-javascript">// Publisher
function saveSettings(settings) {
  localStorage.setItem(&#039;settings&#039;, JSON.stringify(settings));
  pan.publish(&#039;settings.saved&#039;, settings);
}

// Subscriber
pan.subscribe(&#039;settings.saved&#039;, (settings) =&gt; {
  console.log(&#039;Settings updated:&#039;, settings);
  updateUI(settings);
});</code></pre>
<strong>Use when:</strong>
<ul><li>Multiple components may react</li>
<li>You don't need confirmation</li>
<li>Action is non-critical</li>
</ul>
<h3>2. Request/Response</h3>
<p>!<a href="../images/05-pan-bus-5.png"><strong>Figure 5.5:</strong> Request/Response Pattern</a></p>
<strong><em>Figure 5.5:</strong> Request/Response Pattern</em>
<p>Request data and wait for a response:</p>
<pre><code class="language-javascript">// Responder
pan.respond(&#039;auth.token.get&#039;, async () =&gt; {
  return localStorage.getItem(&#039;authToken&#039;);
});

// Requester
const token = await pan.request(&#039;auth.token.get&#039;);
console.log(&#039;Token:&#039;, token);</code></pre>
<strong>Implementation:</strong>
<pre><code class="language-javascript">// In PAN library
class PAN {
  request(topic, data, timeout = 5000) {
    return new Promise((resolve, reject) =&gt; {
      const responseId = `${topic}:${Date.now()}:${Math.random()}`;

      // Subscribe to response
      const unsubscribe = this.subscribe(`${topic}:response:${responseId}`, (response) =&gt; {
        unsubscribe();
        clearTimeout(timer);
        resolve(response);
      });

      // Set timeout
      const timer = setTimeout(() =&gt; {
        unsubscribe();
        reject(new Error(`Request timeout: ${topic}`));
      }, timeout);

      // Publish request
      this.publish(`${topic}:request`, {
        ...data,
        _responseId: responseId
      });
    });
  }

  respond(topic, handler) {
    return this.subscribe(`${topic}:request`, async (data) =&gt; {
      try {
        const result = await handler(data);
        this.publish(`${topic}:response:${data._responseId}`, result);
      } catch (error) {
        this.publish(`${topic}:response:${data._responseId}`, {
          error: error.message
        });
      }
    });
  }
}</code></pre>
<strong>Use when:</strong>
<ul><li>Need data from another component</li>
<li>Waiting for response is acceptable</li>
<li>Asynchronous operations</li>
</ul>
<h3>3. Command Pattern</h3>
<p>Issue commands that components execute:</p>
<pre><code class="language-javascript">// Command issuer
pan.publish(&#039;modal.open&#039;, {
  component: &#039;user-profile&#039;,
  props: { userId: 123 }
});

// Command handler
pan.subscribe(&#039;modal.open&#039;, ({ component, props }) =&gt; {
  const modal = document.createElement(&#039;app-modal&#039;);
  modal.component = component;
  modal.props = props;
  document.body.appendChild(modal);
});</code></pre>
<strong>Use when:</strong>
<ul><li>Triggering actions in other components</li>
<li>Implementing undo/redo</li>
<li>Building command palette UIs</li>
</ul>
<h3>4. Event Sourcing</h3>
<p>Store events for replay or auditing:</p>
<pre><code class="language-javascript">const eventStore = [];

// Store all events
pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
  eventStore.push({
    topic,
    data,
    timestamp: Date.now()
  });
});

// Replay events
function replayEvents(fromTimestamp) {
  eventStore
    .filter(event =&gt; event.timestamp &gt;= fromTimestamp)
    .forEach(event =&gt; {
      pan.publish(event.topic, event.data);
    });
}

// Get events for debugging
function getEventHistory(topic) {
  return eventStore.filter(event =&gt;
    event.topic === topic || event.topic.startsWith(topic + &#039;.&#039;)
  );
}</code></pre>
<strong>Use when:</strong>
<ul><li>Debugging complex interactions</li>
<li>Implementing undo/redo</li>
<li>Auditing user actions</li>
<li>Syncing state across sessions</li>
</ul>
<h3>5. Aggregation Pattern</h3>
<p>Collect multiple events before acting:</p>
<pre><code class="language-javascript">class DataAggregator extends HTMLElement {
  constructor() {
    super();
    this.pendingUpdates = new Set();
    this.debounceTimer = null;
  }

  connectedCallback() {
    pan.subscribe(&#039;data.item.updated&#039;, ({ id }) =&gt; {
      this.pendingUpdates.add(id);
      this.scheduleRefresh();
    });
  }

  scheduleRefresh() {
    clearTimeout(this.debounceTimer);

    this.debounceTimer = setTimeout(() =&gt; {
      this.refreshItems(Array.from(this.pendingUpdates));
      this.pendingUpdates.clear();
    }, 500);
  }

  async refreshItems(ids) {
    const items = await fetchItems(ids);
    this.render(items);
  }
}</code></pre>
<strong>Use when:</strong>
<ul><li>Avoiding excessive updates</li>
<li>Batching API requests</li>
<li>Debouncing rapid events</li>
</ul>
<h3>6. Saga Pattern</h3>
<p>Coordinate multi-step processes:</p>
<pre><code class="language-javascript">class CheckoutSaga {
  constructor() {
    this.setupListeners();
  }

  setupListeners() {
    pan.subscribe(&#039;checkout.started&#039;, this.handleCheckoutStart);
    pan.subscribe(&#039;payment.completed&#039;, this.handlePaymentComplete);
    pan.subscribe(&#039;order.created&#039;, this.handleOrderCreated);
  }

  handleCheckoutStart = async ({ cart }) =&gt; {
    try {
      // Step 1: Validate cart
      pan.publish(&#039;checkout.validating&#039;, { cart });
      await this.validateCart(cart);

      // Step 2: Calculate totals
      pan.publish(&#039;checkout.calculating&#039;, { cart });
      const totals = await this.calculateTotals(cart);

      // Step 3: Request payment
      pan.publish(&#039;payment.requested&#039;, { totals });
    } catch (error) {
      pan.publish(&#039;checkout.failed&#039;, { error: error.message });
    }
  }

  handlePaymentComplete = async ({ paymentId, totals }) =&gt; {
    try {
      // Step 4: Create order
      pan.publish(&#039;order.creating&#039;, { paymentId });
      const order = await this.createOrder(paymentId, totals);

      pan.publish(&#039;order.created&#039;, { order });
    } catch (error) {
      // Compensating transaction: refund payment
      pan.publish(&#039;payment.refund-requested&#039;, { paymentId });
      pan.publish(&#039;checkout.failed&#039;, { error: error.message });
    }
  }

  handleOrderCreated = async ({ order }) =&gt; {
    // Step 5: Send confirmation
    pan.publish(&#039;order.confirmation-sending&#039;, { order });
    await this.sendConfirmation(order);

    // Step 6: Complete checkout
    pan.publish(&#039;checkout.completed&#039;, { order });
  }
}</code></pre>
<strong>Use when:</strong>
<ul><li>Complex multi-step workflows</li>
<li>Need to handle failures and rollbacks</li>
<li>Coordinating multiple services</li>
</ul>
<h2>Debugging PAN Communication</h2>
<p>!<a href="../images/05-pan-bus-10.png"><strong>Figure 5.7:</strong> PAN Bus Internal Architecture</a></p>
<strong><em>Figure 5.7:</strong> PAN Bus Internal Architecture</em>
<p>Debugging event-driven systems requires different techniques than traditional debugging.</p>
<h3>Logging All Events</h3>
<pre><code class="language-javascript">// Enable debug mode
pan.debug(true);

// Or manually subscribe to all events
pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
  console.group(`[PAN] ${topic}`);
  console.log(&#039;Data:&#039;, data);
  console.log(&#039;Timestamp:&#039;, new Date().toISOString());
  console.trace(&#039;Stack trace&#039;);
  console.groupEnd();
});</code></pre>
<h3>Event Inspector</h3>
<p>Build a visual event inspector:</p>
<pre><code class="language-javascript">class PanInspector extends HTMLElement {
  constructor() {
    super();
    this.events = [];
    this.maxEvents = 100;
  }

  connectedCallback() {
    this.render();

    pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
      this.logEvent(topic, data);
    });
  }

  logEvent(topic, data) {
    this.events.unshift({
      topic,
      data,
      timestamp: Date.now()
    });

    if (this.events.length &gt; this.maxEvents) {
      this.events.pop();
    }

    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;style&gt;
        .pan-inspector {
          position: fixed;
          bottom: 0;
          right: 0;
          width: 400px;
          height: 300px;
          background: white;
          border: 1px solid #ccc;
          overflow: auto;
          font-family: monospace;
          font-size: 12px;
        }

        .event {
          padding: 8px;
          border-bottom: 1px solid #eee;
        }

        .event:hover {
          background: #f5f5f5;
        }

        .topic {
          font-weight: bold;
          color: #667eea;
        }

        .timestamp {
          color: #999;
          font-size: 10px;
        }

        .data {
          margin-top: 4px;
          color: #333;
        }
      &lt;/style&gt;

      &lt;div class=&quot;pan-inspector&quot;&gt;
        &lt;h3&gt;PAN Event Inspector&lt;/h3&gt;
        ${this.events.map(event =&gt; `
          &lt;div class=&quot;event&quot;&gt;
            &lt;div class=&quot;topic&quot;&gt;${event.topic}&lt;/div&gt;
            &lt;div class=&quot;timestamp&quot;&gt;${new Date(event.timestamp).toLocaleTimeString()}&lt;/div&gt;
            &lt;div class=&quot;data&quot;&gt;${JSON.stringify(event.data, null, 2)}&lt;/div&gt;
          &lt;/div&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;pan-inspector&#039;, PanInspector);</code></pre>
<h3>Event Filtering</h3>
<p>Filter events for specific topics:</p>
<pre><code class="language-javascript">function filterEvents(pattern) {
  const regex = new RegExp(pattern.replace(&#039;*&#039;, &#039;.*&#039;));

  pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
    if (regex.test(topic)) {
      console.log(`[FILTERED] ${topic}:`, data);
    }
  });
}

// Usage
filterEvents(&#039;user.*&#039;);     // Only user events
filterEvents(&#039;*.error&#039;);    // All error events
filterEvents(&#039;cart|order&#039;); // Cart or order events</code></pre>
<h3>Performance Monitoring</h3>
<p>Track event frequency and performance:</p>
<pre><code class="language-javascript">class PanMonitor {
  constructor() {
    this.stats = new Map();

    pan.subscribe(&#039;*&#039;, (topic) =&gt; {
      const stat = this.stats.get(topic) || { count: 0, timestamps: [] };

      stat.count++;
      stat.timestamps.push(Date.now());

      // Keep only last 100 timestamps
      if (stat.timestamps.length &gt; 100) {
        stat.timestamps.shift();
      }

      this.stats.set(topic, stat);
    });
  }

  getStats(topic) {
    const stat = this.stats.get(topic);
    if (!stat) return null;

    const timestamps = stat.timestamps;
    const duration = timestamps[timestamps.length - 1] - timestamps[0];
    const frequency = timestamps.length / (duration / 1000);

    return {
      topic,
      count: stat.count,
      frequency: frequency.toFixed(2) + &#039; events/sec&#039;,
      lastEvent: new Date(timestamps[timestamps.length - 1])
    };
  }

  getAllStats() {
    const results = [];

    this.stats.forEach((_, topic) =&gt; {
      results.push(this.getStats(topic));
    });

    return results.sort((a, b) =&gt; b.count - a.count);
  }

  reset() {
    this.stats.clear();
  }
}

// Usage
const monitor = new PanMonitor();

// Later, check stats
console.table(monitor.getAllStats());</code></pre>
<h3>Event Replay</h3>
<p>Capture and replay events for testing:</p>
<pre><code class="language-javascript">class EventRecorder {
  constructor() {
    this.recording = false;
    this.events = [];
  }

  start() {
    this.recording = true;
    this.events = [];

    this.unsubscribe = pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
      if (this.recording) {
        this.events.push({ topic, data, timestamp: Date.now() });
      }
    });
  }

  stop() {
    this.recording = false;
    if (this.unsubscribe) {
      this.unsubscribe();
    }

    return this.events;
  }

  replay(events, speed = 1) {
    if (!events || events.length === 0) return;

    const startTime = events[0].timestamp;

    events.forEach((event, index) =&gt; {
      const delay = (event.timestamp - startTime) / speed;

      setTimeout(() =&gt; {
        pan.publish(event.topic, event.data);
      }, delay);
    });
  }

  save(name) {
    localStorage.setItem(`pan-recording-${name}`, JSON.stringify(this.events));
  }

  load(name) {
    const data = localStorage.getItem(`pan-recording-${name}`);
    return data ? JSON.parse(data) : null;
  }
}

// Usage
const recorder = new EventRecorder();

// Start recording
recorder.start();

// ... perform actions ...

// Stop and save
const events = recorder.stop();
recorder.save(&#039;my-test-scenario&#039;);

// Later, replay
const events = recorder.load(&#039;my-test-scenario&#039;);
recorder.replay(events, 2); // 2x speed</code></pre>
<h2>Summary</h2>
<p>This chapter covered:</p>
<ul><li><strong>Pub/Sub Architecture</strong>: Decoupled communication via topics</li>
<li><strong>Topics and Namespaces</strong>: Organizing events with hierarchical naming</li>
<li><strong>Publishing</strong>: Sending messages and event patterns</li>
<li><strong>Subscribing</strong>: Receiving and filtering events</li>
<li><strong>Message Patterns</strong>: Fire-and-forget, request/response, commands, sagas</li>
<li><strong>Debugging</strong>: Logging, inspection, monitoring, and replay tools</li>
</ul>
The PAN bus is central to LARC applications. Mastering it enables you to build scalable, maintainable applications where components collaborate without tight coupling.
<hr>
<h2>Best Practices</h2>
<li><strong>Use descriptive topic names</strong></li>
   - <code>user.profile.updated</code> not <code>userUpdated</code>
   - Past tense for events that happened
   - Include context in message data
<li><strong>Clean up subscriptions</strong></li>
   - Always unsubscribe in <code>disconnectedCallback</code>
   - Use subscription managers for multiple subscriptions
   - Avoid memory leaks
<li><strong>Avoid infinite loops</strong></li>
   - Don't publish the same event you're subscribed to
   - Use different topics for input and output
   - Add loop detection in debug mode
<li><strong>Keep handlers fast</strong></li>
   - Don't block the event loop
   - Use async/await for long operations
   - Consider debouncing rapid events
<li><strong>Include metadata</strong></li>
   - Timestamp, source, user ID for debugging
   - Request IDs for tracing
   - Error details for failures
<li><strong>Test event flows</strong></li>
   - Use event recorders for integration tests
   - Mock pan.publish/subscribe in unit tests
   - Verify event contracts between components
<p>\pagebreak</p>
<h1>Chapter 6: State Management</h1>
<p>!<a href="../images/06-state-management-3.png"><strong>Figure 6.1:</strong> State Management Hierarchy</a></p>
<strong><em>Figure 6.1:</strong> State Management Hierarchy</em>
<p>State management is one of the most critical aspects of application development. Poor state management leads to bugs, performance issues, and maintenance nightmares. Good state management makes applications predictable, testable, and maintainable.</p>
<p>LARC takes a pragmatic approach: start simple and scale complexity only when needed. This chapter explores state management at every level, from component-local state to distributed, offline-first architectures.</p>
<h2>Component-Local State</h2>
<p>The simplest form of state lives entirely within a single component. This is your first choice for most scenarios.</p>
<h3>Instance Properties</h3>
<p>Use instance properties for component-specific state:</p>
<pre><code class="language-javascript">class ToggleSwitch extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });

    // Local state
    this.isOn = false;
  }

  connectedCallback() {
    this.render();

    this.shadowRoot.querySelector(&#039;button&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.isOn = !this.isOn;  // Update state
      this.render();            // Re-render

      // Notify others
      this.dispatchEvent(new CustomEvent(&#039;toggle&#039;, {
        detail: { isOn: this.isOn }
      }));
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button {
          background: ${this.isOn ? &#039;#48bb78&#039; : &#039;#cbd5e0&#039;};
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
        }
      &lt;/style&gt;
      &lt;button&gt;${this.isOn ? &#039;ON&#039; : &#039;OFF&#039;}&lt;/button&gt;
    `;
  }
}</code></pre>
<strong>When to use:</strong>
<ul><li>UI state (expanded/collapsed, selected, etc.)</li>
<li>Temporary values (search input, form drafts)</li>
<li>Component-specific configuration</li>
</ul>
<strong>Advantages:</strong>
<ul><li>Simple and straightforward</li>
<li>No dependencies on external state</li>
<li>Easy to reason about</li>
<li>Easy to test</li>
</ul>
<h3>Private Fields</h3>
<p>Use private fields (with <code>#</code>) for true encapsulation:</p>
<pre><code class="language-javascript">class Counter extends HTMLElement {
  // Private fields
  #count = 0;
  #max = 100;
  #min = 0;

  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  // Public getter
  get count() {
    return this.#count;
  }

  // Public setter with validation
  set count(value) {
    const newCount = Number(value);

    if (isNaN(newCount)) {
      throw new Error(&#039;Count must be a number&#039;);
    }

    if (newCount &lt; this.#min || newCount &gt; this.#max) {
      throw new Error(`Count must be between ${this.#min} and ${this.#max}`);
    }

    this.#count = newCount;
    this.render();
  }

  increment() {
    this.count = Math.min(this.#count + 1, this.#max);
  }

  decrement() {
    this.count = Math.max(this.#count - 1, this.#min);
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;div&gt;${this.#count}&lt;/div&gt;
    `;
  }
}</code></pre>
<strong>Benefits:</strong>
<ul><li>True privacy (can't access from outside)</li>
<li>Validation at setter boundaries</li>
<li>Clear public API</li>
</ul>
<h3>State Objects</h3>
<p>Organize related state in objects:</p>
<pre><code class="language-javascript">class UserProfile extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });

    // Group related state
    this.state = {
      user: null,
      loading: false,
      error: null,
      editMode: false
    };
  }

  setState(updates) {
    // Merge updates into state
    this.state = {
      ...this.state,
      ...updates
    };

    this.render();
  }

  async loadUser(userId) {
    this.setState({ loading: true, error: null });

    try {
      const response = await fetch(`/api/users/${userId}`);
      const user = await response.json();

      this.setState({ user, loading: false });
    } catch (error) {
      this.setState({ error: error.message, loading: false });
    }
  }

  render() {
    const { user, loading, error, editMode } = this.state;

    if (loading) {
      this.shadowRoot.innerHTML = &#039;&lt;div&gt;Loading...&lt;/div&gt;&#039;;
    } else if (error) {
      this.shadowRoot.innerHTML = `&lt;div class=&quot;error&quot;&gt;${error}&lt;/div&gt;`;
    } else if (user) {
      this.shadowRoot.innerHTML = `
        &lt;div&gt;
          &lt;h2&gt;${user.name}&lt;/h2&gt;
          ${editMode ? this.renderEditForm() : this.renderDisplay()}
        &lt;/div&gt;
      `;
    }
  }
}</code></pre>
<strong>Benefits:</strong>
<ul><li>Organized state structure</li>
<li>Single method to update state</li>
<li>Clear state shape</li>
<li>Easier debugging (log entire state)</li>
</ul>
<h2>Shared State Patterns</h2>
<p>When multiple components need access to the same data, you need shared state.</p>
<h3>Simple Global State</h3>
<p>Create a shared state object:</p>
<pre><code class="language-javascript">// lib/state.js
export const appState = {
  user: null,
  theme: &#039;light&#039;,
  language: &#039;en&#039;,
  notifications: []
};

// Update state
export function updateState(updates) {
  Object.assign(appState, updates);
  pan.publish(&#039;app.state.changed&#039;, appState);
}

// Get state
export function getState() {
  return { ...appState };
}</code></pre>
<strong>Usage in components:</strong>
<pre><code class="language-javascript">import { appState, updateState } from &#039;../lib/state.js&#039;;

class ThemeSwitcher extends HTMLElement {
  connectedCallback() {
    // Read initial state
    this.render(appState.theme);

    // Subscribe to changes
    this.unsubscribe = pan.subscribe(&#039;app.state.changed&#039;, (state) =&gt; {
      this.render(state.theme);
    });

    // Add event listener
    this.addEventListener(&#039;click&#039;, () =&gt; {
      const newTheme = appState.theme === &#039;light&#039; ? &#039;dark&#039; : &#039;light&#039;;
      updateState({ theme: newTheme });
    });
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  render(theme) {
    this.textContent = `Theme: ${theme}`;
  }
}</code></pre>
<h3>Reactive State with Proxy</h3>
<p>Make state changes automatically trigger updates:</p>
<pre><code class="language-javascript">// lib/reactive-state.js
export function createReactiveState(initialState) {
  const listeners = new Set();

  const state = new Proxy(initialState, {
    set(target, property, value) {
      const oldValue = target[property];
      target[property] = value;

      // Notify listeners
      listeners.forEach(listener =&gt; {
        listener(property, value, oldValue);
      });

      // Also publish via PAN
      pan.publish(&#039;state.changed&#039;, {
        property,
        value,
        oldValue
      });

      return true;
    },

    get(target, property) {
      return target[property];
    }
  });

  return {
    state,
    subscribe(listener) {
      listeners.add(listener);
      return () =&gt; listeners.delete(listener);
    },
    getState() {
      return { ...state };
    }
  };
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">// Create reactive state
const { state, subscribe } = createReactiveState({
  count: 0,
  user: null,
  theme: &#039;light&#039;
});

// Components automatically react to changes
class CountDisplay extends HTMLElement {
  connectedCallback() {
    // Subscribe to specific property changes
    this.unsubscribe = subscribe((property, value) =&gt; {
      if (property === &#039;count&#039;) {
        this.textContent = `Count: ${value}`;
      }
    });

    // Initial render
    this.textContent = `Count: ${state.count}`;
  }

  disconnectedCallback() {
    this.unsubscribe();
  }
}

// Update state (automatically triggers updates)
state.count++;  // All subscribers notified
state.count = 42;  // All subscribers notified</code></pre>
<h3>Store Pattern</h3>
<p>Build a more sophisticated store:</p>
<pre><code class="language-javascript">// lib/store.js
class Store {
  constructor(initialState = {}) {
    this.state = initialState;
    this.listeners = new Map();
    this.middleware = [];
  }

  getState() {
    return { ...this.state };
  }

  setState(updates) {
    const oldState = { ...this.state };
    this.state = { ...this.state, ...updates };

    // Run middleware
    this.middleware.forEach(fn =&gt; fn(this.state, oldState));

    // Notify listeners
    this.listeners.forEach((listeners, key) =&gt; {
      if (key === &#039;*&#039; || key in updates) {
        listeners.forEach(listener =&gt; {
          listener(this.state, oldState);
        });
      }
    });
  }

  subscribe(key, listener) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }

    this.listeners.get(key).add(listener);

    // Return unsubscribe function
    return () =&gt; {
      const listeners = this.listeners.get(key);
      if (listeners) {
        listeners.delete(listener);
      }
    };
  }

  use(middleware) {
    this.middleware.push(middleware);
  }

  dispatch(action) {
    // Action pattern: { type, payload }
    switch (action.type) {
      case &#039;user/login&#039;:
        this.setState({ user: action.payload });
        break;
      case &#039;user/logout&#039;:
        this.setState({ user: null });
        break;
      case &#039;theme/change&#039;:
        this.setState({ theme: action.payload });
        break;
      default:
        console.warn(`Unknown action: ${action.type}`);
    }
  }
}

// Create store instance
export const store = new Store({
  user: null,
  theme: &#039;light&#039;,
  notifications: []
});

// Add logging middleware
store.use((state, oldState) =&gt; {
  console.log(&#039;State changed:&#039;, { old: oldState, new: state });
});

// Add persistence middleware
store.use((state) =&gt; {
  localStorage.setItem(&#039;app-state&#039;, JSON.stringify(state));
});</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { store } from &#039;../lib/store.js&#039;;

class UserMenu extends HTMLElement {
  connectedCallback() {
    // Subscribe to user changes only
    this.unsubscribe = store.subscribe(&#039;user&#039;, (state) =&gt; {
      this.render(state.user);
    });

    // Initial render
    this.render(store.getState().user);
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  render(user) {
    if (user) {
      this.innerHTML = `
        &lt;div&gt;Hello, ${user.name}&lt;/div&gt;
        &lt;button id=&quot;logout&quot;&gt;Logout&lt;/button&gt;
      `;

      this.querySelector(&#039;#logout&#039;).addEventListener(&#039;click&#039;, () =&gt; {
        store.dispatch({ type: &#039;user/logout&#039; });
      });
    } else {
      this.innerHTML = &#039;&lt;button id=&quot;login&quot;&gt;Login&lt;/button&gt;&#039;;

      this.querySelector(&#039;#login&#039;).addEventListener(&#039;click&#039;, () =&gt; {
        // Trigger login flow
        pan.publish(&#039;auth.login.requested&#039;);
      });
    }
  }
}</code></pre>
<h2>The pan-store Component</h2>
<p>!<a href="../images/06-state-management-9.png"><strong>Figure 6.2:</strong> pan-store Architecture</a></p>
<strong><em>Figure 6.2:</strong> pan-store Architecture</em>
<p>!<a href="../images/06-state-management-9.png"><strong>Figure 6.2:</strong> pan-store Architecture</a>
<strong><em>Figure 6.2:</strong> pan-store Architecture</em></p>
<p>LARC provides a built-in component for state management:</p>
<pre><code class="language-html">&lt;pan-store id=&quot;app-store&quot; persist=&quot;true&quot;&gt;
  &lt;!-- Initial state --&gt;
  &lt;script type=&quot;application/json&quot;&gt;
  {
    &quot;user&quot;: null,
    &quot;theme&quot;: &quot;light&quot;,
    &quot;cart&quot;: {
      &quot;items&quot;: [],
      &quot;total&quot;: 0
    }
  }
  &lt;/script&gt;
&lt;/pan-store&gt;

&lt;script type=&quot;module&quot;&gt;
  const store = document.getElementById(&#039;app-store&#039;);

  // Get state
  const state = store.getState();

  // Update state
  store.setState({ theme: &#039;dark&#039; });

  // Subscribe to changes
  store.addEventListener(&#039;state-changed&#039;, (e) =&gt; {
    console.log(&#039;State changed:&#039;, e.detail);
  });

  // Or use PAN bus
  pan.subscribe(&#039;store.changed&#039;, (state) =&gt; {
    console.log(&#039;State via PAN:&#039;, state);
  });
&lt;/script&gt;</code></pre>
<strong>Features:</strong>
<ul><li>Declarative state initialization</li>
<li>Optional persistence to localStorage</li>
<li>Integrates with PAN bus</li>
<li>Supports nested state updates</li>
<li>Time-travel debugging in dev mode</li>
</ul>
<strong>Advanced usage:</strong>
<pre><code class="language-javascript">// Get nested state
const cartItems = store.getState(&#039;cart.items&#039;);

// Update nested state
store.setState(&#039;cart.items&#039;, [...items, newItem]);

// Subscribe to specific paths
store.subscribe(&#039;cart.total&#039;, (value) =&gt; {
  console.log(&#039;Cart total changed:&#039;, value);
});

// Computed properties
store.computed(&#039;cart.itemCount&#039;, (state) =&gt; {
  return state.cart.items.length;
});

// Actions
store.action(&#039;addToCart&#039;, (item) =&gt; {
  const cart = store.getState(&#039;cart&#039;);
  const items = [...cart.items, item];
  const total = items.reduce((sum, item) =&gt; sum + item.price, 0);

  store.setState({
    &#039;cart.items&#039;: items,
    &#039;cart.total&#039;: total
  });
});

// Use action
store.dispatch(&#039;addToCart&#039;, { id: 1, name: &#039;Product&#039;, price: 29.99 });</code></pre>
<h2>IndexedDB Integration</h2>
<p>For large datasets or offline capability, use IndexedDB:</p>
<h3>Basic IndexedDB Wrapper</h3>
<pre><code class="language-javascript">// lib/db.js
class Database {
  constructor(name, version = 1) {
    this.name = name;
    this.version = version;
    this.db = null;
  }

  async open(stores) {
    return new Promise((resolve, reject) =&gt; {
      const request = indexedDB.open(this.name, this.version);

      request.onerror = () =&gt; reject(request.error);
      request.onsuccess = () =&gt; {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) =&gt; {
        const db = event.target.result;

        stores.forEach(({ name, keyPath, indexes }) =&gt; {
          if (!db.objectStoreNames.contains(name)) {
            const store = db.createObjectStore(name, { keyPath });

            indexes?.forEach(({ name, keyPath, options }) =&gt; {
              store.createIndex(name, keyPath, options);
            });
          }
        });
      };
    });
  }

  async add(storeName, data) {
    const tx = this.db.transaction(storeName, &#039;readwrite&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.add(data);
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async get(storeName, key) {
    const tx = this.db.transaction(storeName, &#039;readonly&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.get(key);
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async getAll(storeName) {
    const tx = this.db.transaction(storeName, &#039;readonly&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.getAll();
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async update(storeName, data) {
    const tx = this.db.transaction(storeName, &#039;readwrite&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.put(data);
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async delete(storeName, key) {
    const tx = this.db.transaction(storeName, &#039;readwrite&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.delete(key);
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async clear(storeName) {
    const tx = this.db.transaction(storeName, &#039;readwrite&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.clear();
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }
}

// Initialize database
export const db = new Database(&#039;MyApp&#039;, 1);

await db.open([
  {
    name: &#039;todos&#039;,
    keyPath: &#039;id&#039;,
    indexes: [
      { name: &#039;by-status&#039;, keyPath: &#039;status&#039; },
      { name: &#039;by-created&#039;, keyPath: &#039;createdAt&#039; }
    ]
  },
  {
    name: &#039;users&#039;,
    keyPath: &#039;id&#039;
  }
]);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { db } from &#039;../lib/db.js&#039;;

class TodoList extends HTMLElement {
  async connectedCallback() {
    // Load todos from IndexedDB
    this.todos = await db.getAll(&#039;todos&#039;);
    this.render();

    // Subscribe to changes
    pan.subscribe(&#039;todo.added&#039;, async ({ todo }) =&gt; {
      await db.add(&#039;todos&#039;, todo);
      this.todos = await db.getAll(&#039;todos&#039;);
      this.render();
    });

    pan.subscribe(&#039;todo.updated&#039;, async ({ todo }) =&gt; {
      await db.update(&#039;todos&#039;, todo);
      this.todos = await db.getAll(&#039;todos&#039;);
      this.render();
    });

    pan.subscribe(&#039;todo.deleted&#039;, async ({ id }) =&gt; {
      await db.delete(&#039;todos&#039;, id);
      this.todos = await db.getAll(&#039;todos&#039;);
      this.render();
    });
  }

  render() {
    this.innerHTML = `
      &lt;ul&gt;
        ${this.todos.map(todo =&gt; `
          &lt;li&gt;
            &lt;span&gt;${todo.text}&lt;/span&gt;
            &lt;button data-id=&quot;${todo.id}&quot;&gt;Delete&lt;/button&gt;
          &lt;/li&gt;
        `).join(&#039;&#039;)}
      &lt;/ul&gt;
    `;
  }
}</code></pre>
<h3>Cache-First Strategy</h3>
<p>Implement cache-first data loading:</p>
<pre><code class="language-javascript">class DataManager {
  constructor(storeName) {
    this.storeName = storeName;
    this.cache = new Map();
  }

  async get(id) {
    // 1. Check memory cache
    if (this.cache.has(id)) {
      return this.cache.get(id);
    }

    // 2. Check IndexedDB
    const cached = await db.get(this.storeName, id);
    if (cached) {
      this.cache.set(id, cached);
      return cached;
    }

    // 3. Fetch from API
    const data = await this.fetchFromAPI(id);

    // 4. Store in cache and IndexedDB
    this.cache.set(id, data);
    await db.add(this.storeName, data);

    return data;
  }

  async fetchFromAPI(id) {
    const response = await fetch(`/api/${this.storeName}/${id}`);
    return response.json();
  }

  async refresh(id) {
    // Force refresh from API
    const data = await this.fetchFromAPI(id);

    // Update cache and IndexedDB
    this.cache.set(id, data);
    await db.update(this.storeName, data);

    return data;
  }

  async getAll() {
    // Load from IndexedDB first
    const items = await db.getAll(this.storeName);

    // Cache in memory
    items.forEach(item =&gt; {
      this.cache.set(item.id, item);
    });

    return items;
  }
}

// Usage
const userManager = new DataManager(&#039;users&#039;);

// Always returns fast (from cache if available)
const user = await userManager.get(123);

// Force refresh
const freshUser = await userManager.refresh(123);</code></pre>
<h2>Persistence Strategies</h2>
<h3>localStorage</h3>
<p>Simple key-value storage:</p>
<pre><code class="language-javascript">class PersistentState {
  constructor(key) {
    this.key = key;
    this.state = this.load();
  }

  load() {
    try {
      const data = localStorage.getItem(this.key);
      return data ? JSON.parse(data) : {};
    } catch (error) {
      console.error(&#039;Failed to load state:&#039;, error);
      return {};
    }
  }

  save() {
    try {
      localStorage.setItem(this.key, JSON.stringify(this.state));
    } catch (error) {
      console.error(&#039;Failed to save state:&#039;, error);
    }
  }

  get(path) {
    return this.getNestedValue(this.state, path);
  }

  set(path, value) {
    this.setNestedValue(this.state, path, value);
    this.save();
  }

  getNestedValue(obj, path) {
    return path.split(&#039;.&#039;).reduce((current, key) =&gt; current?.[key], obj);
  }

  setNestedValue(obj, path, value) {
    const keys = path.split(&#039;.&#039;);
    const lastKey = keys.pop();
    const target = keys.reduce((current, key) =&gt; {
      if (!(key in current)) current[key] = {};
      return current[key];
    }, obj);
    target[lastKey] = value;
  }

  clear() {
    this.state = {};
    localStorage.removeItem(this.key);
  }
}

// Usage
const settings = new PersistentState(&#039;app-settings&#039;);

settings.set(&#039;theme&#039;, &#039;dark&#039;);
settings.set(&#039;user.preferences.notifications&#039;, true);

console.log(settings.get(&#039;theme&#039;));  // &#039;dark&#039;
console.log(settings.get(&#039;user.preferences.notifications&#039;));  // true</code></pre>
<h3>sessionStorage</h3>
<p>For temporary session data:</p>
<pre><code class="language-javascript">class SessionState {
  constructor(key) {
    this.key = key;
  }

  set(data) {
    sessionStorage.setItem(this.key, JSON.stringify(data));
  }

  get() {
    const data = sessionStorage.getItem(this.key);
    return data ? JSON.parse(data) : null;
  }

  clear() {
    sessionStorage.removeItem(this.key);
  }
}

// Usage - data persists only for the session
const sessionData = new SessionState(&#039;form-draft&#039;);

// Save form draft
sessionData.set({ email: &#039;user@example.com&#039;, message: &#039;Draft...&#039; });

// Restore on page reload (same session)
const draft = sessionData.get();</code></pre>
<h3>Hybrid Strategy</h3>
<p>Combine localStorage and IndexedDB:</p>
<pre><code class="language-javascript">class HybridStorage {
  constructor(namespace) {
    this.namespace = namespace;
  }

  async set(key, value) {
    const fullKey = `${this.namespace}:${key}`;

    // Store small data in localStorage
    if (this.isSmall(value)) {
      localStorage.setItem(fullKey, JSON.stringify(value));
    } else {
      // Store large data in IndexedDB
      await db.update(&#039;storage&#039;, { key: fullKey, value });
    }
  }

  async get(key) {
    const fullKey = `${this.namespace}:${key}`;

    // Try localStorage first
    const local = localStorage.getItem(fullKey);
    if (local) {
      return JSON.parse(local);
    }

    // Try IndexedDB
    const result = await db.get(&#039;storage&#039;, fullKey);
    return result?.value;
  }

  isSmall(value) {
    const str = JSON.stringify(value);
    return str.length &lt; 1024 * 10; // 10KB threshold
  }

  async clear() {
    // Clear localStorage items
    Object.keys(localStorage).forEach(key =&gt; {
      if (key.startsWith(`${this.namespace}:`)) {
        localStorage.removeItem(key);
      }
    });

    // Clear IndexedDB items
    const all = await db.getAll(&#039;storage&#039;);
    for (const item of all) {
      if (item.key.startsWith(`${this.namespace}:`)) {
        await db.delete(&#039;storage&#039;, item.key);
      }
    }
  }
}</code></pre>
<h2>Offline-First Applications</h2>
<p>Build applications that work without connectivity:</p>
<h3>Service Worker + State Management</h3>
<pre><code class="language-javascript">// sw.js - Service Worker
self.addEventListener(&#039;install&#039;, (event) =&gt; {
  event.waitUntil(
    caches.open(&#039;v1&#039;).then((cache) =&gt; {
      return cache.addAll([
        &#039;/&#039;,
        &#039;/index.html&#039;,
        &#039;/src/app.js&#039;,
        &#039;/&#039;,
        // Cache critical assets
      ]);
    })
  );
});

self.addEventListener(&#039;fetch&#039;, (event) =&gt; {
  event.respondWith(
    caches.match(event.request).then((response) =&gt; {
      // Return cached version or fetch
      return response || fetch(event.request);
    })
  );
});</code></pre>
<h3>Sync Queue</h3>
<p>Queue operations when offline:</p>
<pre><code class="language-javascript">// lib/sync-queue.js
class SyncQueue {
  constructor() {
    this.queue = this.loadQueue();
    this.processing = false;

    // Listen for online events
    window.addEventListener(&#039;online&#039;, () =&gt; {
      this.process();
    });

    // Start processing if online
    if (navigator.onLine) {
      this.process();
    }
  }

  loadQueue() {
    const data = localStorage.getItem(&#039;sync-queue&#039;);
    return data ? JSON.parse(data) : [];
  }

  saveQueue() {
    localStorage.setItem(&#039;sync-queue&#039;, JSON.stringify(this.queue));
  }

  add(operation) {
    this.queue.push({
      id: Date.now() + Math.random(),
      operation,
      timestamp: Date.now(),
      attempts: 0
    });

    this.saveQueue();

    if (navigator.onLine) {
      this.process();
    }
  }

  async process() {
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;

    while (this.queue.length &gt; 0 &amp;&amp; navigator.onLine) {
      const item = this.queue[0];

      try {
        await this.executeOperation(item.operation);

        // Success - remove from queue
        this.queue.shift();
        this.saveQueue();

        pan.publish(&#039;sync.success&#039;, { operation: item.operation });
      } catch (error) {
        item.attempts++;

        if (item.attempts &gt;= 3) {
          // Max attempts - remove and report error
          this.queue.shift();
          this.saveQueue();

          pan.publish(&#039;sync.failed&#039;, {
            operation: item.operation,
            error: error.message
          });
        } else {
          // Retry later
          break;
        }
      }
    }

    this.processing = false;
  }

  async executeOperation(operation) {
    switch (operation.type) {
      case &#039;CREATE&#039;:
        return this.create(operation.data);
      case &#039;UPDATE&#039;:
        return this.update(operation.data);
      case &#039;DELETE&#039;:
        return this.delete(operation.id);
      default:
        throw new Error(`Unknown operation: ${operation.type}`);
    }
  }

  async create(data) {
    const response = await fetch(&#039;/api/items&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(data)
    });

    if (!response.ok) throw new Error(&#039;Create failed&#039;);
    return response.json();
  }

  async update(data) {
    const response = await fetch(`/api/items/${data.id}`, {
      method: &#039;PUT&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(data)
    });

    if (!response.ok) throw new Error(&#039;Update failed&#039;);
    return response.json();
  }

  async delete(id) {
    const response = await fetch(`/api/items/${id}`, {
      method: &#039;DELETE&#039;
    });

    if (!response.ok) throw new Error(&#039;Delete failed&#039;);
  }

  clear() {
    this.queue = [];
    this.saveQueue();
  }

  getStatus() {
    return {
      queued: this.queue.length,
      online: navigator.onLine,
      processing: this.processing
    };
  }
}

export const syncQueue = new SyncQueue();</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { syncQueue } from &#039;../lib/sync-queue.js&#039;;

class TodoManager {
  async addTodo(text) {
    const todo = {
      id: Date.now(),
      text,
      completed: false,
      createdAt: new Date()
    };

    // Save locally immediately
    await db.add(&#039;todos&#039;, todo);
    pan.publish(&#039;todo.added&#039;, { todo });

    // Queue for server sync
    if (!navigator.onLine) {
      syncQueue.add({
        type: &#039;CREATE&#039;,
        data: todo
      });

      pan.publish(&#039;notification.info&#039;, {
        message: &#039;Saved locally. Will sync when online.&#039;
      });
    } else {
      // Online - sync immediately
      try {
        await this.syncToServer(todo);
      } catch (error) {
        // Failed - add to queue
        syncQueue.add({
          type: &#039;CREATE&#039;,
          data: todo
        });
      }
    }
  }

  async syncToServer(todo) {
    const response = await fetch(&#039;/api/todos&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(todo)
    });

    if (!response.ok) {
      throw new Error(&#039;Sync failed&#039;);
    }

    const result = await response.json();

    // Update local copy with server ID
    await db.update(&#039;todos&#039;, { ...todo, serverId: result.id });
  }
}</code></pre>
<h2>Summary</h2>
<p>This chapter covered state management at every level:</p>
<ul><li><strong>Component-Local State</strong>: Instance properties, private fields, and state objects</li>
<li><strong>Shared State</strong>: Global state, reactive proxies, and store patterns</li>
<li><strong>pan-store</strong>: Built-in state management component</li>
<li><strong>IndexedDB</strong>: Large dataset storage and offline capability</li>
<li><strong>Persistence</strong>: localStorage, sessionStorage, and hybrid strategies</li>
<li><strong>Offline-First</strong>: Service workers, sync queues, and conflict resolution</li>
</ul>
Choose the simplest solution that meets your needs, then scale up complexity as requirements grow.
<hr>
<h2>Best Practices</h2>
<li><strong>Start with local state</strong></li>
   - Only share state when necessary
   - Keeps components independent
   - Easier to test and debug
<li><strong>Use IndexedDB for large data</strong></li>
   - localStorage limited to ~5-10MB
   - IndexedDB can store gigabytes
   - Better performance for large datasets
<li><strong>Implement cache-first strategies</strong></li>
   - Load from cache immediately
   - Update from server in background
   - Show stale data rather than loading spinner
<li><strong>Queue offline operations</strong></li>
   - Don't lose user data
   - Sync when connection restored
   - Show sync status to user
<li><strong>Test offline scenarios</strong></li>
   - Use DevTools to simulate offline
   - Test sync queue behavior
   - Verify conflict resolution
<li><strong>Monitor storage usage</strong></li>
   - Check quota before storing
   - Clean up old data
   - Provide clear error messages when full
\pagebreak
<h1>Chapter 7: Advanced Component Patterns</h1>
<p>As your LARC applications grow, you'll encounter scenarios that require sophisticated component architectures. This chapter explores advanced patterns that enable code reuse, flexible composition, and optimal performance.</p>
<p>These patterns come from years of component-based development across frameworks. LARC implements them using web standards, making them portable and future-proof.</p>
<h2>Compound Components</h2>
<p>Compound components work together as a set, sharing implicit state. Think of HTML's <code><select></code> and <code><option></code> elements—they form a cohesive unit.</p>
<h3>Basic Compound Component</h3>
<pre><code class="language-javascript">// tabs.js - Container component
class TabGroup extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.activeTab = 0;
  }

  connectedCallback() {
    this.render();
    this.setupTabs();
  }

  setupTabs() {
    // Get all tab headers
    const headers = this.querySelectorAll(&#039;tab-header&#039;);
    headers.forEach((header, index) =&gt; {
      header.addEventListener(&#039;click&#039;, () =&gt; {
        this.activeTab = index;
        this.updateTabs();
      });
    });

    this.updateTabs();
  }

  updateTabs() {
    // Update headers
    const headers = this.querySelectorAll(&#039;tab-header&#039;);
    headers.forEach((header, index) =&gt; {
      header.active = index === this.activeTab;
    });

    // Update panels
    const panels = this.querySelectorAll(&#039;tab-panel&#039;);
    panels.forEach((panel, index) =&gt; {
      panel.active = index === this.activeTab;
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
        }
        .headers {
          display: flex;
          border-bottom: 2px solid #e2e8f0;
        }
        .panels {
          padding: 16px 0;
        }
      &lt;/style&gt;
      &lt;div class=&quot;headers&quot;&gt;
        &lt;slot name=&quot;headers&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
      &lt;div class=&quot;panels&quot;&gt;
        &lt;slot name=&quot;panels&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;
  }
}

// tab-header.js
class TabHeader extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  set active(value) {
    this._active = value;
    this.render();
  }

  connectedCallback() {
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button {
          padding: 12px 24px;
          border: none;
          background: ${this._active ? &#039;#667eea&#039; : &#039;transparent&#039;};
          color: ${this._active ? &#039;white&#039; : &#039;#4a5568&#039;};
          cursor: pointer;
          font-weight: ${this._active ? &#039;600&#039; : &#039;400&#039;};
          transition: all 0.2s;
        }
        button:hover {
          background: ${this._active ? &#039;#5a67d8&#039; : &#039;#f7fafc&#039;};
        }
      &lt;/style&gt;
      &lt;button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;
    `;
  }
}

// tab-panel.js
class TabPanel extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  set active(value) {
    this._active = value;
    this.style.display = value ? &#039;block&#039; : &#039;none&#039;;
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
        }
      &lt;/style&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;
  }
}

customElements.define(&#039;tab-group&#039;, TabGroup);
customElements.define(&#039;tab-header&#039;, TabHeader);
customElements.define(&#039;tab-panel&#039;, TabPanel);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;tab-group&gt;
  &lt;tab-header slot=&quot;headers&quot;&gt;Profile&lt;/tab-header&gt;
  &lt;tab-header slot=&quot;headers&quot;&gt;Settings&lt;/tab-header&gt;
  &lt;tab-header slot=&quot;headers&quot;&gt;Billing&lt;/tab-header&gt;

  &lt;tab-panel slot=&quot;panels&quot;&gt;
    &lt;h2&gt;Profile Content&lt;/h2&gt;
    &lt;p&gt;User profile information...&lt;/p&gt;
  &lt;/tab-panel&gt;

  &lt;tab-panel slot=&quot;panels&quot;&gt;
    &lt;h2&gt;Settings Content&lt;/h2&gt;
    &lt;p&gt;Application settings...&lt;/p&gt;
  &lt;/tab-panel&gt;

  &lt;tab-panel slot=&quot;panels&quot;&gt;
    &lt;h2&gt;Billing Content&lt;/h2&gt;
    &lt;p&gt;Billing information...&lt;/p&gt;
  &lt;/tab-panel&gt;
&lt;/tab-group&gt;</code></pre>
<h3>Context API for Compound Components</h3>
<p>Share state without prop drilling:</p>
<pre><code class="language-javascript">// lib/context.js
const contexts = new WeakMap();

export function createContext(defaultValue) {
  return {
    Provider: class extends HTMLElement {
      constructor() {
        super();
        this.value = defaultValue;
        contexts.set(this, this.value);
      }

      provide(value) {
        this.value = value;
        contexts.set(this, value);
        this.notifyConsumers();
      }

      notifyConsumers() {
        const consumers = this.querySelectorAll(&#039;[data-context-consumer]&#039;);
        consumers.forEach(consumer =&gt; {
          if (consumer.onContextChange) {
            consumer.onContextChange(this.value);
          }
        });
      }

      connectedCallback() {
        this.innerHTML = `&lt;slot&gt;&lt;/slot&gt;`;
      }
    },

    Consumer: class extends HTMLElement {
      connectedCallback() {
        this.setAttribute(&#039;data-context-consumer&#039;, &#039;&#039;);

        // Find provider up the tree
        let provider = this.closest(&#039;[data-context-provider]&#039;);
        if (provider &amp;&amp; contexts.has(provider)) {
          this.onContextChange(contexts.get(provider));
        }
      }

      onContextChange(value) {
        // Override in subclasses
      }
    }
  };
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">// Create context
const ThemeContext = createContext({ theme: &#039;light&#039; });

// Provider component
class ThemeProvider extends ThemeContext.Provider {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute(&#039;data-context-provider&#039;, &#039;&#039;);

    this.provide({
      theme: &#039;light&#039;,
      toggleTheme: () =&gt; {
        const newTheme = this.value.theme === &#039;light&#039; ? &#039;dark&#039; : &#039;light&#039;;
        this.provide({ ...this.value, theme: newTheme });
      }
    });
  }
}

// Consumer component
class ThemedButton extends ThemeContext.Consumer {
  onContextChange(context) {
    this.context = context;
    this.render();
  }

  render() {
    const { theme } = this.context || { theme: &#039;light&#039; };

    this.innerHTML = `
      &lt;button style=&quot;
        background: ${theme === &#039;dark&#039; ? &#039;#333&#039; : &#039;#fff&#039;};
        color: ${theme === &#039;dark&#039; ? &#039;#fff&#039; : &#039;#333&#039;};
      &quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/button&gt;
    `;
  }
}

customElements.define(&#039;theme-provider&#039;, ThemeProvider);
customElements.define(&#039;themed-button&#039;, ThemedButton);</code></pre>
<pre><code class="language-html">&lt;theme-provider&gt;
  &lt;themed-button&gt;Light/Dark&lt;/themed-button&gt;
  &lt;themed-button&gt;Another Button&lt;/themed-button&gt;
&lt;/theme-provider&gt;</code></pre>
<h2>Higher-Order Components</h2>
<p>Higher-order components (HOCs) wrap other components to add functionality.</p>
<h3>Mixin Pattern</h3>
<p>JavaScript mixins add functionality to classes:</p>
<pre><code class="language-javascript">// mixins/observable.js
export const ObservableMixin = (Base) =&gt; class extends Base {
  constructor() {
    super();
    this._observers = new Map();
  }

  observe(property, callback) {
    if (!this._observers.has(property)) {
      this._observers.set(property, new Set());
    }
    this._observers.get(property).add(callback);

    // Return unobserve function
    return () =&gt; {
      this._observers.get(property)?.delete(callback);
    };
  }

  notify(property, value) {
    this._observers.get(property)?.forEach(callback =&gt; {
      callback(value);
    });
  }

  set(property, value) {
    this[`_${property}`] = value;
    this.notify(property, value);
  }

  get(property) {
    return this[`_${property}`];
  }
};

// mixins/resizable.js
export const ResizableMixin = (Base) =&gt; class extends Base {
  connectedCallback() {
    super.connectedCallback?.();

    this.resizeObserver = new ResizeObserver((entries) =&gt; {
      for (const entry of entries) {
        this.onResize?.(entry.contentRect);
      }
    });

    this.resizeObserver.observe(this);
  }

  disconnectedCallback() {
    super.disconnectedCallback?.();
    this.resizeObserver?.disconnect();
  }
};

// mixins/loading.js
export const LoadingMixin = (Base) =&gt; class extends Base {
  constructor() {
    super();
    this._loading = false;
  }

  startLoading() {
    this._loading = true;
    this.setAttribute(&#039;loading&#039;, &#039;&#039;);
    this.onLoadingChange?.(true);
  }

  stopLoading() {
    this._loading = false;
    this.removeAttribute(&#039;loading&#039;);
    this.onLoadingChange?.(false);
  }

  get loading() {
    return this._loading;
  }
};</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { ObservableMixin } from &#039;./mixins/observable.js&#039;;
import { ResizableMixin } from &#039;./mixins/resizable.js&#039;;
import { LoadingMixin } from &#039;./mixins/loading.js&#039;;

// Compose multiple mixins
class DataTable extends LoadingMixin(ResizableMixin(ObservableMixin(HTMLElement))) {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  async connectedCallback() {
    super.connectedCallback();

    // Use Observable mixin
    this.observe(&#039;data&#039;, (data) =&gt; {
      console.log(&#039;Data changed:&#039;, data);
      this.render();
    });

    // Use Loading mixin
    this.startLoading();
    const data = await this.fetchData();
    this.set(&#039;data&#039;, data);
    this.stopLoading();
  }

  // Use Resizable mixin
  onResize(rect) {
    console.log(&#039;Component resized:&#039;, rect.width, rect.height);
    this.updateLayout();
  }

  onLoadingChange(loading) {
    this.render();
  }

  async fetchData() {
    const response = await fetch(&#039;/api/data&#039;);
    return response.json();
  }

  render() {
    // Render based on state
  }
}

customElements.define(&#039;data-table&#039;, DataTable);</code></pre>
<h3>Decorator Pattern</h3>
<p>Wrap components to enhance them:</p>
<pre><code class="language-javascript">// decorators/with-loading.js
export function withLoading(ComponentClass) {
  return class extends ComponentClass {
    constructor() {
      super();
      this._originalConnectedCallback = this.connectedCallback;
    }

    connectedCallback() {
      // Inject loading overlay
      const loadingOverlay = document.createElement(&#039;div&#039;);
      loadingOverlay.className = &#039;loading-overlay&#039;;
      loadingOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255,255,255,0.8);
        display: none;
        align-items: center;
        justify-content: center;
      `;
      loadingOverlay.innerHTML = &#039;&lt;div class=&quot;spinner&quot;&gt;&lt;/div&gt;&#039;;

      this.appendChild(loadingOverlay);
      this._loadingOverlay = loadingOverlay;

      // Call original
      if (this._originalConnectedCallback) {
        this._originalConnectedCallback.call(this);
      }
    }

    showLoading() {
      if (this._loadingOverlay) {
        this._loadingOverlay.style.display = &#039;flex&#039;;
      }
    }

    hideLoading() {
      if (this._loadingOverlay) {
        this._loadingOverlay.style.display = &#039;none&#039;;
      }
    }
  };
}

// Usage
class UserProfile extends HTMLElement {
  async connectedCallback() {
    this.showLoading();

    const user = await fetch(&#039;/api/user&#039;).then(r =&gt; r.json());
    this.render(user);

    this.hideLoading();
  }

  render(user) {
    this.innerHTML = `&lt;h1&gt;${user.name}&lt;/h1&gt;`;
  }
}

// Apply decorator
const UserProfileWithLoading = withLoading(UserProfile);
customElements.define(&#039;user-profile&#039;, UserProfileWithLoading);</code></pre>
<h2>Component Composition</h2>
<p>Build complex UIs from simple, focused components.</p>
<h3>Container/Presentational Pattern</h3>
<p>Separate logic from presentation:</p>
<pre><code class="language-javascript">// Presentational - no logic, just rendering
class UserCard extends HTMLElement {
  set user(value) {
    this._user = value;
    this.render();
  }

  render() {
    if (!this._user) return;

    this.innerHTML = `
      &lt;div class=&quot;card&quot;&gt;
        &lt;img src=&quot;${this._user.avatar}&quot; alt=&quot;${this._user.name}&quot;&gt;
        &lt;h3&gt;${this._user.name}&lt;/h3&gt;
        &lt;p&gt;${this._user.email}&lt;/p&gt;
        &lt;button class=&quot;follow-btn&quot;&gt;Follow&lt;/button&gt;
      &lt;/div&gt;
    `;

    // Emit events, don&#039;t handle logic
    this.querySelector(&#039;.follow-btn&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.dispatchEvent(new CustomEvent(&#039;follow&#039;, {
        detail: { userId: this._user.id }
      }));
    });
  }
}

// Container - handles logic and data
class UserCardContainer extends HTMLElement {
  async connectedCallback() {
    const userId = this.getAttribute(&#039;user-id&#039;);

    // Fetch data
    this.user = await this.fetchUser(userId);

    // Create presentational component
    const card = document.createElement(&#039;user-card&#039;);
    card.user = this.user;

    // Handle events
    card.addEventListener(&#039;follow&#039;, (e) =&gt; {
      this.followUser(e.detail.userId);
    });

    this.appendChild(card);
  }

  async fetchUser(id) {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }

  async followUser(userId) {
    await fetch(`/api/users/${userId}/follow`, { method: &#039;POST&#039; });
    pan.publish(&#039;user.followed&#039;, { userId });
  }
}

customElements.define(&#039;user-card&#039;, UserCard);
customElements.define(&#039;user-card-container&#039;, UserCardContainer);</code></pre>
<h3>Render Props Pattern</h3>
<p>Pass rendering logic as a slot:</p>
<pre><code class="language-javascript">class DataProvider extends HTMLElement {
  async connectedCallback() {
    const url = this.getAttribute(&#039;url&#039;);

    // Render loading state
    this.innerHTML = &#039;&lt;slot name=&quot;loading&quot;&gt;Loading...&lt;/slot&gt;&#039;;

    try {
      const response = await fetch(url);
      const data = await response.json();

      // Render with data
      const renderSlot = this.querySelector(&#039;[slot=&quot;render&quot;]&#039;);
      if (renderSlot) {
        renderSlot.data = data;
        this.innerHTML = &#039;&#039;;
        this.appendChild(renderSlot);
      }
    } catch (error) {
      // Render error state
      this.innerHTML = `&lt;slot name=&quot;error&quot;&gt;Error: ${error.message}&lt;/slot&gt;`;
    }
  }
}

customElements.define(&#039;data-provider&#039;, DataProvider);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;data-provider url=&quot;/api/users&quot;&gt;
  &lt;div slot=&quot;loading&quot;&gt;
    &lt;spinner-component&gt;&lt;/spinner-component&gt;
  &lt;/div&gt;

  &lt;user-list slot=&quot;render&quot;&gt;&lt;/user-list&gt;

  &lt;div slot=&quot;error&quot;&gt;
    &lt;error-message&gt;&lt;/error-message&gt;
  &lt;/div&gt;
&lt;/data-provider&gt;</code></pre>
<h2>Slots and Content Projection</h2>
<p>Slots are powerful for flexible component composition.</p>
<h3>Named Slots</h3>
<pre><code class="language-javascript">class CardComponent extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .card {
          border: 1px solid #e2e8f0;
          border-radius: 8px;
          overflow: hidden;
        }
        .header {
          background: #f7fafc;
          padding: 16px;
          border-bottom: 1px solid #e2e8f0;
        }
        .body {
          padding: 16px;
        }
        .footer {
          background: #f7fafc;
          padding: 12px 16px;
          border-top: 1px solid #e2e8f0;
          display: flex;
          justify-content: flex-end;
          gap: 8px;
        }
      &lt;/style&gt;

      &lt;div class=&quot;card&quot;&gt;
        &lt;div class=&quot;header&quot;&gt;
          &lt;slot name=&quot;header&quot;&gt;Default Header&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;body&quot;&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;footer&quot;&gt;
          &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;card-component&#039;, CardComponent);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;card-component&gt;
  &lt;h2 slot=&quot;header&quot;&gt;User Profile&lt;/h2&gt;

  &lt;!-- Default slot --&gt;
  &lt;p&gt;User profile content goes here...&lt;/p&gt;

  &lt;div slot=&quot;footer&quot;&gt;
    &lt;button&gt;Save&lt;/button&gt;
    &lt;button&gt;Cancel&lt;/button&gt;
  &lt;/div&gt;
&lt;/card-component&gt;</code></pre>
<h3>Slot Change Detection</h3>
<p>React to slot content changes:</p>
<pre><code class="language-javascript">class DynamicList extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .count { font-weight: bold; color: #667eea; }
      &lt;/style&gt;
      &lt;div class=&quot;count&quot;&gt;&lt;/div&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;

    // Listen for slot changes
    const slot = this.shadowRoot.querySelector(&#039;slot&#039;);
    slot.addEventListener(&#039;slotchange&#039;, () =&gt; {
      this.updateCount();
    });

    this.updateCount();
  }

  updateCount() {
    const slot = this.shadowRoot.querySelector(&#039;slot&#039;);
    const elements = slot.assignedElements();

    const count = this.shadowRoot.querySelector(&#039;.count&#039;);
    count.textContent = `${elements.length} items`;
  }
}

customElements.define(&#039;dynamic-list&#039;, DynamicList);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;dynamic-list&gt;
  &lt;div&gt;Item 1&lt;/div&gt;
  &lt;div&gt;Item 2&lt;/div&gt;
  &lt;div&gt;Item 3&lt;/div&gt;
&lt;/dynamic-list&gt;

&lt;script&gt;
  const list = document.querySelector(&#039;dynamic-list&#039;);

  // Add item dynamically
  const newItem = document.createElement(&#039;div&#039;);
  newItem.textContent = &#039;Item 4&#039;;
  list.appendChild(newItem);
  // Count automatically updates!
&lt;/script&gt;</code></pre>
<h3>Conditional Slots</h3>
<p>Show/hide content based on slot presence:</p>
<pre><code class="language-javascript">class ConditionalCard extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    const hasHeader = this.querySelector(&#039;[slot=&quot;header&quot;]&#039;) !== null;
    const hasFooter = this.querySelector(&#039;[slot=&quot;footer&quot;]&#039;) !== null;

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .card { border: 1px solid #ddd; border-radius: 8px; }
        .header, .footer { background: #f5f5f5; padding: 16px; }
        .body { padding: 16px; }
        .hidden { display: none; }
      &lt;/style&gt;

      &lt;div class=&quot;card&quot;&gt;
        &lt;div class=&quot;header ${hasHeader ? &#039;&#039; : &#039;hidden&#039;}&quot;&gt;
          &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;body&quot;&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;footer ${hasFooter ? &#039;&#039; : &#039;hidden&#039;}&quot;&gt;
          &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;conditional-card&#039;, ConditionalCard);</code></pre>
<h2>Dynamic Component Loading</h2>
<p>Load components on demand for better performance.</p>
<h3>Lazy Loading</h3>
<pre><code class="language-javascript">class LazyLoader extends HTMLElement {
  async connectedCallback() {
    const component = this.getAttribute(&#039;component&#039;);
    const src = this.getAttribute(&#039;src&#039;);

    // Show placeholder
    this.innerHTML = &#039;&lt;div&gt;Loading component...&lt;/div&gt;&#039;;

    try {
      // Dynamically import component
      await import(src);

      // Wait for component to be defined
      await customElements.whenDefined(component);

      // Create and append component
      const element = document.createElement(component);

      // Copy attributes
      Array.from(this.attributes).forEach(attr =&gt; {
        if (attr.name !== &#039;component&#039; &amp;&amp; attr.name !== &#039;src&#039;) {
          element.setAttribute(attr.name, attr.value);
        }
      });

      this.innerHTML = &#039;&#039;;
      this.appendChild(element);
    } catch (error) {
      this.innerHTML = `&lt;div class=&quot;error&quot;&gt;Failed to load component: ${error.message}&lt;/div&gt;`;
    }
  }
}

customElements.define(&#039;lazy-loader&#039;, LazyLoader);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;!-- Component loads when added to DOM --&gt;
&lt;lazy-loader
  component=&quot;heavy-chart&quot;
  src=&quot;/components/heavy-chart.js&quot;
  data-url=&quot;/api/chart-data&quot;&gt;
&lt;/lazy-loader&gt;</code></pre>
<h3>Intersection Observer for Viewport Loading</h3>
<p>Load components when they enter the viewport:</p>
<pre><code class="language-javascript">class ViewportLoader extends HTMLElement {
  connectedCallback() {
    this.observer = new IntersectionObserver((entries) =&gt; {
      entries.forEach(entry =&gt; {
        if (entry.isIntersecting &amp;&amp; !this.loaded) {
          this.load();
        }
      });
    }, {
      rootMargin: &#039;50px&#039;  // Start loading 50px before visible
    });

    this.observer.observe(this);
  }

  disconnectedCallback() {
    this.observer?.disconnect();
  }

  async load() {
    this.loaded = true;
    const component = this.getAttribute(&#039;component&#039;);
    const src = this.getAttribute(&#039;src&#039;);

    await import(src);
    await customElements.whenDefined(component);

    const element = document.createElement(component);
    Array.from(this.attributes).forEach(attr =&gt; {
      if (![&#039;component&#039;, &#039;src&#039;].includes(attr.name)) {
        element.setAttribute(attr.name, attr.value);
      }
    });

    this.appendChild(element);
  }
}

customElements.define(&#039;viewport-loader&#039;, ViewportLoader);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;!-- Heavy image gallery - only loads when scrolled into view --&gt;
&lt;viewport-loader
  component=&quot;image-gallery&quot;
  src=&quot;/components/image-gallery.js&quot;
  album-id=&quot;123&quot;&gt;
&lt;/viewport-loader&gt;</code></pre>
<h2>Performance Optimization</h2>
<h3>Virtual Scrolling</h3>
<p>Render only visible items in long lists:</p>
<pre><code class="language-javascript">class VirtualList extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });

    this.items = [];
    this.itemHeight = 50;
    this.visibleCount = 20;
    this.scrollTop = 0;
  }

  set data(items) {
    this.items = items;
    this.render();
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          height: 100%;
          overflow-y: auto;
          position: relative;
        }
        .viewport {
          position: relative;
        }
        .item {
          position: absolute;
          left: 0;
          right: 0;
          height: ${this.itemHeight}px;
          display: flex;
          align-items: center;
          padding: 0 16px;
          border-bottom: 1px solid #eee;
        }
      &lt;/style&gt;
      &lt;div class=&quot;viewport&quot;&gt;&lt;/div&gt;
    `;

    this.viewport = this.shadowRoot.querySelector(&#039;.viewport&#039;);

    this.addEventListener(&#039;scroll&#039;, () =&gt; {
      this.scrollTop = this.scrollTop;
      this.renderVisibleItems();
    });
  }

  render() {
    if (!this.viewport) return;

    // Set total height
    const totalHeight = this.items.length * this.itemHeight;
    this.viewport.style.height = `${totalHeight}px`;

    this.renderVisibleItems();
  }

  renderVisibleItems() {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.min(
      startIndex + this.visibleCount,
      this.items.length
    );

    // Clear existing items
    this.viewport.innerHTML = &#039;&#039;;

    // Render only visible items
    for (let i = startIndex; i &lt; endIndex; i++) {
      const item = document.createElement(&#039;div&#039;);
      item.className = &#039;item&#039;;
      item.style.top = `${i * this.itemHeight}px`;
      item.textContent = this.items[i];

      this.viewport.appendChild(item);
    }
  }
}

customElements.define(&#039;virtual-list&#039;, VirtualList);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">const list = document.createElement(&#039;virtual-list&#039;);
list.data = Array.from({ length: 10000 }, (_, i) =&gt; `Item ${i + 1}`);
list.style.height = &#039;400px&#039;;
document.body.appendChild(list);</code></pre>
<h3>Memoization</h3>
<p>Cache expensive computations:</p>
<pre><code class="language-javascript">class MemoizedComponent extends HTMLElement {
  constructor() {
    super();
    this.cache = new Map();
  }

  memoize(fn, keyFn) {
    return (...args) =&gt; {
      const key = keyFn ? keyFn(...args) : JSON.stringify(args);

      if (this.cache.has(key)) {
        return this.cache.get(key);
      }

      const result = fn(...args);
      this.cache.set(key, result);

      return result;
    };
  }

  computeExpensiveValue = this.memoize(
    (data) =&gt; {
      // Expensive computation
      console.log(&#039;Computing...&#039;);
      return data.reduce((acc, val) =&gt; acc + val.price, 0);
    },
    (data) =&gt; data.map(d =&gt; d.id).join(&#039;,&#039;)
  );

  connectedCallback() {
    const data = [
      { id: 1, price: 100 },
      { id: 2, price: 200 }
    ];

    // First call - computes
    console.log(this.computeExpensiveValue(data));

    // Second call - cached
    console.log(this.computeExpensiveValue(data));
  }
}</code></pre>
<h3>Debouncing and Throttling</h3>
<p>Limit expensive operations:</p>
<pre><code class="language-javascript">// lib/performance.js
export function debounce(fn, delay) {
  let timeoutId;

  return function(...args) {
    clearTimeout(timeoutId);

    timeoutId = setTimeout(() =&gt; {
      fn.apply(this, args);
    }, delay);
  };
}

export function throttle(fn, limit) {
  let inThrottle;

  return function(...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;

      setTimeout(() =&gt; {
        inThrottle = false;
      }, limit);
    }
  };
}

// Usage
class SearchBox extends HTMLElement {
  constructor() {
    super();

    // Debounce search - wait for user to stop typing
    this.handleSearch = debounce(this.search.bind(this), 300);

    // Throttle scroll - limit updates
    this.handleScroll = throttle(this.onScroll.bind(this), 100);
  }

  connectedCallback() {
    this.innerHTML = &#039;&lt;input type=&quot;search&quot; placeholder=&quot;Search...&quot;&gt;&#039;;

    this.querySelector(&#039;input&#039;).addEventListener(&#039;input&#039;, (e) =&gt; {
      this.handleSearch(e.target.value);
    });

    window.addEventListener(&#039;scroll&#039;, this.handleScroll);
  }

  search(query) {
    console.log(&#039;Searching for:&#039;, query);
    // Perform search
  }

  onScroll() {
    console.log(&#039;Scrolled&#039;);
    // Update UI based on scroll
  }
}</code></pre>
<h2>Summary</h2>
<p>This chapter explored advanced component patterns:</p>
<ul><li><strong>Compound Components</strong>: Components that work together as a cohesive unit</li>
<li><strong>Higher-Order Components</strong>: Mixins and decorators for code reuse</li>
<li><strong>Component Composition</strong>: Container/presentational pattern and render props</li>
<li><strong>Slots</strong>: Named slots, slot change detection, and conditional rendering</li>
<li><strong>Dynamic Loading</strong>: Lazy loading and viewport-based loading</li>
<li><strong>Performance</strong>: Virtual scrolling, memoization, debouncing, and throttling</li>
</ul>
These patterns enable you to build sophisticated, performant applications while keeping code maintainable and testable.
<hr>
<h2>Best Practices</h2>
<li><strong>Favor composition over inheritance</strong></li>
   - Build complex components from simple ones
   - Use slots for flexibility
   - Keep components focused
<li><strong>Use mixins for cross-cutting concerns</strong></li>
   - Observable behavior
   - Resize handling
   - Loading states
<li><strong>Separate logic from presentation</strong></li>
   - Container components handle data
   - Presentational components handle UI
   - Easier to test and reuse
<li><strong>Lazy load heavy components</strong></li>
   - Reduce initial bundle size
   - Load on demand or when visible
   - Show loading states
<li><strong>Optimize expensive operations</strong></li>
   - Memoize pure functions
   - Debounce user input
   - Throttle scroll/resize handlers
   - Use virtual scrolling for long lists
<li><strong>Keep performance in mind</strong></li>
   - Profile before optimizing
   - Measure impact of changes
   - Don't over-optimize prematurely
<p>\pagebreak</p>
<h1>Chapter 8: Business Logic Patterns</h1>
<p>In the previous chapters, we've learned how to build components, communicate via the PAN bus, and manage state. But when building real-world applications, you'll inevitably need to inject your own custom business logic: validation rules, pricing calculations, access control, analytics tracking, and countless other domain-specific concerns.</p>
<p>A common question developers ask when adopting LARC is: <em>"Where do I put my business logic?"</em> This chapter explores the architectural patterns for integrating business logic into LARC applications, helping you make informed decisions about code organization and separation of concerns.</p>
<h2>The Philosophy: Separation of Concerns</h2>
<p>LARC's architecture naturally encourages a clean separation between:</p>
<ul><li><strong>Components</strong>: UI and interaction concerns</li>
<li><strong>PAN Bus</strong>: Communication layer</li>
<li><strong>Business Logic</strong>: Domain rules and workflows</li>
</ul>
This separation isn't just academic—it makes your code:
<ul><li><strong>Testable</strong>: Logic can be tested independently of UI</li>
<li><strong>Maintainable</strong>: Changes to business rules don't require touching components</li>
<li><strong>Reusable</strong>: Logic can be shared across multiple components</li>
<li><strong>Flexible</strong>: Easy to modify workflows without refactoring components</li>
</ul>
Let's explore the patterns that make this possible.
<h2>Pattern 1: PAN Bus Listeners (Recommended)</h2>
<p>The most common and recommended approach is to create separate modules that listen to PAN bus events and implement your business logic. This pattern treats business logic as a <strong>first-class concern</strong>, separate from both UI components and state management.</p>
<h3>When to Use</h3>
<p>Use PAN bus listeners when you need to:</p>
<ul><li>Coordinate behavior across multiple components</li>
<li>Implement cross-cutting concerns (analytics, logging, validation)</li>
<li>Add business rules that aren't tied to a specific component</li>
<li>Keep components generic and reusable</li>
</ul>
<h3>Basic Implementation</h3>
<p>Let's build an e-commerce application where we need to enforce business rules around cart operations:</p>
<pre><code class="language-javascript">// business-logic/cart-rules.js
import { pan } from &#039;@larcjs/core&#039;;

class CartBusinessRules {
  constructor() {
    this.maxItemsPerOrder = 50;
    this.maxQuantityPerItem = 10;
  }

  init() {
    // Subscribe to cart events
    pan.subscribe(&#039;cart.item.add&#039;, this.handleItemAdd.bind(this));
    pan.subscribe(&#039;cart.item.update&#039;, this.handleItemUpdate.bind(this));
    pan.subscribe(&#039;cart.checkout.start&#039;, this.handleCheckout.bind(this));
  }

  async handleItemAdd(data) {
    console.log(&#039;Business rule: Validating item add&#039;, data);

    // Check current cart state
    const currentCart = await pan.request(&#039;cart.get&#039;);

    // Business Rule 1: Maximum items per order
    if (currentCart.items.length &gt;= this.maxItemsPerOrder) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;MAX_ITEMS_EXCEEDED&#039;,
        message: `Cannot add more than ${this.maxItemsPerOrder} items to cart`
      });
      return;
    }

    // Business Rule 2: Check inventory
    const available = await this.checkInventory(data.product.id);
    if (!available || available &lt; data.quantity) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;INSUFFICIENT_INVENTORY&#039;,
        message: &#039;This item is currently out of stock&#039;,
        product: data.product
      });
      return;
    }

    // Business Rule 3: Apply pricing
    const pricing = await this.calculatePrice(data.product, data.quantity);

    // All validations passed - allow the add and publish enriched data
    pan.publish(&#039;cart.item.validated&#039;, {
      ...data,
      pricing,
      timestamp: Date.now()
    });
  }

  async handleItemUpdate(data) {
    // Business Rule: Quantity limits
    if (data.quantity &gt; this.maxQuantityPerItem) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;MAX_QUANTITY_EXCEEDED&#039;,
        message: `Maximum ${this.maxQuantityPerItem} per item`
      });
      return;
    }

    // Check inventory for new quantity
    const available = await this.checkInventory(data.productId);
    if (available &lt; data.quantity) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;INSUFFICIENT_INVENTORY&#039;,
        message: `Only ${available} available`,
        available
      });
      return;
    }

    pan.publish(&#039;cart.item.update.validated&#039;, data);
  }

  async handleCheckout(data) {
    // Business Rule: Minimum order value
    const cart = await pan.request(&#039;cart.get&#039;);
    const total = cart.items.reduce((sum, item) =&gt; sum + item.total, 0);

    if (total &lt; 10) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;MINIMUM_ORDER_NOT_MET&#039;,
        message: &#039;Minimum order value is $10&#039;,
        current: total,
        required: 10
      });
      return;
    }

    // Business Rule: User must be logged in
    const user = await pan.request(&#039;auth.user.get&#039;);
    if (!user) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;AUTH_REQUIRED&#039;,
        message: &#039;Please log in to continue&#039;
      });
      return;
    }

    pan.publish(&#039;checkout.validated&#039;, { cart, user });
  }

  async checkInventory(productId) {
    // In real app, this would call your backend
    const response = await fetch(`/api/inventory/${productId}`);
    const data = await response.json();
    return data.available;
  }

  async calculatePrice(product, quantity) {
    // Apply business logic: bulk discounts, promotions, etc.
    let unitPrice = product.price;

    // Bulk discount: 10% off for 5+ items
    if (quantity &gt;= 5) {
      unitPrice = unitPrice * 0.9;
    }

    // TODO: Check for active promotions
    // TODO: Apply user-specific pricing

    return {
      unitPrice,
      quantity,
      subtotal: unitPrice * quantity,
      discount: quantity &gt;= 5 ? (product.price - unitPrice) * quantity : 0
    };
  }
}

// Initialize and export
const cartRules = new CartBusinessRules();
export default cartRules;</code></pre>
<p>Now in your main application file:</p>
<pre><code class="language-javascript">// app.js
import { pan } from &#039;@larcjs/core&#039;;
import cartRules from &#039;./business-logic/cart-rules.js&#039;;

// Initialize business logic
cartRules.init();

// Your components just publish events - the business logic handles the rest
// No business logic in components themselves!</code></pre>
<p>Your components remain simple and focused on UI:</p>
<pre><code class="language-javascript">// components/product-card.js
class ProductCard extends HTMLElement {
  // ... component setup ...

  handleAddToCart() {
    // Just publish the event - business logic will validate
    pan.publish(&#039;cart.item.add&#039;, {
      product: this.product,
      quantity: this.quantity
    });

    // Show optimistic UI
    this.showAddingState();
  }

  connectedCallback() {
    super.connectedCallback();

    // Listen for validation results
    this.unsubscribers = [
      pan.subscribe(&#039;cart.item.validated&#039;, (data) =&gt; {
        if (data.product.id === this.product.id) {
          this.showSuccess();
        }
      }),

      pan.subscribe(&#039;cart.error&#039;, (error) =&gt; {
        this.showError(error.message);
      })
    ];
  }
}</code></pre>
<h3>Advantages</h3>
<p>This pattern provides several key benefits:</p>
<li><strong>Separation of Concerns</strong>: Components handle UI, business logic modules handle rules</li>
<li><strong>Easy Testing</strong>: Test business logic without rendering components</li>
<li><strong>Centralized Rules</strong>: All cart rules in one place, easy to modify</li>
<li><strong>Reusable</strong>: Multiple components can trigger the same logic</li>
<li><strong>Flexible</strong>: Easy to add, remove, or modify rules</li>
<h3>Advanced: Composable Business Logic</h3>
<p>For larger applications, you can compose multiple business logic modules:</p>
<pre><code class="language-javascript">// business-logic/index.js
import { pan } from &#039;@larcjs/core&#039;;
import cartRules from &#039;./cart-rules.js&#039;;
import pricingRules from &#039;./pricing-rules.js&#039;;
import inventoryRules from &#039;./inventory-rules.js&#039;;
import analyticsRules from &#039;./analytics-rules.js&#039;;

export function initBusinessLogic() {
  console.log(&#039;Initializing business logic...&#039;);

  // Initialize all business logic modules
  cartRules.init();
  pricingRules.init();
  inventoryRules.init();
  analyticsRules.init();

  console.log(&#039;Business logic ready&#039;);
}</code></pre>
<pre><code class="language-javascript">// app.js
import { initBusinessLogic } from &#039;./business-logic/index.js&#039;;

// Single call to initialize all business logic
initBusinessLogic();</code></pre>
<h2>Pattern 2: Extending Components</h2>
<p>Sometimes you need to add business logic directly to a component, especially when:</p>
<ul><li>The logic is specific to one component type</li>
<li>You need to override component behavior</li>
<li>You're creating specialized versions of generic components</li>
</ul>
<h3>When to Use</h3>
<p>Use component extension when:</p>
<ul><li>Logic is tightly coupled to component rendering</li>
<li>You need access to component internals (Shadow DOM, private methods)</li>
<li>Creating specialized variants of base components</li>
<li>Logic doesn't need to be shared across different component types</li>
</ul>
<h3>Implementation</h3>
<p>Let's extend a generic product card with business-specific behavior:</p>
<pre><code class="language-javascript">// components/base/product-card.js
export class ProductCard extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        /* Base styles */
      &lt;/style&gt;
      &lt;div class=&quot;card&quot;&gt;
        &lt;img src=&quot;${this.product.image}&quot; alt=&quot;${this.product.name}&quot;&gt;
        &lt;h3&gt;${this.product.name}&lt;/h3&gt;
        &lt;p class=&quot;price&quot;&gt;${this.formatPrice(this.product.price)}&lt;/p&gt;
        &lt;button class=&quot;add-to-cart&quot;&gt;Add to Cart&lt;/button&gt;
      &lt;/div&gt;
    `;

    this.shadowRoot.querySelector(&#039;.add-to-cart&#039;)
      .addEventListener(&#039;click&#039;, () =&gt; this.handleAddToCart());
  }

  handleAddToCart() {
    pan.publish(&#039;cart.item.add&#039;, {
      product: this.product,
      quantity: 1
    });
  }

  formatPrice(price) {
    return `$${price.toFixed(2)}`;
  }

  get product() {
    return JSON.parse(this.getAttribute(&#039;product&#039;));
  }
}

customElements.define(&#039;product-card&#039;, ProductCard);</code></pre>
<p>Now extend it with business-specific logic:</p>
<pre><code class="language-javascript">// components/premium-product-card.js
import { ProductCard } from &#039;./base/product-card.js&#039;;

export class PremiumProductCard extends ProductCard {
  connectedCallback() {
    super.connectedCallback();

    // Add business-specific subscriptions
    this._unsubscribers = [
      pan.subscribe(&#039;pricing.update&#039;, this.handlePriceUpdate.bind(this)),
      pan.subscribe(&#039;user.tier.changed&#039;, this.handleTierChange.bind(this))
    ];

    // Initialize premium features
    this.loadMemberPricing();
  }

  async loadMemberPricing() {
    const user = await pan.request(&#039;auth.user.get&#039;);
    if (user?.tier === &#039;premium&#039;) {
      this.applyPremiumDiscount();
    }
  }

  applyPremiumDiscount() {
    // Business Rule: 15% discount for premium members
    const discount = 0.15;
    const originalPrice = this.product.price;
    const discountedPrice = originalPrice * (1 - discount);

    this.product.price = discountedPrice;
    this.product.originalPrice = originalPrice;

    this.render(); // Re-render with new price
  }

  render() {
    // Call parent render
    super.render();

    // Add premium badge if applicable
    if (this.product.originalPrice) {
      this.addPremiumBadge();
    }
  }

  addPremiumBadge() {
    const badge = document.createElement(&#039;div&#039;);
    badge.className = &#039;premium-badge&#039;;
    badge.innerHTML = `
      &lt;style&gt;
        .premium-badge {
          position: absolute;
          top: 10px;
          right: 10px;
          background: gold;
          color: black;
          padding: 5px 10px;
          border-radius: 3px;
          font-weight: bold;
        }
        .original-price {
          text-decoration: line-through;
          color: #999;
          font-size: 0.9em;
        }
      &lt;/style&gt;
      &lt;span&gt;Premium Member&lt;/span&gt;
      &lt;div class=&quot;original-price&quot;&gt;
        ${this.formatPrice(this.product.originalPrice)}
      &lt;/div&gt;
    `;

    this.shadowRoot.querySelector(&#039;.card&#039;).prepend(badge);
  }

  async handleAddToCart() {
    // Business validation before adding
    const canAddPremiumItem = await this.validatePremiumAccess();

    if (!canAddPremiumItem) {
      pan.publish(&#039;app.error&#039;, {
        message: &#039;Premium membership required for this product&#039;
      });
      return;
    }

    // Track premium conversions
    this.trackPremiumConversion();

    // Call parent behavior
    super.handleAddToCart();
  }

  async validatePremiumAccess() {
    if (!this.product.premiumOnly) return true;

    const user = await pan.request(&#039;auth.user.get&#039;);
    return user?.tier === &#039;premium&#039;;
  }

  trackPremiumConversion() {
    pan.publish(&#039;analytics.track&#039;, {
      event: &#039;premium_product_add_to_cart&#039;,
      product: this.product.id,
      price: this.product.price,
      discount: this.product.originalPrice - this.product.price
    });
  }

  handlePriceUpdate(data) {
    if (data.productId === this.product.id) {
      this.product.price = data.newPrice;
      this.render();
    }
  }

  handleTierChange(data) {
    // User tier changed - recalculate pricing
    this.loadMemberPricing();
  }

  disconnectedCallback() {
    // Clean up subscriptions
    this._unsubscribers.forEach(unsub =&gt; unsub());
    super.disconnectedCallback?.();
  }
}

customElements.define(&#039;premium-product-card&#039;, PremiumProductCard);</code></pre>
<h3>When This Makes Sense</h3>
<p>Component extension works well when:</p>
<li><strong>The logic changes how the component renders or behaves</strong></li>
<li><strong>You need multiple variants of a base component</strong> (premium, free, guest, etc.)</li>
<li><strong>Business logic is closely tied to component lifecycle</strong></li>
<p>However, be cautious: overuse of extension can lead to:</p>
<ul><li>Tight coupling between business logic and UI</li>
<li>Harder to test business rules independently</li>
<li>Duplication if multiple components need the same logic</li>
</ul>
<h2>Pattern 3: Wrapper Components</h2>
<p>Wrapper components let you add behavior around existing components without modifying them. This is useful when you want to:</p>
<ul><li>Add behavior to third-party components</li>
<li>Keep base components pristine</li>
<li>Compose behaviors dynamically</li>
</ul>
<h3>Implementation</h3>
<pre><code class="language-javascript">// components/business-wrapper.js
class BusinessWrapper extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    // Intercept events from slotted content
    this.addEventListener(&#039;add-to-cart&#039;, this.handleBusinessLogic.bind(this));

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
        }
        .validation-message {
          color: red;
          padding: 10px;
          background: #fee;
          border-radius: 4px;
          margin-bottom: 10px;
        }
        .validation-message.hidden {
          display: none;
        }
      &lt;/style&gt;
      &lt;div class=&quot;validation-message hidden&quot;&gt;&lt;/div&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;
  }

  async handleBusinessLogic(e) {
    // Stop the event from propagating immediately
    e.stopPropagation();

    // Apply business validation
    const validation = await this.validateBusinessRules(e.detail);

    if (!validation.valid) {
      this.showError(validation.message);
      return;
    }

    // Validation passed - let the event continue
    pan.publish(&#039;cart.item.add&#039;, e.detail);
  }

  async validateBusinessRules(data) {
    // Check user eligibility
    const user = await pan.request(&#039;auth.user.get&#039;);
    if (!user) {
      return {
        valid: false,
        message: &#039;Please log in to add items to cart&#039;
      };
    }

    // Check age restriction
    if (data.product.ageRestricted &amp;&amp; user.age &lt; 21) {
      return {
        valid: false,
        message: &#039;This product requires age verification (21+)&#039;
      };
    }

    // Check geographic restriction
    if (data.product.geoRestricted &amp;&amp; !this.isAllowedRegion(user.region)) {
      return {
        valid: false,
        message: &#039;This product is not available in your region&#039;
      };
    }

    return { valid: true };
  }

  isAllowedRegion(region) {
    // Business logic for regional restrictions
    const allowedRegions = [&#039;US&#039;, &#039;CA&#039;, &#039;UK&#039;];
    return allowedRegions.includes(region);
  }

  showError(message) {
    const errorEl = this.shadowRoot.querySelector(&#039;.validation-message&#039;);
    errorEl.textContent = message;
    errorEl.classList.remove(&#039;hidden&#039;);

    setTimeout(() =&gt; {
      errorEl.classList.add(&#039;hidden&#039;);
    }, 5000);
  }
}

customElements.define(&#039;business-wrapper&#039;, BusinessWrapper);</code></pre>
<p>Usage:</p>
<pre><code class="language-html">&lt;!-- Wrap any component with business logic --&gt;
&lt;business-wrapper&gt;
  &lt;product-card product-id=&quot;123&quot;&gt;&lt;/product-card&gt;
&lt;/business-wrapper&gt;

&lt;business-wrapper&gt;
  &lt;quick-buy-button product-id=&quot;456&quot;&gt;&lt;/quick-buy-button&gt;
&lt;/business-wrapper&gt;</code></pre>
<p>The wrapper intercepts events and applies business logic <strong>without modifying</strong> the wrapped components.</p>
<h2>Pattern 4: Behavior Mixins</h2>
<p>Mixins let you share behavior across multiple component types. This is useful for cross-cutting concerns like analytics, logging, or validation.</p>
<h3>Implementation</h3>
<pre><code class="language-javascript">// mixins/analytics-mixin.js
export const AnalyticsMixin = (BaseClass) =&gt; class extends BaseClass {
  track(event, data = {}) {
    pan.publish(&#039;analytics.track&#039;, {
      event,
      data,
      component: this.tagName.toLowerCase(),
      timestamp: Date.now(),
      ...this.getAnalyticsContext()
    });
  }

  trackInteraction(element, action) {
    this.track(`${element}.${action}`, {
      element,
      action
    });
  }

  getAnalyticsContext() {
    // Add common context to all analytics events
    return {
      page: window.location.pathname,
      referrer: document.referrer
    };
  }

  connectedCallback() {
    super.connectedCallback?.();
    this.track(&#039;component.mounted&#039;, { id: this.id });
  }

  disconnectedCallback() {
    this.track(&#039;component.unmounted&#039;, { id: this.id });
    super.disconnectedCallback?.();
  }
};</code></pre>
<pre><code class="language-javascript">// mixins/validation-mixin.js
export const ValidationMixin = (BaseClass) =&gt; class extends BaseClass {
  async validate(data, rules) {
    const errors = [];

    for (const [field, rule] of Object.entries(rules)) {
      const value = data[field];

      if (rule.required &amp;&amp; !value) {
        errors.push(`${field} is required`);
      }

      if (rule.min &amp;&amp; value &lt; rule.min) {
        errors.push(`${field} must be at least ${rule.min}`);
      }

      if (rule.max &amp;&amp; value &gt; rule.max) {
        errors.push(`${field} must be at most ${rule.max}`);
      }

      if (rule.pattern &amp;&amp; !rule.pattern.test(value)) {
        errors.push(`${field} is invalid`);
      }

      if (rule.custom) {
        const customError = await rule.custom(value, data);
        if (customError) errors.push(customError);
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  showValidationErrors(errors) {
    pan.publish(&#039;validation.errors&#039;, {
      component: this.tagName.toLowerCase(),
      errors
    });
  }
};</code></pre>
<p>Use mixins to compose behavior:</p>
<pre><code class="language-javascript">import { AnalyticsMixin } from &#039;./mixins/analytics-mixin.js&#039;;
import { ValidationMixin } from &#039;./mixins/validation-mixin.js&#039;;

class CheckoutForm extends ValidationMixin(AnalyticsMixin(HTMLElement)) {
  async handleSubmit() {
    // Use validation from mixin
    const validation = await this.validate(this.formData, {
      email: {
        required: true,
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      },
      cardNumber: {
        required: true,
        custom: async (value) =&gt; {
          const valid = await this.validateCard(value);
          return valid ? null : &#039;Invalid card number&#039;;
        }
      }
    });

    if (!validation.valid) {
      this.showValidationErrors(validation.errors);
      return;
    }

    // Use analytics from mixin
    this.track(&#039;checkout.submit&#039;, {
      amount: this.total,
      items: this.items.length
    });

    // Process checkout
    this.processOrder();
  }
}</code></pre>
<h2>Pattern 5: Service Layer</h2>
<p>For complex business logic, create a dedicated service layer that components and PAN listeners can both use:</p>
<pre><code class="language-javascript">// services/pricing-service.js
class PricingService {
  async calculatePrice(product, quantity, user) {
    let price = product.basePrice;

    // Business Rule: Volume discounts
    if (quantity &gt;= 10) price *= 0.85;
    else if (quantity &gt;= 5) price *= 0.90;

    // Business Rule: Member discounts
    if (user?.tier === &#039;premium&#039;) {
      price *= 0.85;
    } else if (user?.tier === &#039;gold&#039;) {
      price *= 0.90;
    }

    // Business Rule: Active promotions
    const promotions = await this.getActivePromotions(product.id);
    for (const promo of promotions) {
      price = this.applyPromotion(price, promo);
    }

    return {
      unitPrice: price,
      quantity,
      subtotal: price * quantity,
      savings: (product.basePrice - price) * quantity
    };
  }

  async getActivePromotions(productId) {
    const response = await fetch(`/api/promotions?product=${productId}`);
    return response.json();
  }

  applyPromotion(price, promotion) {
    if (promotion.type === &#039;percentage&#039;) {
      return price * (1 - promotion.value / 100);
    } else if (promotion.type === &#039;fixed&#039;) {
      return Math.max(0, price - promotion.value);
    }
    return price;
  }

  async getTax(subtotal, region) {
    const taxRates = {
      &#039;CA&#039;: 0.0725,
      &#039;NY&#039;: 0.08,
      &#039;TX&#039;: 0.0625
    };

    return subtotal * (taxRates[region] || 0);
  }
}

export default new PricingService();</code></pre>
<p>Use the service from both components and PAN listeners:</p>
<pre><code class="language-javascript">// In a component
import pricingService from &#039;./services/pricing-service.js&#039;;

class ProductCard extends HTMLElement {
  async updatePrice() {
    const user = await pan.request(&#039;auth.user.get&#039;);
    const pricing = await pricingService.calculatePrice(
      this.product,
      this.quantity,
      user
    );

    this.displayPrice(pricing);
  }
}</code></pre>
<pre><code class="language-javascript">// In business logic
import pricingService from &#039;./services/pricing-service.js&#039;;

class CartBusinessLogic {
  init() {
    pan.subscribe(&#039;cart.item.add&#039;, async (data) =&gt; {
      const user = await pan.request(&#039;auth.user.get&#039;);
      const pricing = await pricingService.calculatePrice(
        data.product,
        data.quantity,
        user
      );

      pan.publish(&#039;cart.item.priced&#039;, { ...data, pricing });
    });
  }
}</code></pre>
<h2>Decision Matrix</h2>
<p>Here's how to choose the right pattern:</p>
<p>| Scenario | Recommended Pattern | Why |
|----------|-------------------|-----|
| Cross-component coordination | PAN Bus Listeners | Decoupled, flexible |
| Analytics/logging | Mixins | Reusable across all components |
| Validation before actions | PAN Bus Listeners | Centralized rules |
| Component-specific UI logic | Extend Component | Access to internals |
| Add behavior to third-party components | Wrapper | Non-invasive |
| Complex business calculations | Service Layer | Testable, reusable |
| Component variants (premium, free) | Extend Component | Clear inheritance |
| Feature flags / A-B testing | Wrapper or PAN Listeners | Easy to toggle |</p>
<h2>Real-World Example: E-Commerce Checkout</h2>
<p>Let's see how these patterns work together in a complete checkout flow:</p>
<pre><code class="language-javascript">// services/checkout-service.js
class CheckoutService {
  async processOrder(cart, paymentInfo, shippingInfo) {
    // Complex business logic
    const pricing = await this.calculateFinalPricing(cart);
    const shipping = await this.calculateShipping(cart, shippingInfo);
    const tax = await this.calculateTax(pricing.subtotal, shippingInfo.state);

    return {
      items: cart.items,
      pricing,
      shipping,
      tax,
      total: pricing.subtotal + shipping.cost + tax
    };
  }

  async calculateFinalPricing(cart) {
    // Apply all discounts, coupons, etc.
    let subtotal = 0;
    let savings = 0;

    for (const item of cart.items) {
      const itemPricing = await pricingService.calculatePrice(
        item.product,
        item.quantity,
        cart.user
      );
      subtotal += itemPricing.subtotal;
      savings += itemPricing.savings;
    }

    return { subtotal, savings };
  }

  async calculateShipping(cart, shippingInfo) {
    // Shipping business rules
    if (cart.total &gt;= 50) {
      return { method: &#039;standard&#039;, cost: 0, freeShipping: true };
    }

    const weight = cart.items.reduce((sum, item) =&gt; sum + item.weight, 0);
    const zone = this.getShippingZone(shippingInfo.state);

    return {
      method: &#039;standard&#039;,
      cost: this.calculateShippingCost(weight, zone),
      freeShipping: false
    };
  }

  calculateShippingCost(weight, zone) {
    const baseRate = { 1: 5, 2: 7, 3: 10 };
    return baseRate[zone] + (weight &gt; 5 ? (weight - 5) * 0.5 : 0);
  }

  getShippingZone(state) {
    const zones = {
      1: [&#039;CA&#039;, &#039;OR&#039;, &#039;WA&#039;],
      2: [&#039;NV&#039;, &#039;AZ&#039;, &#039;UT&#039;, &#039;ID&#039;],
      3: [] // All other states
    };

    for (const [zone, states] of Object.entries(zones)) {
      if (states.includes(state)) return parseInt(zone);
    }
    return 3;
  }

  async calculateTax(subtotal, state) {
    return pricingService.getTax(subtotal, state);
  }
}

export default new CheckoutService();</code></pre>
<pre><code class="language-javascript">// business-logic/checkout-rules.js
import checkoutService from &#039;../services/checkout-service.js&#039;;

class CheckoutBusinessRules {
  init() {
    pan.subscribe(&#039;checkout.start&#039;, this.handleCheckoutStart.bind(this));
    pan.subscribe(&#039;checkout.submit&#039;, this.handleCheckoutSubmit.bind(this));
  }

  async handleCheckoutStart(data) {
    // Business validations
    const cart = await pan.request(&#039;cart.get&#039;);
    const user = await pan.request(&#039;auth.user.get&#039;);

    // Validation 1: Cart not empty
    if (!cart.items.length) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;EMPTY_CART&#039;,
        message: &#039;Your cart is empty&#039;
      });
      return;
    }

    // Validation 2: User logged in
    if (!user) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;AUTH_REQUIRED&#039;,
        message: &#039;Please log in to continue&#039;
      });
      return;
    }

    // Validation 3: Inventory check
    for (const item of cart.items) {
      const available = await this.checkInventory(item.product.id);
      if (available &lt; item.quantity) {
        pan.publish(&#039;checkout.error&#039;, {
          code: &#039;INSUFFICIENT_INVENTORY&#039;,
          message: `Only ${available} of &quot;${item.product.name}&quot; available`,
          item
        });
        return;
      }
    }

    // All validations passed
    pan.publish(&#039;checkout.validated&#039;, { cart, user });
  }

  async handleCheckoutSubmit(data) {
    try {
      // Process order through service
      const order = await checkoutService.processOrder(
        data.cart,
        data.paymentInfo,
        data.shippingInfo
      );

      // Submit to backend
      const response = await fetch(&#039;/api/orders&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify(order)
      });

      if (!response.ok) {
        throw new Error(&#039;Order submission failed&#039;);
      }

      const result = await response.json();

      // Success
      pan.publish(&#039;checkout.success&#039;, {
        orderId: result.orderId,
        order: result
      });

      // Clear cart
      pan.publish(&#039;cart.clear&#039;);

    } catch (error) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;SUBMISSION_FAILED&#039;,
        message: &#039;Unable to process order. Please try again.&#039;,
        error
      });
    }
  }

  async checkInventory(productId) {
    const response = await fetch(`/api/inventory/${productId}`);
    const data = await response.json();
    return data.available;
  }
}

export default new CheckoutBusinessRules();</code></pre>
<p>The checkout component stays simple:</p>
<pre><code class="language-javascript">// components/checkout-form.js
class CheckoutForm extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });
    this.render();
    this.attachEventListeners();
    this.subscribeToEvents();
  }

  subscribeToEvents() {
    this._unsubscribers = [
      pan.subscribe(&#039;checkout.validated&#039;, () =&gt; {
        this.showCheckoutForm();
      }),

      pan.subscribe(&#039;checkout.error&#039;, (error) =&gt; {
        this.showError(error.message);
      }),

      pan.subscribe(&#039;checkout.success&#039;, (data) =&gt; {
        this.showSuccess(data.orderId);
      })
    ];
  }

  handleSubmit(e) {
    e.preventDefault();

    // Just collect data and publish - business logic handles the rest
    pan.publish(&#039;checkout.submit&#039;, {
      cart: this.cart,
      paymentInfo: this.getPaymentInfo(),
      shippingInfo: this.getShippingInfo()
    });

    this.showProcessing();
  }

  // UI methods only - no business logic
  showCheckoutForm() { /* ... */ }
  showError(message) { /* ... */ }
  showSuccess(orderId) { /* ... */ }
  showProcessing() { /* ... */ }
}</code></pre>
<h2>Testing Business Logic</h2>
<p>One of the biggest advantages of separating business logic is testability. Here's how to test each pattern:</p>
<h3>Testing PAN Bus Listeners</h3>
<pre><code class="language-javascript">// __tests__/cart-rules.test.js
import { describe, it, expect, beforeEach, vi } from &#039;vitest&#039;;
import { pan } from &#039;@larcjs/core&#039;;
import cartRules from &#039;../business-logic/cart-rules.js&#039;;

describe(&#039;Cart Business Rules&#039;, () =&gt; {
  beforeEach(() =&gt; {
    // Reset PAN bus between tests
    pan.clear();
    cartRules.init();
  });

  it(&#039;should reject adding more than max items&#039;, async () =&gt; {
    // Mock cart with max items
    pan.respond(&#039;cart.get&#039;, () =&gt; ({
      items: new Array(50).fill({})
    }));

    const errorHandler = vi.fn();
    pan.subscribe(&#039;cart.error&#039;, errorHandler);

    // Try to add another item
    await pan.publish(&#039;cart.item.add&#039;, {
      product: { id: 1, name: &#039;Test&#039; },
      quantity: 1
    });

    expect(errorHandler).toHaveBeenCalledWith({
      code: &#039;MAX_ITEMS_EXCEEDED&#039;,
      message: expect.stringContaining(&#039;50 items&#039;)
    });
  });

  it(&#039;should apply bulk discount for 5+ items&#039;, async () =&gt; {
    const validated = vi.fn();
    pan.subscribe(&#039;cart.item.validated&#039;, validated);

    await pan.publish(&#039;cart.item.add&#039;, {
      product: { id: 1, name: &#039;Test&#039;, price: 100 },
      quantity: 5
    });

    expect(validated).toHaveBeenCalledWith(
      expect.objectContaining({
        pricing: expect.objectContaining({
          unitPrice: 90, // 10% discount
          discount: 50
        })
      })
    );
  });
});</code></pre>
<h3>Testing Services</h3>
<pre><code class="language-javascript">// __tests__/pricing-service.test.js
import { describe, it, expect } from &#039;vitest&#039;;
import pricingService from &#039;../services/pricing-service.js&#039;;

describe(&#039;Pricing Service&#039;, () =&gt; {
  it(&#039;should apply volume discount&#039;, async () =&gt; {
    const product = { basePrice: 100 };
    const pricing = await pricingService.calculatePrice(product, 10, null);

    expect(pricing.unitPrice).toBe(85); // 15% off for 10+
    expect(pricing.subtotal).toBe(850);
  });

  it(&#039;should stack member and volume discounts&#039;, async () =&gt; {
    const product = { basePrice: 100 };
    const user = { tier: &#039;premium&#039; };

    const pricing = await pricingService.calculatePrice(product, 10, user);

    // 15% volume + 15% premium = 72.25
    expect(pricing.unitPrice).toBe(72.25);
  });
});</code></pre>
<h2>Best Practices</h2>
<h3>1. Keep Components Dumb</h3>
<p>Components should focus on UI and user interaction. They publish events but don't implement business rules.</p>
<strong>Good:</strong>
<pre><code class="language-javascript">handleAddToCart() {
  pan.publish(&#039;cart.item.add&#039;, { product: this.product });
}</code></pre>
<strong>Bad:</strong>
<pre><code class="language-javascript">async handleAddToCart() {
  // Business logic in component - hard to test and reuse
  const inventory = await fetch(&#039;/api/inventory&#039;);
  if (inventory &lt; this.quantity) {
    alert(&#039;Out of stock&#039;);
    return;
  }

  const user = await fetch(&#039;/api/user&#039;);
  if (user.age &lt; 21 &amp;&amp; this.product.ageRestricted) {
    alert(&#039;Age restricted&#039;);
    return;
  }

  // ... more business logic
}</code></pre>
<h3>2. Use Services for Complex Logic</h3>
<p>If business logic involves multiple steps, calculations, or external APIs, put it in a service:</p>
<pre><code class="language-javascript">// Good: Service handles complexity
const pricing = await pricingService.calculatePrice(product, quantity, user);

// Bad: Business logic scattered across components and PAN listeners
const basePrice = product.price;
const volumeDiscount = quantity &gt;= 10 ? 0.15 : 0;
const memberDiscount = user?.tier === &#039;premium&#039; ? 0.15 : 0;
// ... etc</code></pre>
<h3>3. Make Business Logic Observable</h3>
<p>Use PAN bus to make business logic transparent:</p>
<pre><code class="language-javascript">class OrderProcessor {
  async processOrder(order) {
    pan.publish(&#039;order.processing.start&#039;, { orderId: order.id });

    try {
      await this.validateOrder(order);
      pan.publish(&#039;order.validated&#039;, { orderId: order.id });

      await this.chargePayment(order);
      pan.publish(&#039;order.charged&#039;, { orderId: order.id });

      await this.createShipment(order);
      pan.publish(&#039;order.shipped&#039;, { orderId: order.id });

      pan.publish(&#039;order.complete&#039;, { orderId: order.id });
    } catch (error) {
      pan.publish(&#039;order.failed&#039;, { orderId: order.id, error });
    }
  }
}</code></pre>
<p>Now other parts of your app can react to these events (analytics, notifications, UI updates, etc.).</p>
<h3>4. Document Business Rules</h3>
<p>Make business rules explicit and documented:</p>
<pre><code class="language-javascript">/**
 * Shopping Cart Business Rules
 *
 * 1. Maximum 50 items per order
 * 2. Maximum 10 quantity per item
 * 3. Free shipping over $50
 * 4. Volume discounts:
 *    - 5-9 items: 10% off
 *    - 10+ items: 15% off
 * 5. Member discounts:
 *    - Premium: 15% off
 *    - Gold: 10% off
 * 6. Minimum order value: $10
 */
class CartBusinessRules {
  // Implementation
}</code></pre>
<h3>5. Use Feature Flags</h3>
<p>Make business logic toggleable:</p>
<pre><code class="language-javascript">class CheckoutRules {
  constructor() {
    this.features = {
      guestCheckout: true,
      expressCheckout: false,
      digitalWallet: true
    };
  }

  async handleCheckout(data) {
    if (!this.features.guestCheckout &amp;&amp; !data.user) {
      pan.publish(&#039;checkout.error&#039;, {
        message: &#039;Account required for checkout&#039;
      });
      return;
    }

    // ... rest of logic
  }
}</code></pre>
<h2>Summary</h2>
<p>When integrating business logic into LARC applications:</p>
<li><strong>Default to PAN Bus listeners</strong> for most business logic - it's decoupled, testable, and flexible</li>
<li><strong>Use services</strong> for complex calculations and workflows</li>
<li><strong>Extend components</strong> only when logic is tightly coupled to UI</li>
<li><strong>Use mixins</strong> for cross-cutting concerns like analytics</li>
<li><strong>Wrap components</strong> when adding behavior to third-party code</li>
<li><strong>Keep components dumb</strong> - they publish events, business logic handles the rest</li>
<p>This separation of concerns makes your application:</p>
<ul><li><strong>Easier to test</strong> - business logic without rendering components</li>
<li><strong>More maintainable</strong> - business rules in one place</li>
<li><strong>More flexible</strong> - easy to change rules without touching UI</li>
<li><strong>More reusable</strong> - logic can be shared across components</li>
</ul>
In the next chapter, we'll explore routing and navigation, building on these patterns to create complete single-page applications.
<p>\pagebreak</p>
<h1>Chapter 8: Routing and Navigation</h1>
<p>Client-side routing enables single-page applications (SPAs) to feel like multi-page websites without full page reloads. LARC provides routing through web standards and the PAN bus, keeping things simple and framework-free.</p>
<h2>Client-Side Routing Basics</h2>
<p>Client-side routing intercepts link clicks and updates the URL without reloading:</p>
<pre><code class="language-javascript">// lib/router.js
class Router {
  constructor() {
    this.routes = new Map();
    this.currentRoute = null;

    // Intercept link clicks
    document.addEventListener(&#039;click&#039;, (e) =&gt; {
      if (e.target.matches(&#039;a[href^=&quot;/&quot;]&#039;)) {
        e.preventDefault();
        this.navigate(e.target.getAttribute(&#039;href&#039;));
      }
    });

    // Handle browser back/forward
    window.addEventListener(&#039;popstate&#039;, () =&gt; {
      this.handleRoute(window.location.pathname);
    });
  }

  register(path, handler) {
    this.routes.set(path, handler);
  }

  navigate(path, state = {}) {
    window.history.pushState(state, &#039;&#039;, path);
    this.handleRoute(path);

    // Publish navigation event
    pan.publish(&#039;router.navigated&#039;, { path, state });
  }

  handleRoute(path) {
    // Find matching route
    for (const [pattern, handler] of this.routes) {
      const params = this.matchRoute(pattern, path);
      if (params) {
        this.currentRoute = { path, pattern, params };
        handler(params);
        return;
      }
    }

    // 404 - no match
    pan.publish(&#039;router.not-found&#039;, { path });
  }

  matchRoute(pattern, path) {
    // Simple pattern matching
    const patternParts = pattern.split(&#039;/&#039;).filter(Boolean);
    const pathParts = path.split(&#039;/&#039;).filter(Boolean);

    if (patternParts.length !== pathParts.length) {
      return null;
    }

    const params = {};

    for (let i = 0; i &lt; patternParts.length; i++) {
      const patternPart = patternParts[i];
      const pathPart = pathParts[i];

      if (patternPart.startsWith(&#039;:&#039;)) {
        // Dynamic segment
        params[patternPart.slice(1)] = pathPart;
      } else if (patternPart !== pathPart) {
        // Mismatch
        return null;
      }
    }

    return params;
  }

  start() {
    this.handleRoute(window.location.pathname);
  }
}

export const router = new Router();</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { router } from &#039;./lib/router.js&#039;;

// Register routes
router.register(&#039;/&#039;, () =&gt; {
  document.getElementById(&#039;app&#039;).innerHTML = &#039;&lt;home-page&gt;&lt;/home-page&gt;&#039;;
});

router.register(&#039;/about&#039;, () =&gt; {
  document.getElementById(&#039;app&#039;).innerHTML = &#039;&lt;about-page&gt;&lt;/about-page&gt;&#039;;
});

router.register(&#039;/users/:id&#039;, (params) =&gt; {
  const page = document.createElement(&#039;user-page&#039;);
  page.setAttribute(&#039;user-id&#039;, params.id);
  document.getElementById(&#039;app&#039;).innerHTML = &#039;&#039;;
  document.getElementById(&#039;app&#039;).appendChild(page);
});

// Start router
router.start();</code></pre>
<h2>The pan-router Component</h2>
<p>LARC provides a declarative router component:</p>
<pre><code class="language-html">&lt;pan-router&gt;
  &lt;pan-route path=&quot;/&quot; component=&quot;home-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/about&quot; component=&quot;about-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/users/:id&quot; component=&quot;user-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/posts/:postId/comments/:commentId&quot; component=&quot;comment-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;*&quot; component=&quot;not-found-page&quot;&gt;&lt;/pan-route&gt;
&lt;/pan-router&gt;</code></pre>
<strong>Implementation:</strong>
<pre><code class="language-javascript">class PanRouter extends HTMLElement {
  connectedCallback() {
    this.routes = Array.from(this.querySelectorAll(&#039;pan-route&#039;)).map(route =&gt; ({
      path: route.getAttribute(&#039;path&#039;),
      component: route.getAttribute(&#039;component&#039;),
      guard: route.getAttribute(&#039;guard&#039;)
    }));

    // Create outlet
    this.outlet = document.createElement(&#039;div&#039;);
    this.outlet.className = &#039;router-outlet&#039;;
    this.appendChild(this.outlet);

    // Listen for navigation
    pan.subscribe(&#039;router.navigate&#039;, ({ path, params }) =&gt; {
      this.navigate(path, params);
    });

    // Handle browser navigation
    window.addEventListener(&#039;popstate&#039;, () =&gt; {
      this.handleRoute(window.location.pathname);
    });

    // Intercept links
    document.addEventListener(&#039;click&#039;, (e) =&gt; {
      const link = e.target.closest(&#039;a[href^=&quot;/&quot;]&#039;);
      if (link) {
        e.preventDefault();
        this.navigate(link.getAttribute(&#039;href&#039;));
      }
    });

    // Initial route
    this.handleRoute(window.location.pathname);
  }

  navigate(path, params = {}) {
    window.history.pushState(params, &#039;&#039;, path);
    this.handleRoute(path);
  }

  async handleRoute(path) {
    // Find matching route
    for (const route of this.routes) {
      const params = this.matchRoute(route.path, path);

      if (params) {
        // Check route guard
        if (route.guard) {
          const canActivate = await this.runGuard(route.guard, params);
          if (!canActivate) {
            return;
          }
        }

        // Render component
        await this.renderComponent(route.component, params);
        return;
      }
    }

    // 404
    pan.publish(&#039;router.not-found&#039;, { path });
  }

  matchRoute(pattern, path) {
    if (pattern === &#039;*&#039;) return {};

    const patternParts = pattern.split(&#039;/&#039;).filter(Boolean);
    const pathParts = path.split(&#039;/&#039;).filter(Boolean);

    if (patternParts.length !== pathParts.length) return null;

    const params = {};

    for (let i = 0; i &lt; patternParts.length; i++) {
      if (patternParts[i].startsWith(&#039;:&#039;)) {
        params[patternParts[i].slice(1)] = pathParts[i];
      } else if (patternParts[i] !== pathParts[i]) {
        return null;
      }
    }

    return params;
  }

  async runGuard(guardName, params) {
    const result = await pan.request(`guard.${guardName}`, params);
    return result !== false;
  }

  async renderComponent(componentName, params) {
    // Wait for component to be defined
    await customElements.whenDefined(componentName);

    // Create component
    const component = document.createElement(componentName);

    // Pass route params
    Object.entries(params).forEach(([key, value]) =&gt; {
      component.setAttribute(key, value);
    });

    // Clear outlet and add component
    this.outlet.innerHTML = &#039;&#039;;
    this.outlet.appendChild(component);

    // Publish route change
    pan.publish(&#039;router.changed&#039;, { component: componentName, params });
  }
}

customElements.define(&#039;pan-router&#039;, PanRouter);
customElements.define(&#039;pan-route&#039;, class extends HTMLElement {});</code></pre>
<h2>Route Parameters</h2>
<p>Access route parameters in components:</p>
<pre><code class="language-javascript">class UserPage extends HTMLElement {
  static get observedAttributes() {
    return [&#039;user-id&#039;];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === &#039;user-id&#039; &amp;&amp; newValue) {
      this.loadUser(newValue);
    }
  }

  async loadUser(id) {
    const response = await fetch(`/api/users/${id}`);
    const user = await response.json();
    this.render(user);
  }

  render(user) {
    this.innerHTML = `
      &lt;h1&gt;${user.name}&lt;/h1&gt;
      &lt;p&gt;${user.email}&lt;/p&gt;
    `;
  }
}

customElements.define(&#039;user-page&#039;, UserPage);</code></pre>
<h2>Route Guards</h2>
<p>Protect routes with authentication checks:</p>
<pre><code class="language-javascript">// Respond to auth guard
pan.respond(&#039;guard.auth&#039;, async () =&gt; {
  const token = localStorage.getItem(&#039;authToken&#039;);

  if (!token) {
    // Redirect to login
    pan.publish(&#039;router.navigate&#039;, { path: &#039;/login&#039; });
    return false;
  }

  // Verify token
  try {
    const response = await fetch(&#039;/api/auth/verify&#039;, {
      headers: { &#039;Authorization&#039;: `Bearer ${token}` }
    });

    return response.ok;
  } catch {
    return false;
  }
});

// Respond to admin guard
pan.respond(&#039;guard.admin&#039;, async () =&gt; {
  const user = await pan.request(&#039;auth.user.get&#039;);
  return user?.role === &#039;admin&#039;;
});</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;pan-router&gt;
  &lt;pan-route path=&quot;/login&quot; component=&quot;login-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/dashboard&quot; component=&quot;dashboard-page&quot; guard=&quot;auth&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/admin&quot; component=&quot;admin-page&quot; guard=&quot;admin&quot;&gt;&lt;/pan-route&gt;
&lt;/pan-router&gt;</code></pre>
<h2>Nested Routes</h2>
<p>Support hierarchical routing:</p>
<pre><code class="language-html">&lt;pan-router&gt;
  &lt;pan-route path=&quot;/settings&quot; component=&quot;settings-layout&quot;&gt;
    &lt;pan-route path=&quot;/settings/profile&quot; component=&quot;profile-settings&quot;&gt;&lt;/pan-route&gt;
    &lt;pan-route path=&quot;/settings/security&quot; component=&quot;security-settings&quot;&gt;&lt;/pan-route&gt;
    &lt;pan-route path=&quot;/settings/billing&quot; component=&quot;billing-settings&quot;&gt;&lt;/pan-route&gt;
  &lt;/pan-route&gt;
&lt;/pan-router&gt;</code></pre>
<h2>Programmatic Navigation</h2>
<p>Navigate from JavaScript:</p>
<pre><code class="language-javascript">// Navigate to a path
pan.publish(&#039;router.navigate&#039;, { path: &#039;/users/123&#039; });

// Navigate with state
pan.publish(&#039;router.navigate&#039;, {
  path: &#039;/search&#039;,
  state: { query: &#039;web components&#039; }
});

// Go back
pan.publish(&#039;router.back&#039;);

// Go forward
pan.publish(&#039;router.forward&#039;);

// Replace current route (no history entry)
pan.publish(&#039;router.replace&#039;, { path: &#039;/new-path&#039; });</code></pre>
<h2>Query Parameters</h2>
<p>Parse and use query parameters:</p>
<pre><code class="language-javascript">class SearchPage extends HTMLElement {
  connectedCallback() {
    // Parse query params
    const params = new URLSearchParams(window.location.search);
    const query = params.get(&#039;q&#039;);
    const page = parseInt(params.get(&#039;page&#039;) || &#039;1&#039;);

    this.performSearch(query, page);

    // Listen for query changes
    pan.subscribe(&#039;router.changed&#039;, () =&gt; {
      const params = new URLSearchParams(window.location.search);
      const newQuery = params.get(&#039;q&#039;);
      const newPage = parseInt(params.get(&#039;page&#039;) || &#039;1&#039;);

      if (newQuery !== query || newPage !== page) {
        this.performSearch(newQuery, newPage);
      }
    });
  }

  performSearch(query, page) {
    // Search implementation
  }
}</code></pre>
<strong>Update query params:</strong>
<pre><code class="language-javascript">function updateQuery(params) {
  const url = new URL(window.location);

  Object.entries(params).forEach(([key, value]) =&gt; {
    url.searchParams.set(key, value);
  });

  pan.publish(&#039;router.navigate&#039;, { path: url.pathname + url.search });
}

// Usage
updateQuery({ q: &#039;web components&#039;, page: &#039;2&#039; });</code></pre>
<h2>Summary</h2>
<p>LARC routing provides:</p>
<ul><li>Client-side navigation without page reloads</li>
<li>Declarative route configuration</li>
<li>Route parameters and guards</li>
<li>Nested routing support</li>
<li>Browser history integration</li>
<li>PAN bus integration</li>
</ul>
<hr>
<h2>Best Practices</h2>
<li><strong>Use declarative routing</strong> - Prefer <code><pan-router></code> over imperative API</li>
<li><strong>Implement route guards</strong> - Protect sensitive routes</li>
<li><strong>Handle 404s gracefully</strong> - Always include catch-all route</li>
<li><strong>Preserve scroll position</strong> - Restore scroll on back navigation</li>
<li><strong>Use query params for filters</strong> - Makes URLs shareable</li>
<p>\pagebreak</p>
<h1>Chapter 9: Forms and Validation</h1>
<p>Forms are the primary way users input data into web applications. LARC provides patterns for building accessible, validated forms using web standards and the PAN bus.</p>
<h2>Form Components</h2>
<h3>Basic Form Component</h3>
<pre><code class="language-javascript">class ContactForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  connectedCallback() {
    this.render();
    this.attachEventListeners();
  }

  attachEventListeners() {
    const form = this.shadowRoot.querySelector(&#039;form&#039;);

    form.addEventListener(&#039;submit&#039;, async (e) =&gt; {
      e.preventDefault();

      if (this.validate()) {
        const data = this.getFormData();
        await this.handleSubmit(data);
      }
    });
  }

  getFormData() {
    const form = this.shadowRoot.querySelector(&#039;form&#039;);
    const formData = new FormData(form);
    return Object.fromEntries(formData);
  }

  validate() {
    const form = this.shadowRoot.querySelector(&#039;form&#039;);
    return form.checkValidity();
  }

  async handleSubmit(data) {
    try {
      const response = await fetch(&#039;/api/contact&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify(data)
      });

      if (response.ok) {
        pan.publish(&#039;form.submitted&#039;, { form: &#039;contact&#039;, data });
        this.showSuccess();
      } else {
        throw new Error(&#039;Submission failed&#039;);
      }
    } catch (error) {
      this.showError(error.message);
    }
  }

  showSuccess() {
    pan.publish(&#039;notification.success&#039;, { message: &#039;Form submitted successfully!&#039; });
    this.shadowRoot.querySelector(&#039;form&#039;).reset();
  }

  showError(message) {
    pan.publish(&#039;notification.error&#039;, { message });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        form { max-width: 500px; }
        .field { margin-bottom: 16px; }
        label {
          display: block;
          margin-bottom: 4px;
          font-weight: 600;
        }
        input, textarea {
          width: 100%;
          padding: 8px 12px;
          border: 1px solid #cbd5e0;
          border-radius: 4px;
        }
        input:invalid, textarea:invalid {
          border-color: #fc8181;
        }
        button {
          background: #667eea;
          color: white;
          padding: 10px 24px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
      &lt;/style&gt;

      &lt;form&gt;
        &lt;div class=&quot;field&quot;&gt;
          &lt;label for=&quot;name&quot;&gt;Name *&lt;/label&gt;
          &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; required minlength=&quot;2&quot;&gt;
        &lt;/div&gt;

        &lt;div class=&quot;field&quot;&gt;
          &lt;label for=&quot;email&quot;&gt;Email *&lt;/label&gt;
          &lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; required&gt;
        &lt;/div&gt;

        &lt;div class=&quot;field&quot;&gt;
          &lt;label for=&quot;message&quot;&gt;Message *&lt;/label&gt;
          &lt;textarea id=&quot;message&quot; name=&quot;message&quot; required minlength=&quot;10&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;
        &lt;/div&gt;

        &lt;button type=&quot;submit&quot;&gt;Send Message&lt;/button&gt;
      &lt;/form&gt;
    `;
  }
}

customElements.define(&#039;contact-form&#039;, ContactForm);</code></pre>
<h2>Two-Way Data Binding</h2>
<p>Sync form inputs with component state:</p>
<pre><code class="language-javascript">class DataBoundForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.state = {
      firstName: &#039;&#039;,
      lastName: &#039;&#039;,
      email: &#039;&#039;
    };
  }

  connectedCallback() {
    this.render();
    this.bindInputs();
  }

  bindInputs() {
    const inputs = this.shadowRoot.querySelectorAll(&#039;input&#039;);

    inputs.forEach(input =&gt; {
      // Update state when input changes
      input.addEventListener(&#039;input&#039;, (e) =&gt; {
        this.state[e.target.name] = e.target.value;
        pan.publish(&#039;form.state.changed&#039;, { state: this.state });
      });

      // Update input when state changes
      pan.subscribe(&#039;form.state.update&#039;, (updates) =&gt; {
        if (updates[input.name] !== undefined) {
          input.value = updates[input.name];
          this.state[input.name] = updates[input.name];
        }
      });
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;form&gt;
        &lt;input type=&quot;text&quot; name=&quot;firstName&quot; value=&quot;${this.state.firstName}&quot; placeholder=&quot;First Name&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;lastName&quot; value=&quot;${this.state.lastName}&quot; placeholder=&quot;Last Name&quot;&gt;
        &lt;input type=&quot;email&quot; name=&quot;email&quot; value=&quot;${this.state.email}&quot; placeholder=&quot;Email&quot;&gt;
      &lt;/form&gt;
      &lt;div class=&quot;preview&quot;&gt;
        &lt;p&gt;Hello, ${this.state.firstName} ${this.state.lastName}!&lt;/p&gt;
        &lt;p&gt;Email: ${this.state.email}&lt;/p&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h2>Validation Strategies</h2>
<h3>Native HTML5 Validation</h3>
<pre><code class="language-html">&lt;input type=&quot;email&quot; required&gt;
&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;100&quot;&gt;
&lt;input type=&quot;text&quot; pattern=&quot;[A-Za-z]{3,}&quot; title=&quot;At least 3 letters&quot;&gt;
&lt;input type=&quot;url&quot; required&gt;</code></pre>
<h3>Custom Validation</h3>
<pre><code class="language-javascript">class ValidatedInput extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;
      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;
    `;

    const input = this.querySelector(&#039;input&#039;);
    const error = this.querySelector(&#039;.error&#039;);

    input.addEventListener(&#039;blur&#039;, () =&gt; {
      const validationResult = this.customValidate(input.value);

      if (!validationResult.valid) {
        error.textContent = validationResult.message;
        input.classList.add(&#039;invalid&#039;);
      } else {
        error.textContent = &#039;&#039;;
        input.classList.remove(&#039;invalid&#039;);
      }
    });
  }

  customValidate(value) {
    // Custom validation logic
    if (value.length &lt; 3) {
      return { valid: false, message: &#039;Must be at least 3 characters&#039; };
    }

    if (!/^[a-zA-Z]+$/.test(value)) {
      return { valid: false, message: &#039;Only letters allowed&#039; };
    }

    return { valid: true };
  }
}</code></pre>
<h3>Async Validation</h3>
<pre><code class="language-javascript">class UsernameInput extends HTMLElement {
  connectedCallback() {
    this.render();

    const input = this.querySelector(&#039;input&#039;);
    let timeoutId;

    input.addEventListener(&#039;input&#039;, (e) =&gt; {
      clearTimeout(timeoutId);

      timeoutId = setTimeout(async () =&gt; {
        await this.checkAvailability(e.target.value);
      }, 500);
    });
  }

  async checkAvailability(username) {
    const status = this.querySelector(&#039;.status&#039;);

    if (username.length &lt; 3) {
      status.textContent = &#039;&#039;;
      return;
    }

    status.textContent = &#039;Checking...&#039;;

    try {
      const response = await fetch(`/api/check-username?username=${username}`);
      const { available } = await response.json();

      if (available) {
        status.textContent = &#039;✓ Available&#039;;
        status.className = &#039;status success&#039;;
      } else {
        status.textContent = &#039;✗ Already taken&#039;;
        status.className = &#039;status error&#039;;
      }
    } catch (error) {
      status.textContent = &#039;Could not check availability&#039;;
      status.className = &#039;status error&#039;;
    }
  }

  render() {
    this.innerHTML = `
      &lt;label&gt;Username&lt;/label&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;Choose a username&quot;&gt;
      &lt;span class=&quot;status&quot;&gt;&lt;/span&gt;
    `;
  }
}</code></pre>
<h2>Error Handling</h2>
<p>Display validation errors elegantly:</p>
<pre><code class="language-javascript">class FormWithErrors extends HTMLElement {
  constructor() {
    super();
    this.errors = {};
  }

  connectedCallback() {
    this.render();

    const form = this.querySelector(&#039;form&#039;);

    form.addEventListener(&#039;submit&#039;, (e) =&gt; {
      e.preventDefault();

      this.clearErrors();
      const errors = this.validateForm();

      if (Object.keys(errors).length === 0) {
        this.handleSubmit();
      } else {
        this.showErrors(errors);
      }
    });
  }

  validateForm() {
    const errors = {};
    const inputs = this.querySelectorAll(&#039;input&#039;);

    inputs.forEach(input =&gt; {
      if (!input.validity.valid) {
        errors[input.name] = this.getErrorMessage(input);
      }
    });

    return errors;
  }

  getErrorMessage(input) {
    if (input.validity.valueMissing) {
      return &#039;This field is required&#039;;
    }
    if (input.validity.typeMismatch) {
      return `Please enter a valid ${input.type}`;
    }
    if (input.validity.tooShort) {
      return `Must be at least ${input.minLength} characters`;
    }
    if (input.validity.tooLong) {
      return `Must be no more than ${input.maxLength} characters`;
    }
    if (input.validity.patternMismatch) {
      return input.title || &#039;Invalid format&#039;;
    }

    return &#039;Invalid input&#039;;
  }

  showErrors(errors) {
    Object.entries(errors).forEach(([fieldName, message]) =&gt; {
      const field = this.querySelector(`[name=&quot;${fieldName}&quot;]`);
      const errorEl = field.parentElement.querySelector(&#039;.error&#039;);

      if (errorEl) {
        errorEl.textContent = message;
        field.classList.add(&#039;invalid&#039;);
      }
    });
  }

  clearErrors() {
    this.querySelectorAll(&#039;.error&#039;).forEach(el =&gt; {
      el.textContent = &#039;&#039;;
    });

    this.querySelectorAll(&#039;.invalid&#039;).forEach(el =&gt; {
      el.classList.remove(&#039;invalid&#039;);
    });
  }

  render() {
    this.innerHTML = `
      &lt;form&gt;
        &lt;div class=&quot;field&quot;&gt;
          &lt;label&gt;Email&lt;/label&gt;
          &lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt;
          &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;

        &lt;div class=&quot;field&quot;&gt;
          &lt;label&gt;Password&lt;/label&gt;
          &lt;input type=&quot;password&quot; name=&quot;password&quot; required minlength=&quot;8&quot;&gt;
          &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;

        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    `;
  }
}</code></pre>
<h2>File Uploads</h2>
<p>Handle file uploads with progress tracking:</p>
<pre><code class="language-javascript">class FileUpload extends HTMLElement {
  connectedCallback() {
    this.render();

    const input = this.querySelector(&#039;input[type=&quot;file&quot;]&#039;);
    const button = this.querySelector(&#039;button&#039;);

    input.addEventListener(&#039;change&#039;, (e) =&gt; {
      const file = e.target.files[0];
      if (file) {
        this.showPreview(file);
        button.disabled = false;
      }
    });

    button.addEventListener(&#039;click&#039;, () =&gt; {
      const file = input.files[0];
      if (file) {
        this.uploadFile(file);
      }
    });
  }

  showPreview(file) {
    const preview = this.querySelector(&#039;.preview&#039;);

    if (file.type.startsWith(&#039;image/&#039;)) {
      const reader = new FileReader();
      reader.onload = (e) =&gt; {
        preview.innerHTML = `&lt;img src=&quot;${e.target.result}&quot; alt=&quot;Preview&quot;&gt;`;
      };
      reader.readAsDataURL(file);
    } else {
      preview.innerHTML = `
        &lt;p&gt;${file.name}&lt;/p&gt;
        &lt;p&gt;${this.formatFileSize(file.size)}&lt;/p&gt;
      `;
    }
  }

  async uploadFile(file) {
    const formData = new FormData();
    formData.append(&#039;file&#039;, file);

    const xhr = new XMLHttpRequest();

    xhr.upload.addEventListener(&#039;progress&#039;, (e) =&gt; {
      const percent = (e.loaded / e.total) * 100;
      this.updateProgress(percent);
    });

    xhr.addEventListener(&#039;load&#039;, () =&gt; {
      if (xhr.status === 200) {
        pan.publish(&#039;file.uploaded&#039;, {
          filename: file.name,
          response: JSON.parse(xhr.response)
        });
        this.showSuccess();
      } else {
        this.showError(&#039;Upload failed&#039;);
      }
    });

    xhr.addEventListener(&#039;error&#039;, () =&gt; {
      this.showError(&#039;Upload failed&#039;);
    });

    xhr.open(&#039;POST&#039;, &#039;/api/upload&#039;);
    xhr.send(formData);
  }

  updateProgress(percent) {
    const progress = this.querySelector(&#039;.progress-bar&#039;);
    progress.style.width = `${percent}%`;
    progress.textContent = `${Math.round(percent)}%`;
  }

  formatFileSize(bytes) {
    if (bytes &lt; 1024) return bytes + &#039; B&#039;;
    if (bytes &lt; 1024 * 1024) return (bytes / 1024).toFixed(1) + &#039; KB&#039;;
    return (bytes / (1024 * 1024)).toFixed(1) + &#039; MB&#039;;
  }

  showSuccess() {
    this.querySelector(&#039;.status&#039;).innerHTML = &#039;✓ Uploaded successfully&#039;;
  }

  showError(message) {
    this.querySelector(&#039;.status&#039;).innerHTML = `✗ ${message}`;
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;upload-container&quot;&gt;
        &lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&gt;
        &lt;div class=&quot;preview&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;progress&quot;&gt;
          &lt;div class=&quot;progress-bar&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;button disabled&gt;Upload&lt;/button&gt;
        &lt;div class=&quot;status&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;file-upload&#039;, FileUpload);</code></pre>
<h2>Form Submission</h2>
<p>Handle form submission with loading states and error recovery:</p>
<pre><code class="language-javascript">class SmartForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.submitting = false;
  }

  connectedCallback() {
    this.render();

    this.shadowRoot.querySelector(&#039;form&#039;).addEventListener(&#039;submit&#039;, async (e) =&gt; {
      e.preventDefault();

      if (this.submitting) return;

      this.submitting = true;
      this.disableForm();

      try {
        const data = this.getFormData();
        await this.submitForm(data);
        this.handleSuccess();
      } catch (error) {
        this.handleError(error);
      } finally {
        this.submitting = false;
        this.enableForm();
      }
    });
  }

  getFormData() {
    const form = this.shadowRoot.querySelector(&#039;form&#039;);
    const formData = new FormData(form);
    return Object.fromEntries(formData);
  }

  async submitForm(data) {
    const response = await fetch(&#039;/api/submit&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || &#039;Submission failed&#039;);
    }

    return response.json();
  }

  disableForm() {
    const inputs = this.shadowRoot.querySelectorAll(&#039;input, button, textarea&#039;);
    inputs.forEach(el =&gt; el.disabled = true);

    this.shadowRoot.querySelector(&#039;.loading&#039;).style.display = &#039;block&#039;;
  }

  enableForm() {
    const inputs = this.shadowRoot.querySelectorAll(&#039;input, button, textarea&#039;);
    inputs.forEach(el =&gt; el.disabled = false);

    this.shadowRoot.querySelector(&#039;.loading&#039;).style.display = &#039;none&#039;;
  }

  handleSuccess() {
    pan.publish(&#039;notification.success&#039;, { message: &#039;Form submitted successfully!&#039; });
    this.shadowRoot.querySelector(&#039;form&#039;).reset();
  }

  handleError(error) {
    pan.publish(&#039;notification.error&#039;, { message: error.message });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .loading {
          display: none;
          text-align: center;
          padding: 16px;
        }
      &lt;/style&gt;

      &lt;form&gt;
        &lt;!-- Form fields --&gt;
        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
      &lt;/form&gt;

      &lt;div class=&quot;loading&quot;&gt;
        &lt;div class=&quot;spinner&quot;&gt;&lt;/div&gt;
        &lt;p&gt;Submitting...&lt;/p&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;smart-form&#039;, SmartForm);</code></pre>
<h2>Summary</h2>
<p>This chapter covered:</p>
<ul><li>Building accessible form components</li>
<li>Two-way data binding patterns</li>
<li>Validation strategies (native and custom)</li>
<li>Error handling and display</li>
<li>File upload with progress tracking</li>
<li>Form submission with loading states</li>
</ul>
<hr>
<h2>Best Practices</h2>
<li><strong>Use native validation first</strong> - HTML5 provides powerful built-in validation</li>
<li><strong>Provide clear error messages</strong> - Tell users exactly what's wrong</li>
<li><strong>Validate on blur</strong> - Don't show errors while user is typing</li>
<li><strong>Disable during submission</strong> - Prevent double-submission</li>
<li><strong>Show progress for uploads</strong> - Users want to see progress</li>
<li><strong>Handle errors gracefully</strong> - Network can fail, handle it well</li>
<p>\pagebreak</p>
<h1>Chapters 11-19: Summary Outlines</h1>
<h2>Chapter 11: Data Fetching and APIs</h2>
<h3>Key Topics:</h3>
<ul><li><strong>REST API Integration</strong>: Using fetch() with proper error handling</li>
<li><strong>GraphQL Support</strong>: Query/mutation patterns with LARC</li>
<li><strong>WebSocket Communication</strong>: Real-time bi-directional communication</li>
<li><strong>Server-Sent Events</strong>: One-way server push for live updates</li>
<li><strong>Caching Strategies</strong>: Cache-first, network-first, stale-while-revalidate</li>
<li><strong>Retry Logic</strong>: Exponential backoff and circuit breakers</li>
</ul>
<h3>Code Example - API Client:</h3>
<pre><code class="language-javascript">class ApiClient {
  async fetch(endpoint, options = {}) {
    const response = await fetch(`/api${endpoint}`, {
      ...options,
      headers: {
        &#039;Content-Type&#039;: &#039;application/json&#039;,
        ...options.headers
      }
    });

    if (!response.ok) throw new Error(`API Error: ${response.status}`);
    return response.json();
  }

  async get(endpoint) {
    return this.fetch(endpoint);
  }

  async post(endpoint, data) {
    return this.fetch(endpoint, {
      method: &#039;POST&#039;,
      body: JSON.stringify(data)
    });
  }
}</code></pre>
<h2>Chapter 12: Authentication and Security</h2>
<h3>Key Topics:</h3>
<ul><li><strong>JWT Token Management</strong>: Storing, refreshing, and validating tokens</li>
<li><strong>The pan-auth Component</strong>: Centralized authentication state</li>
<li><strong>Protected Routes</strong>: Route guards for authenticated pages</li>
<li><strong>CORS Handling</strong>: Cross-origin resource sharing configuration</li>
<li><strong>XSS Prevention</strong>: Sanitizing user input</li>
<li><strong>CSRF Protection</strong>: Token-based request validation</li>
</ul>
<h3>Code Example - Auth Service:</h3>
<pre><code class="language-javascript">class AuthService {
  async login(credentials) {
    const response = await fetch(&#039;/api/auth/login&#039;, {
      method: &#039;POST&#039;,
      body: JSON.stringify(credentials)
    });

    const { token, user } = await response.json();

    localStorage.setItem(&#039;authToken&#039;, token);
    pan.publish(&#039;auth.login&#039;, { user });

    return { token, user };
  }

  async refresh() {
    const token = localStorage.getItem(&#039;authToken&#039;);
    const response = await fetch(&#039;/api/auth/refresh&#039;, {
      headers: { &#039;Authorization&#039;: `Bearer ${token}` }
    });

    const { token: newToken } = await response.json();
    localStorage.setItem(&#039;authToken&#039;, newToken);
  }

  logout() {
    localStorage.removeItem(&#039;authToken&#039;);
    pan.publish(&#039;auth.logout&#039;);
  }
}</code></pre>
<h2>Chapter 13: Server Integration</h2>
<h3>Key Topics:</h3>
<ul><li><strong>Node.js/Express Backend</strong>: RESTful API design for LARC</li>
<li><strong>PHP Integration</strong>: Connecting LARC to PHP backends</li>
<li><strong>Python/Django</strong>: Django REST framework integration</li>
<li><strong>Database Patterns</strong>: ORM usage and raw SQL</li>
<li><strong>Real-Time</strong>: WebSocket servers with Socket.io</li>
<li><strong>File Serving</strong>: Static assets and CDN integration</li>
</ul>
<h3>Node.js Example:</h3>
<pre><code class="language-javascript">// server.js
const express = require(&#039;express&#039;);
const app = express();

app.use(express.json());
app.use(express.static(&#039;public&#039;));

app.get(&#039;/api/users&#039;, async (req, res) =&gt; {
  const users = await db.users.findAll();
  res.json(users);
});

app.post(&#039;/api/users&#039;, async (req, res) =&gt; {
  const user = await db.users.create(req.body);
  res.json(user);
});

app.listen(3000);</code></pre>
<h2>Chapter 14: Testing</h2>
<h3>Key Topics:</h3>
<ul><li><strong>Unit Testing</strong>: Testing components in isolation with Web Test Runner</li>
<li><strong>Integration Testing</strong>: Testing component interactions</li>
<li><strong>E2E Testing</strong>: Playwright/Puppeteer for full user flows</li>
<li><strong>Visual Regression</strong>: Percy or BackstopJS for UI testing</li>
<li><strong>Mocking</strong>: Fetch mocks and PAN bus mocks</li>
<li><strong>CI/CD</strong>: GitHub Actions test automation</li>
</ul>
<h3>Test Example:</h3>
<pre><code class="language-javascript">import { expect, fixture, html } from &#039;@open-wc/testing&#039;;
import &#039;../user-card.js&#039;;

describe(&#039;UserCard&#039;, () =&gt; {
  it(&#039;renders user data&#039;, async () =&gt; {
    const el = await fixture(html`
      &lt;user-card .user=${{ name: &#039;John&#039;, email: &#039;john@example.com&#039; }}&gt;
      &lt;/user-card&gt;
    `);

    expect(el.shadowRoot.querySelector(&#039;h2&#039;).textContent).to.equal(&#039;John&#039;);
    expect(el.shadowRoot.querySelector(&#039;.email&#039;).textContent).to.equal(&#039;john@example.com&#039;);
  });

  it(&#039;dispatches follow event on button click&#039;, async () =&gt; {
    const el = await fixture(html`&lt;user-card&gt;&lt;/user-card&gt;`);

    let eventData = null;
    el.addEventListener(&#039;follow&#039;, (e) =&gt; {
      eventData = e.detail;
    });

    el.shadowRoot.querySelector(&#039;button&#039;).click();

    expect(eventData).to.exist;
  });
});</code></pre>
<h2>Chapter 15: Performance and Optimization</h2>
<h3>Key Topics:</h3>
<ul><li><strong>Code Splitting</strong>: Dynamic imports for lazy loading</li>
<li><strong>Tree Shaking</strong>: Removing unused code</li>
<li><strong>Lazy Loading</strong>: Intersection Observer patterns</li>
<li><strong>Image Optimization</strong>: WebP, lazy loading, responsive images</li>
<li><strong>Caching</strong>: Service Worker caching strategies</li>
<li><strong>Performance Monitoring</strong>: Web Vitals and metrics</li>
</ul>
<h3>Performance Patterns:</h3>
<pre><code class="language-javascript">// Lazy load on interaction
button.addEventListener(&#039;click&#039;, async () =&gt; {
  const { HeavyComponent } = await import(&#039;./heavy-component.js&#039;);
  // Use component
}, { once: true });

// Intersection Observer for images
const observer = new IntersectionObserver((entries) =&gt; {
  entries.forEach(entry =&gt; {
    if (entry.isIntersecting) {
      entry.target.src = entry.target.dataset.src;
      observer.unobserve(entry.target);
    }
  });
});

document.querySelectorAll(&#039;img[data-src]&#039;).forEach(img =&gt; {
  observer.observe(img);
});</code></pre>
<h2>Chapter 16: Deployment</h2>
<h3>Key Topics:</h3>
<ul><li><strong>Static Hosting</strong>: Netlify, Vercel, GitHub Pages</li>
<li><strong>CDN Configuration</strong>: CloudFlare, AWS CloudFront</li>
<li><strong>Environment Variables</strong>: Managing config across environments</li>
<li><strong>Build Scripts</strong>: Optional production optimization</li>
<li><strong>CI/CD Pipelines</strong>: Automated deployment workflows</li>
<li><strong>Monitoring</strong>: Error tracking and analytics</li>
</ul>
<h3>Deployment Checklist:</h3>
<ul><li>[ ] Minify JavaScript (optional but recommended)</li>
<li>[ ] Optimize images</li>
<li>[ ] Set up CDN for assets</li>
<li>[ ] Configure caching headers</li>
<li>[ ] Enable HTTPS</li>
<li>[ ] Set up error monitoring (Sentry)</li>
<li>[ ] Configure analytics (Plausible, Fathom)</li>
<li>[ ] Test in all target browsers</li>
<li>[ ] Set up automated deployments</li>
</ul>
<h2>Chapter 17: Component Library</h2>
<h3>Key Topics:</h3>
<ul><li><strong>Using the Registry</strong>: Finding and installing components</li>
<li><strong>Contributing Components</strong>: Publishing to the registry</li>
<li><strong>Component Quality</strong>: Tests, types, documentation</li>
<li><strong>Versioning</strong>: Semantic versioning and changelogs</li>
<li><strong>Documentation</strong>: API docs and usage examples</li>
<li><strong>Design Systems</strong>: Building consistent component libraries</li>
</ul>
<h3>Registry Integration:</h3>
<pre><code class="language-bash"># Install component from registry
larc add @larcjs/ui

# Publish component to registry
larc publish ./components/my-component.js</code></pre>
<h2>Chapter 18: Tooling</h2>
<h3>Key Topics:</h3>
<ul><li><strong>LARC CLI</strong>: create-larc-app, dev server, generators</li>
<li><strong>VS Code Extension</strong>: Snippets, IntelliSense, commands</li>
<li><strong>Browser DevTools</strong>: Debugging Web Components and Shadow DOM</li>
<li><strong>Hot Module Reload</strong>: Live updates without full refresh</li>
<li><strong>Linting</strong>: ESLint configuration for LARC</li>
<li><strong>Formatting</strong>: Prettier setup</li>
</ul>
<h3>VS Code Snippets:</h3>
<pre><code class="language-json">{
  &quot;LARC Component&quot;: {
    &quot;prefix&quot;: &quot;larc-component&quot;,
    &quot;body&quot;: [
      &quot;class ${1:ComponentName} extends HTMLElement {&quot;,
      &quot;  constructor() {&quot;,
      &quot;    super();&quot;,
      &quot;    this.attachShadow({ mode: &#039;open&#039; });&quot;,
      &quot;  }&quot;,
      &quot;  &quot;,
      &quot;  connectedCallback() {&quot;,
      &quot;    this.render();&quot;,
      &quot;  }&quot;,
      &quot;  &quot;,
      &quot;  render() {&quot;,
      &quot;    this.shadowRoot.innerHTML = \\`&quot;,
      &quot;      &lt;style&gt;&quot;,
      &quot;        :host { display: block; }&quot;,
      &quot;      &lt;/style&gt;&quot;,
      &quot;      $2&quot;,
      &quot;    \\`;&quot;,
      &quot;  }&quot;,
      &quot;}&quot;,
      &quot;&quot;,
      &quot;customElements.define(&#039;${3:component-name}&#039;, ${1:ComponentName});&quot;
    ]
  }
}</code></pre>
<h2>Chapter 19: Real-World Applications</h2>
<h3>Case Study 1: E-Commerce Platform</h3>
<strong>Features:</strong>
<ul><li>Product catalog with search and filters</li>
<li>Shopping cart with persistence</li>
<li>Checkout flow with payment integration</li>
<li>User authentication and profiles</li>
<li>Order history and tracking</li>
</ul>
<strong>Architecture:</strong>
<ul><li>Components: product-card, cart-widget, checkout-form</li>
<li>State: IndexedDB for cart, localStorage for preferences</li>
<li>API: REST backend with Stripe integration</li>
<li>Routing: /products, /cart, /checkout, /orders</li>
</ul>
<h3>Case Study 2: Dashboard Application</h3>
<strong>Features:</strong>
<ul><li>Real-time data visualization</li>
<li>User permissions and roles</li>
<li>Data export functionality</li>
<li>Responsive layout</li>
<li>Dark mode support</li>
</ul>
<strong>Architecture:</strong>
<ul><li>Components: chart-widget, data-table, filter-bar</li>
<li>State: Reactive store with WebSocket updates</li>
<li>API: GraphQL for flexible queries</li>
<li>Real-time: WebSocket for live updates</li>
</ul>
<h3>Case Study 3: Blog/CMS</h3>
<strong>Features:</strong>
<ul><li>Markdown editor</li>
<li>Draft auto-save</li>
<li>Media library</li>
<li>SEO optimization</li>
<li>Static site generation</li>
</ul>
<strong>Architecture:</strong>
<ul><li>Components: markdown-editor, media-upload, post-list</li>
<li>State: IndexedDB for drafts</li>
<li>API: Headless CMS (Contentful/Strapi)</li>
<li>Build: Optional SSG for production</li>
</ul>
<h3>Lessons Learned:</h3>
<li>Start simple, add complexity as needed</li>
<li>Use the PAN bus for cross-component communication</li>
<li>Implement offline-first for better UX</li>
<li>Test early and often</li>
<li>Profile before optimizing</li>
<li>Document your components</li>
<li>Use TypeScript for larger projects</li>
<li>Implement error boundaries</li>
<li>Monitor performance in production</li>
<li>Build progressively</li>
<hr>
<h1>Appendices</h1>
<h2>Appendix A: Web Components API Reference</h2>
<h3>Custom Elements</h3>
<ul><li><code>customElements.define(name, constructor, options)</code></li>
<li><code>customElements.get(name)</code></li>
<li><code>customElements.whenDefined(name)</code></li>
<li><code>customElements.upgrade(root)</code></li>
</ul>
<h3>Lifecycle Callbacks</h3>
<ul><li><code>constructor()</code></li>
<li><code>connectedCallback()</code></li>
<li><code>disconnectedCallback()</code></li>
<li><code>attributeChangedCallback(name, oldValue, newValue)</code></li>
<li><code>adoptedCallback()</code></li>
</ul>
<h3>Shadow DOM</h3>
<ul><li><code>element.attachShadow({ mode: 'open'|'closed' })</code></li>
<li><code>element.shadowRoot</code></li>
<li><code>slot.assignedNodes()</code></li>
<li><code>slot.assignedElements()</code></li>
</ul>
<h2>Appendix B: PAN Bus API Reference</h2>
<h3>Core Methods</h3>
<pre><code class="language-javascript">// Publish
pan.publish(topic, data)

// Subscribe
const unsubscribe = pan.subscribe(topic, handler)

// Request/Response
const result = await pan.request(topic, data, timeout)
pan.respond(topic, handler)

// Unsubscribe
unsubscribe()</code></pre>
<h3>Topic Patterns</h3>
<ul><li><code>user.login</code> - Specific event</li>
<li><code>user.*</code> - All user events</li>
<li><code>*.error</code> - All error events</li>
<li><code>*</code> - All events (debugging)</li>
</ul>
<h2>Appendix C: Component API Reference</h2>
<h3>Built-in Components</h3>
<strong>pan-store</strong>
<ul><li>Attributes: <code>persist</code>, <code>namespace</code></li>
<li>Methods: <code>getState()</code>, <code>setState(updates)</code>, <code>subscribe(path, handler)</code></li>
<li>Events: <code>state-changed</code></li>
</ul>
<strong>pan-router</strong>
<ul><li>Child: <code><pan-route path="" component="" guard=""></code></li>
<li>Events: <code>router.navigated</code>, <code>router.not-found</code></li>
<li>PAN Topics: <code>router.navigate</code>, <code>router.back</code>, <code>router.forward</code></li>
</ul>
<strong>pan-fetch</strong>
<ul><li>Attributes: <code>url</code>, <code>method</code>, <code>auto</code></li>
<li>Properties: <code>data</code>, <code>loading</code>, <code>error</code></li>
<li>Events: <code>data-loaded</code>, <code>fetch-error</code></li>
</ul>
<strong>pan-auth</strong>
<ul><li>Methods: <code>login(credentials)</code>, <code>logout()</code>, <code>refresh()</code></li>
<li>Properties: <code>user</code>, <code>authenticated</code></li>
<li>Events: <code>auth-changed</code></li>
</ul>
<h2>Appendix D: Migration Guides</h2>
<h3>From React</h3>
<strong>Concepts:</strong>
<ul><li>JSX → Template literals</li>
<li>Props → Attributes/properties</li>
<li>State → Instance properties</li>
<li>Context → PAN bus or Context API pattern</li>
<li>Hooks → Lifecycle callbacks</li>
<li>Redux → pan-store or custom store</li>
</ul>
<strong>Example:</strong>
<pre><code class="language-javascript">// React
function UserCard({ user }) {
  const [expanded, setExpanded] = useState(false);

  return (
    &lt;div onClick={() =&gt; setExpanded(!expanded)}&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      {expanded &amp;&amp; &lt;p&gt;{user.bio}&lt;/p&gt;}
    &lt;/div&gt;
  );
}

// LARC
class UserCard extends HTMLElement {
  constructor() {
    super();
    this.expanded = false;
  }

  set user(value) {
    this._user = value;
    this.render();
  }

  connectedCallback() {
    this.addEventListener(&#039;click&#039;, () =&gt; {
      this.expanded = !this.expanded;
      this.render();
    });
    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;div&gt;
        &lt;h2&gt;${this._user.name}&lt;/h2&gt;
        ${this.expanded ? `&lt;p&gt;${this._user.bio}&lt;/p&gt;` : &#039;&#039;}
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h3>From Vue</h3>
<strong>Concepts:</strong>
<ul><li>Templates → Template literals</li>
<li>v-model → Two-way binding patterns</li>
<li>Computed → Getters</li>
<li>Watch → Observe patterns</li>
<li>Vuex → pan-store</li>
</ul>
<h3>From Angular</h3>
<strong>Concepts:</strong>
<ul><li>Decorators → Static properties</li>
<li>Dependency Injection → Constructor patterns</li>
<li>Services → Modules</li>
<li>RxJS → PAN bus observables</li>
<li>NgRx → pan-store</li>
</ul>
<h2>Appendix E: Resources</h2>
<h3>Official Documentation</h3>
<ul><li>LARC Docs: https://larcjs.com/docs</li>
<li>Component Registry: https://components.larcjs.com</li>
<li>GitHub: https://github.com/larcjs/larc</li>
</ul>
<h3>Web Standards</h3>
<ul><li>MDN Web Components: https://developer.mozilla.org/en-US/docs/Web/Web_Components</li>
<li>Custom Elements Spec: https://html.spec.whatwg.org/multipage/custom-elements.html</li>
<li>Shadow DOM Spec: https://dom.spec.whatwg.org/#shadow-trees</li>
</ul>
<h3>Community</h3>
<ul><li>Discord: https://discord.gg/larcjs</li>
<li>Forum: https://forum.larcjs.com</li>
<li>Twitter: @larcjs</li>
</ul>
<h3>Learning Resources</h3>
<ul><li>Web Components Tutorial: https://webcomponents.org</li>
<li>ES Modules Guide: https://javascript.info/modules</li>
<li>IndexedDB Tutorial: https://javascript.info/indexeddb</li>
</ul>
<h3>Tools</h3>
<ul><li>LARC CLI: https://www.npmjs.com/package/create-larc-app</li>
<li>VS Code Extension: Search "LARC" in marketplace</li>
<li>Component Analyzer: https://github.com/larcjs/larc/tree/main/packages/devtools</li>
</ul>
<h3>Example Projects</h3>
<ul><li>Official Examples: https://github.com/larcjs/larc/tree/main/packages/examples</li>
<li>Demo Apps: https://github.com/larcjs/larc/tree/main/packages/apps</li>
</ul>
\pagebreak
<h2>About the Author</h2>
<p>Christopher Robison is a veteran software engineer and architect with nearly three 
decades of experience building systems that range from biotech and online trading 
platforms to complex web applications and AI-driven tools. A lifelong maker with 
a deep appreciation for open standards, he has spent his career exploring the 
boundaries of what the web can do when you stop fighting the platform and start 
embracing it.</p>
<p>He is the creator of LARC.js and the PAN message bus, a browser-native architecture 
inspired by the elegant simplicity of the automotive CAN bus. His work blends engineering 
pragmatism with a playful curiosity that has led him to design everything from 
3D printers and robotics to interactive music systems and decentralized applications.</p>
<p>Christopher currently lives in San Francisco, where he continues to build things that 
bridge the digital and physical worlds — and occasionally sneaks off to play punk 
rock shows with his band.</p>
<p>\pagebreak</p>
<h2>The Web Has Grown Up. It’s Time Our Apps Did Too.</h2>
<p>Modern browsers aren’t the brittle playgrounds they once were. They’re fast, secure, 
richly capable application platforms — yet most of today’s development stacks still 
treat them like dumb terminals that need layers of tooling, bundling, and framework 
magic just to function.</p>
<strong>Learning LARC</strong> shows another path.
<p>LARC embraces the browser as a mature runtime, using nothing but open standards — 
Web Components, modules, events, and message buses — to build complex, deeply 
interactive applications without build systems, without monoliths, and without 
ceremony. Through clear narrative examples and real architectural stories, this 
book teaches you how to design apps as ecosystems: small parts, clearly defined, 
communicating through a shared bus.</p>
<p>You’ll learn how to structure large systems out of tiny cooperating modules, expose 
capabilities through message patterns instead of global state, keep your interfaces 
clean, and let the platform do the heavy lifting it was built for.</p>
<p>No bundlers. No scaffolding. No twenty-layer dependency stacks.
Just the browser, finally treated like the grown-up it is.</p>
<p>Whether you’re maintaining a legacy system or starting fresh, <strong>Learning LARC</strong> will 
help you rethink how modern web apps can — and should — be built.</p>

      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/docs/books/learning-larc/build/temp/learning-larc-complete.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
</body>
</html>