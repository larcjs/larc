<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Recipes and Patterns Â· PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Recipes and Patterns">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">docs</a> / <a href="#">building-with-larc</a> / <span>appendix-e-recipes-and-patterns</span>
      </div>
      <article class="docs-content">
        <h1>Recipes and Patterns</h1>
<p>This appendix provides practical, copy-paste-ready solutions for common LARC development scenarios. Each recipe demonstrates a specific technique or pattern you'll encounter when building real applications. Use these as starting points, adapting them to your specific requirements.</p>
<h2>Recipe 1: Lazy-Loading Components</h2>
<p>Defer component loading until needed, reducing initial bundle size.</p>
<pre><code class="language-javascript">class LazyLoader extends HTMLElement {
  async connectedCallback() {
    const componentName = this.getAttribute(&#039;component&#039;);
    const modulePath = this.getAttribute(&#039;module&#039;);

    try {
      await import(modulePath);
      const element = document.createElement(componentName);
      Array.from(this.attributes).forEach(attr =&gt; {
        if (attr.name !== &#039;component&#039; &amp;&amp; attr.name !== &#039;module&#039;) {
          element.setAttribute(attr.name, attr.value);
        }
      });
      this.replaceWith(element);
    } catch (error) {
      this.innerHTML = `&lt;div class=&quot;error&quot;&gt;Failed to load component&lt;/div&gt;`;
      console.error(&#039;Lazy load failed:&#039;, error);
    }
  }
}

customElements.define(&#039;lazy-loader&#039;, LazyLoader);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;lazy-loader
  component=&quot;data-table&quot;
  module=&quot;/components/data-table.js&quot;
  data-source=&quot;/api/users&quot;&gt;
&lt;/lazy-loader&gt;</code></pre>
<strong>When to Use:</strong>
<ul><li>Large components used infrequently</li>
<li>Route-based code splitting</li>
<li>Conditional feature loading based on user permissions</li>
</ul>
<h2>Recipe 2: Form Validation Component</h2>
<p>Reusable form validation with real-time feedback.</p>
<pre><code class="language-javascript">class ValidatedForm extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });
    this.validators = new Map();
    this.errors = new Map();

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .field { margin-bottom: 1rem; }
        .error { color: #d32f2f; font-size: 0.875rem; margin-top: 0.25rem; }
        .valid { border-color: #4caf50; }
        .invalid { border-color: #d32f2f; }
      &lt;/style&gt;
      &lt;form&gt;
        &lt;slot&gt;&lt;/slot&gt;
        &lt;div class=&quot;actions&quot;&gt;
          &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    `;

    this.setupValidation();
  }

  setupValidation() {
    const form = this.shadowRoot.querySelector(&#039;form&#039;);
    const inputs = this.querySelectorAll(&#039;[data-validate]&#039;);

    inputs.forEach(input =&gt; {
      const rules = input.getAttribute(&#039;data-validate&#039;).split(&#039;,&#039;);
      this.validators.set(input, rules);

      input.addEventListener(&#039;blur&#039;, () =&gt; this.validateField(input));
      input.addEventListener(&#039;input&#039;, () =&gt; {
        if (this.errors.has(input)) {
          this.validateField(input);
        }
      });
    });

    form.addEventListener(&#039;submit&#039;, (e) =&gt; {
      e.preventDefault();
      if (this.validateAll()) {
        this.handleSubmit();
      }
    });
  }

  validateField(input) {
    const rules = this.validators.get(input);
    const value = input.value.trim();
    let error = null;

    for (const rule of rules) {
      if (rule === &#039;required&#039; &amp;&amp; !value) {
        error = &#039;This field is required&#039;;
        break;
      }
      if (rule === &#039;email&#039; &amp;&amp; !this.isValidEmail(value)) {
        error = &#039;Invalid email address&#039;;
        break;
      }
      if (rule.startsWith(&#039;min:&#039;)) {
        const min = parseInt(rule.split(&#039;:&#039;)[1]);
        if (value.length &lt; min) {
          error = `Minimum ${min} characters required`;
          break;
        }
      }
      if (rule.startsWith(&#039;max:&#039;)) {
        const max = parseInt(rule.split(&#039;:&#039;)[1]);
        if (value.length &gt; max) {
          error = `Maximum ${max} characters allowed`;
          break;
        }
      }
    }

    this.updateFieldError(input, error);
    return !error;
  }

  updateFieldError(input, error) {
    input.classList.toggle(&#039;invalid&#039;, !!error);
    input.classList.toggle(&#039;valid&#039;, !error);

    let errorDiv = input.nextElementSibling;
    if (errorDiv &amp;&amp; errorDiv.classList.contains(&#039;error&#039;)) {
      errorDiv.remove();
    }

    if (error) {
      this.errors.set(input, error);
      errorDiv = document.createElement(&#039;div&#039;);
      errorDiv.className = &#039;error&#039;;
      errorDiv.textContent = error;
      input.after(errorDiv);
    } else {
      this.errors.delete(input);
    }
  }

  validateAll() {
    let isValid = true;
    this.validators.forEach((rules, input) =&gt; {
      if (!this.validateField(input)) {
        isValid = false;
      }
    });
    return isValid;
  }

  isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  handleSubmit() {
    const formData = new FormData(this.querySelector(&#039;form&#039;));
    this.pan.dispatch(&#039;form:submitted&#039;, Object.fromEntries(formData));
  }
}

customElements.define(&#039;validated-form&#039;, ValidatedForm);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;validated-form&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;label&gt;Email&lt;/label&gt;
    &lt;input type=&quot;email&quot; name=&quot;email&quot; data-validate=&quot;required,email&quot;&gt;
  &lt;/div&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;label&gt;Password&lt;/label&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot; data-validate=&quot;required,min:8&quot;&gt;
  &lt;/div&gt;
&lt;/validated-form&gt;</code></pre>
<h2>Recipe 3: Infinite Scroll List</h2>
<p>Load data progressively as user scrolls.</p>
<pre><code class="language-javascript">class InfiniteList extends HTMLElement {
  constructor() {
    super();
    this.page = 1;
    this.loading = false;
    this.hasMore = true;
  }

  connectedCallback() {
    this.apiEndpoint = this.getAttribute(&#039;api&#039;);
    this.setupIntersectionObserver();
    this.loadMore();
  }

  setupIntersectionObserver() {
    const sentinel = document.createElement(&#039;div&#039;);
    sentinel.className = &#039;scroll-sentinel&#039;;
    this.appendChild(sentinel);

    this.observer = new IntersectionObserver((entries) =&gt; {
      if (entries[0].isIntersecting &amp;&amp; !this.loading &amp;&amp; this.hasMore) {
        this.loadMore();
      }
    }, { threshold: 0.1 });

    this.observer.observe(sentinel);
  }

  async loadMore() {
    this.loading = true;
    this.showLoadingIndicator();

    try {
      const response = await fetch(`${this.apiEndpoint}?page=${this.page}`);
      const data = await response.json();

      if (data.items.length === 0) {
        this.hasMore = false;
        this.hideLoadingIndicator();
        return;
      }

      this.renderItems(data.items);
      this.page++;
    } catch (error) {
      console.error(&#039;Failed to load items:&#039;, error);
      this.pan.dispatch(&#039;error&#039;, { message: &#039;Failed to load items&#039; });
    } finally {
      this.loading = false;
      this.hideLoadingIndicator();
    }
  }

  renderItems(items) {
    const sentinel = this.querySelector(&#039;.scroll-sentinel&#039;);
    items.forEach(item =&gt; {
      const element = this.createItemElement(item);
      this.insertBefore(element, sentinel);
    });
  }

  createItemElement(item) {
    const div = document.createElement(&#039;div&#039;);
    div.className = &#039;list-item&#039;;
    div.innerHTML = `
      &lt;h3&gt;${item.title}&lt;/h3&gt;
      &lt;p&gt;${item.description}&lt;/p&gt;
    `;
    return div;
  }

  showLoadingIndicator() {
    let loader = this.querySelector(&#039;.loader&#039;);
    if (!loader) {
      loader = document.createElement(&#039;div&#039;);
      loader.className = &#039;loader&#039;;
      loader.textContent = &#039;Loading...&#039;;
      this.appendChild(loader);
    }
  }

  hideLoadingIndicator() {
    const loader = this.querySelector(&#039;.loader&#039;);
    if (loader) loader.remove();
  }

  disconnectedCallback() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}

customElements.define(&#039;infinite-list&#039;, InfiniteList);</code></pre>
<h2>Recipe 4: Toast Notification System</h2>
<p>Display temporary user notifications.</p>
<pre><code class="language-javascript">class ToastContainer extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          position: fixed;
          top: 1rem;
          right: 1rem;
          z-index: 10000;
          display: flex;
          flex-direction: column;
          gap: 0.5rem;
          max-width: 400px;
        }
        .toast {
          padding: 1rem 1.5rem;
          border-radius: 0.5rem;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          display: flex;
          align-items: center;
          gap: 0.75rem;
          animation: slideIn 0.3s ease;
        }
        .toast.success { background: #4caf50; color: white; }
        .toast.error { background: #f44336; color: white; }
        .toast.info { background: #2196f3; color: white; }
        .toast.warning { background: #ff9800; color: white; }
        @keyframes slideIn {
          from {
            transform: translateX(100%);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
        .close {
          margin-left: auto;
          cursor: pointer;
          font-size: 1.25rem;
          opacity: 0.8;
        }
        .close:hover { opacity: 1; }
      &lt;/style&gt;
    `;

    this.pan.subscribe(&#039;toast:show&#039;, (event) =&gt; {
      this.showToast(event.detail);
    });
  }

  showToast({ message, type = &#039;info&#039;, duration = 3000 }) {
    const toast = document.createElement(&#039;div&#039;);
    toast.className = `toast ${type}`;
    toast.innerHTML = `
      &lt;span class=&quot;message&quot;&gt;${message}&lt;/span&gt;
      &lt;span class=&quot;close&quot;&gt;&amp;times;&lt;/span&gt;
    `;

    toast.querySelector(&#039;.close&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.removeToast(toast);
    });

    this.shadowRoot.appendChild(toast);

    if (duration &gt; 0) {
      setTimeout(() =&gt; this.removeToast(toast), duration);
    }
  }

  removeToast(toast) {
    toast.style.animation = &#039;slideIn 0.3s ease reverse&#039;;
    setTimeout(() =&gt; toast.remove(), 300);
  }
}

customElements.define(&#039;toast-container&#039;, ToastContainer);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">// Anywhere in your app
this.pan.dispatch(&#039;toast:show&#039;, {
  message: &#039;Settings saved successfully&#039;,
  type: &#039;success&#039;,
  duration: 3000
});</code></pre>
<h2>Recipe 5: Debounced Search Input</h2>
<p>Optimize API calls by debouncing user input.</p>
<pre><code class="language-javascript">class SearchInput extends HTMLElement {
  constructor() {
    super();
    this.debounceTimer = null;
    this.debounceDelay = parseInt(this.getAttribute(&#039;debounce&#039;)) || 300;
  }

  connectedCallback() {
    this.innerHTML = `
      &lt;div class=&quot;search-wrapper&quot;&gt;
        &lt;input type=&quot;search&quot; placeholder=&quot;Search...&quot;&gt;
        &lt;span class=&quot;spinner&quot; style=&quot;display: none;&quot;&gt;[hourglass]&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;results&quot;&gt;&lt;/div&gt;
    `;

    this.input = this.querySelector(&#039;input&#039;);
    this.spinner = this.querySelector(&#039;.spinner&#039;);
    this.resultsContainer = this.querySelector(&#039;.results&#039;);

    this.input.addEventListener(&#039;input&#039;, (e) =&gt; {
      this.handleInput(e.target.value);
    });

    this.pan.subscribe(&#039;search:results&#039;, (event) =&gt; {
      this.displayResults(event.detail);
    });
  }

  handleInput(value) {
    clearTimeout(this.debounceTimer);

    if (!value.trim()) {
      this.resultsContainer.innerHTML = &#039;&#039;;
      return;
    }

    this.showSpinner();

    this.debounceTimer = setTimeout(() =&gt; {
      this.performSearch(value);
    }, this.debounceDelay);
  }

  async performSearch(query) {
    try {
      const apiEndpoint = this.getAttribute(&#039;api&#039;);
      const response = await fetch(`${apiEndpoint}?q=${encodeURIComponent(query)}`);
      const results = await response.json();
      this.pan.dispatch(&#039;search:results&#039;, results);
    } catch (error) {
      console.error(&#039;Search failed:&#039;, error);
    } finally {
      this.hideSpinner();
    }
  }

  displayResults(results) {
    if (results.length === 0) {
      this.resultsContainer.innerHTML = &#039;&lt;div class=&quot;no-results&quot;&gt;No results found&lt;/div&gt;&#039;;
      return;
    }

    this.resultsContainer.innerHTML = results
      .map(result =&gt; `&lt;div class=&quot;result-item&quot;&gt;${result.title}&lt;/div&gt;`)
      .join(&#039;&#039;);
  }

  showSpinner() {
    this.spinner.style.display = &#039;inline&#039;;
  }

  hideSpinner() {
    this.spinner.style.display = &#039;none&#039;;
  }
}

customElements.define(&#039;search-input&#039;, SearchInput);</code></pre>
<h2>Recipe 6: Modal Dialog</h2>
<p>Accessible modal with focus trapping.</p>
<pre><code class="language-javascript">class ModalDialog extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          z-index: 9999;
        }
        :host([open]) { display: block; }
        .backdrop {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.5);
        }
        .modal {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          border-radius: 0.5rem;
          padding: 2rem;
          max-width: 90vw;
          max-height: 90vh;
          overflow: auto;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        .close {
          position: absolute;
          top: 1rem;
          right: 1rem;
          background: none;
          border: none;
          font-size: 1.5rem;
          cursor: pointer;
        }
      &lt;/style&gt;
      &lt;div class=&quot;backdrop&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;modal&quot; role=&quot;dialog&quot; aria-modal=&quot;true&quot;&gt;
        &lt;button class=&quot;close&quot; aria-label=&quot;Close&quot;&gt;&amp;times;&lt;/button&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;

    this.shadowRoot.querySelector(&#039;.backdrop&#039;).addEventListener(&#039;click&#039;, () =&gt; this.close());
    this.shadowRoot.querySelector(&#039;.close&#039;).addEventListener(&#039;click&#039;, () =&gt; this.close());

    this.pan.subscribe(&#039;modal:open&#039;, (event) =&gt; {
      if (event.detail.id === this.id) {
        this.open();
      }
    });
  }

  open() {
    this.setAttribute(&#039;open&#039;, &#039;&#039;);
    this.previousFocus = document.activeElement;
    this.trapFocus();
    document.body.style.overflow = &#039;hidden&#039;;
  }

  close() {
    this.removeAttribute(&#039;open&#039;);
    document.body.style.overflow = &#039;&#039;;
    if (this.previousFocus) {
      this.previousFocus.focus();
    }
    this.pan.dispatch(&#039;modal:closed&#039;, { id: this.id });
  }

  trapFocus() {
    const focusableElements = this.shadowRoot.querySelectorAll(
      &#039;button, [href], input, select, textarea, [tabindex]:not([tabindex=&quot;-1&quot;])&#039;
    );
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    this.keydownHandler = (e) =&gt; {
      if (e.key !== &#039;Tab&#039;) return;

      if (e.shiftKey &amp;&amp; document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      } else if (!e.shiftKey &amp;&amp; document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    };

    this.addEventListener(&#039;keydown&#039;, this.keydownHandler);
    firstElement?.focus();
  }

  disconnectedCallback() {
    if (this.keydownHandler) {
      this.removeEventListener(&#039;keydown&#039;, this.keydownHandler);
    }
  }
}

customElements.define(&#039;modal-dialog&#039;, ModalDialog);</code></pre>
<h2>Recipe 7: State Persistence</h2>
<p>Save and restore component state to localStorage.</p>
<pre><code class="language-javascript">class StatefulComponent extends HTMLElement {
  constructor() {
    super();
    this.storageKey = this.getAttribute(&#039;storage-key&#039;) || &#039;component-state&#039;;
    this.state = this.loadState();
  }

  loadState() {
    try {
      const saved = localStorage.getItem(this.storageKey);
      return saved ? JSON.parse(saved) : this.getDefaultState();
    } catch (error) {
      console.error(&#039;Failed to load state:&#039;, error);
      return this.getDefaultState();
    }
  }

  saveState() {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.state));
      this.pan.dispatch(&#039;state:saved&#039;, { key: this.storageKey });
    } catch (error) {
      console.error(&#039;Failed to save state:&#039;, error);
      this.pan.dispatch(&#039;state:error&#039;, { error: error.message });
    }
  }

  updateState(updates) {
    this.state = { ...this.state, ...updates };
    this.saveState();
    this.render();
  }

  getDefaultState() {
    return {};
  }

  clearState() {
    localStorage.removeItem(this.storageKey);
    this.state = this.getDefaultState();
    this.render();
  }
}</code></pre>
<h2>Recipe 8: Drag and Drop</h2>
<p>Reorderable list with drag-and-drop.</p>
<pre><code class="language-javascript">class DraggableList extends HTMLElement {
  connectedCallback() {
    this.addEventListener(&#039;dragstart&#039;, this.handleDragStart.bind(this));
    this.addEventListener(&#039;dragover&#039;, this.handleDragOver.bind(this));
    this.addEventListener(&#039;drop&#039;, this.handleDrop.bind(this));
    this.addEventListener(&#039;dragend&#039;, this.handleDragEnd.bind(this));

    this.makeItemsDraggable();
  }

  makeItemsDraggable() {
    this.querySelectorAll(&#039;.draggable-item&#039;).forEach(item =&gt; {
      item.setAttribute(&#039;draggable&#039;, &#039;true&#039;);
    });
  }

  handleDragStart(e) {
    if (!e.target.classList.contains(&#039;draggable-item&#039;)) return;
    e.target.classList.add(&#039;dragging&#039;);
    e.dataTransfer.effectAllowed = &#039;move&#039;;
    e.dataTransfer.setData(&#039;text/html&#039;, e.target.innerHTML);
  }

  handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = &#039;move&#039;;

    const dragging = this.querySelector(&#039;.dragging&#039;);
    const afterElement = this.getDragAfterElement(e.clientY);

    if (afterElement == null) {
      this.appendChild(dragging);
    } else {
      this.insertBefore(dragging, afterElement);
    }
  }

  handleDrop(e) {
    e.stopPropagation();
    this.dispatchReorderEvent();
  }

  handleDragEnd(e) {
    e.target.classList.remove(&#039;dragging&#039;);
  }

  getDragAfterElement(y) {
    const draggableElements = [
      ...this.querySelectorAll(&#039;.draggable-item:not(.dragging)&#039;)
    ];

    return draggableElements.reduce((closest, child) =&gt; {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;

      if (offset &lt; 0 &amp;&amp; offset &gt; closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  dispatchReorderEvent() {
    const order = Array.from(this.querySelectorAll(&#039;.draggable-item&#039;))
      .map((item, index) =&gt; ({ index, id: item.dataset.id }));
    this.pan.dispatch(&#039;list:reordered&#039;, order);
  }
}

customElements.define(&#039;draggable-list&#039;, DraggableList);</code></pre>
<h2>Recipe 9: Responsive Image</h2>
<p>Automatically load appropriate image sizes.</p>
<pre><code class="language-javascript">class ResponsiveImage extends HTMLElement {
  connectedCallback() {
    this.sources = JSON.parse(this.getAttribute(&#039;sources&#039;));
    this.alt = this.getAttribute(&#039;alt&#039;) || &#039;&#039;;

    this.render();
    window.addEventListener(&#039;resize&#039;, () =&gt; this.handleResize());
  }

  render() {
    const src = this.selectSource();
    this.innerHTML = `&lt;img src=&quot;${src}&quot; alt=&quot;${this.alt}&quot; loading=&quot;lazy&quot;&gt;`;
  }

  selectSource() {
    const width = window.innerWidth;
    const sorted = Object.entries(this.sources)
      .sort(([a], [b]) =&gt; parseInt(a) - parseInt(b));

    for (const [breakpoint, url] of sorted) {
      if (width &lt;= parseInt(breakpoint)) {
        return url;
      }
    }

    return sorted[sorted.length - 1][1];
  }

  handleResize() {
    clearTimeout(this.resizeTimer);
    this.resizeTimer = setTimeout(() =&gt; {
      const currentSrc = this.querySelector(&#039;img&#039;).src;
      const newSrc = this.selectSource();
      if (currentSrc !== newSrc) {
        this.render();
      }
    }, 250);
  }
}

customElements.define(&#039;responsive-image&#039;, ResponsiveImage);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;responsive-image
  sources=&#039;{&quot;480&quot;: &quot;/img/small.jpg&quot;, &quot;1024&quot;: &quot;/img/medium.jpg&quot;, &quot;1920&quot;: &quot;/img/large.jpg&quot;}&#039;
  alt=&quot;Product photo&quot;&gt;
&lt;/responsive-image&gt;</code></pre>
<h2>Recipe 10: Event Bus Bridge</h2>
<p>Bridge LARC PAN bus events to external systems.</p>
<pre><code class="language-javascript">class EventBridge extends HTMLElement {
  connectedCallback() {
    this.externalSystem = this.getAttribute(&#039;target&#039;);
    this.eventMap = JSON.parse(this.getAttribute(&#039;event-map&#039;) || &#039;{}&#039;);

    Object.keys(this.eventMap).forEach(panEvent =&gt; {
      this.pan.subscribe(panEvent, (event) =&gt; {
        this.bridgeEvent(panEvent, event.detail);
      });
    });
  }

  bridgeEvent(panEvent, data) {
    const externalEvent = this.eventMap[panEvent];

    switch (this.externalSystem) {
      case &#039;analytics&#039;:
        this.sendToAnalytics(externalEvent, data);
        break;
      case &#039;websocket&#039;:
        this.sendToWebSocket(externalEvent, data);
        break;
      case &#039;postmessage&#039;:
        this.sendToParent(externalEvent, data);
        break;
    }
  }

  sendToAnalytics(event, data) {
    if (window.gtag) {
      window.gtag(&#039;event&#039;, event, data);
    }
  }

  sendToWebSocket(event, data) {
    if (this.websocket?.readyState === WebSocket.OPEN) {
      this.websocket.send(JSON.stringify({ type: event, payload: data }));
    }
  }

  sendToParent(event, data) {
    window.parent.postMessage({ type: event, payload: data }, &#039;*&#039;);
  }
}

customElements.define(&#039;event-bridge&#039;, EventBridge);</code></pre>
<h2>Common Patterns</h2>
<h3>Pattern: Component Composition</h3>
<p>Build complex components from simpler ones.</p>
<pre><code class="language-javascript">class UserProfile extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;user-avatar user-id=&quot;${this.getAttribute(&#039;user-id&#039;)}&quot;&gt;&lt;/user-avatar&gt;
      &lt;user-details user-id=&quot;${this.getAttribute(&#039;user-id&#039;)}&quot;&gt;&lt;/user-details&gt;
      &lt;user-actions user-id=&quot;${this.getAttribute(&#039;user-id&#039;)}&quot;&gt;&lt;/user-actions&gt;
    `;
  }
}</code></pre>
<h3>Pattern: Higher-Order Components</h3>
<p>Wrap components with additional functionality.</p>
<pre><code class="language-javascript">function withLoading(ComponentClass) {
  return class extends ComponentClass {
    connectedCallback() {
      this.showLoader();
      super.connectedCallback();
    }

    showLoader() {
      this.innerHTML = &#039;&lt;div class=&quot;loader&quot;&gt;Loading...&lt;/div&gt;&#039;;
    }
  };
}

customElements.define(&#039;user-card&#039;, withLoading(UserCard));</code></pre>
<h3>Pattern: Singleton Services</h3>
<p>Share a single instance across components.</p>
<pre><code class="language-javascript">class DataCache {
  static instance = null;

  static getInstance() {
    if (!DataCache.instance) {
      DataCache.instance = new DataCache();
    }
    return DataCache.instance;
  }

  constructor() {
    this.cache = new Map();
  }

  get(key) {
    return this.cache.get(key);
  }

  set(key, value) {
    this.cache.set(key, value);
  }
}</code></pre>
<h2>Anti-Patterns to Avoid</h2>
<h3>Anti-Pattern: Tight Coupling</h3>
<strong>Bad:</strong>
<pre><code class="language-javascript">class ComponentA extends HTMLElement {
  connectedCallback() {
    document.querySelector(&#039;component-b&#039;).doSomething();
  }
}</code></pre>
<strong>Good:</strong>
<pre><code class="language-javascript">class ComponentA extends HTMLElement {
  connectedCallback() {
    this.pan.dispatch(&#039;action:requested&#039;, { data });
  }
}</code></pre>
<h3>Anti-Pattern: Massive Components</h3>
<strong>Bad:</strong> 500-line components handling everything.
<strong>Good:</strong> Break into focused, single-responsibility components.
<h3>Anti-Pattern: Ignoring Lifecycle</h3>
<strong>Bad:</strong>
<pre><code class="language-javascript">class BadComponent extends HTMLElement {
  constructor() {
    super();
    this.innerHTML = &#039;&lt;div&gt;Content&lt;/div&gt;&#039;; // Too early!
  }
}</code></pre>
<strong>Good:</strong>
<pre><code class="language-javascript">class GoodComponent extends HTMLElement {
  connectedCallback() {
    this.innerHTML = &#039;&lt;div&gt;Content&lt;/div&gt;&#039;;
  }
}</code></pre>
<h3>Anti-Pattern: Manual Memory Leaks</h3>
<strong>Bad:</strong>
<pre><code class="language-javascript">connectedCallback() {
  this.pan.subscribe(&#039;event&#039;, handler);
  // Never unsubscribed!
}</code></pre>
<strong>Good:</strong>
<pre><code class="language-javascript">connectedCallback() {
  this.unsubscribe = this.pan.subscribe(&#039;event&#039;, handler);
}

disconnectedCallback() {
  this.unsubscribe();
}</code></pre>
<p>These recipes provide battle-tested solutions for common scenarios. Adapt them to your needs, understanding the principles behind each pattern. The best code is readable, maintainable, and solves the problem at hand without unnecessary complexity.</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/docs/building-with-larc/appendix-e-recipes-and-patterns.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
</body>
</html>