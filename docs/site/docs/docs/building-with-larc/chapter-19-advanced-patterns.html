<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Advanced Patterns · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Advanced Patterns">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">docs</a> / <a href="#">building-with-larc</a> / <span>chapter-19-advanced-patterns</span>
      </div>
      <article class="docs-content">
        <h1>Advanced Patterns</h1>
<blockquote>"Any sufficiently advanced technology is indistinguishable from magic. Any sufficiently advanced LARC pattern is indistinguishable from over-engineering." — Clarke's Third Law, Revised</blockquote>
<p>You've mastered the basics of LARC. Your components communicate gracefully. Your state management is pristine. Your error handling would make a DevOps engineer weep tears of joy. But now you're ready for the advanced stuff—the patterns that separate the "just building apps" developers from the "architect a scalable micro-frontend ecosystem" developers.</p>
<p>Fair warning: some of these patterns are powerful. Some are clever. Some might be too clever. Use your judgment, and remember that the best code is the code your teammates can understand at 9 AM on a Monday.</p>
<h2>Message Forwarding and Bridging</h2>
<p>Sometimes you need messages from one bus to appear on another. Maybe you're integrating a third-party widget. Maybe you're building a multi-window application. Maybe you just like making things complicated (no judgment).</p>
<h3>Basic Message Forwarding</h3>
<p>Forward messages from one bus to another:</p>
<pre><code class="language-javascript">class MessageBridge extends Component {
  constructor(sourceBus, targetBus, messageTypes) {
    super();
    this.sourceBus = sourceBus;
    this.targetBus = targetBus;
    this.messageTypes = messageTypes || [&#039;*&#039;]; // Forward all by default
  }

  init() {
    this.messageTypes.forEach(type =&gt; {
      this.sourceBus.on(type, (data) =&gt; {
        this.targetBus.emit(type, data);
      });
    });
  }

  render() {
    return null; // Bridges don&#039;t render
  }
}

// Usage
const mainBus = createBus();
const widgetBus = createBus();

// Forward user actions from widget to main app
const bridge = new MessageBridge(
  widgetBus,
  mainBus,
  [&#039;user-click&#039;, &#039;user-input&#039;]
);</code></pre>
<h3>Bidirectional Bridging</h3>
<p>When you need messages flowing both ways:</p>
<pre><code class="language-javascript">class BidirectionalBridge extends Component {
  constructor(busA, busB, config = {}) {
    super();
    this.busA = busA;
    this.busB = busB;
    this.config = {
      aToB: config.aToB || [&#039;*&#039;], // Types to forward A -&gt; B
      bToA: config.bToA || [&#039;*&#039;], // Types to forward B -&gt; A
      transform: config.transform || ((data) =&gt; data), // Transform data
      filter: config.filter || (() =&gt; true) // Filter messages
    };
  }

  init() {
    // Forward A -&gt; B
    this.config.aToB.forEach(type =&gt; {
      this.busA.on(type, (data) =&gt; {
        if (this.config.filter(type, data, &#039;aToB&#039;)) {
          const transformed = this.config.transform(data, &#039;aToB&#039;);
          this.busB.emit(type, transformed);
        }
      });
    });

    // Forward B -&gt; A
    this.config.bToA.forEach(type =&gt; {
      this.busB.on(type, (data) =&gt; {
        if (this.config.filter(type, data, &#039;bToA&#039;)) {
          const transformed = this.config.transform(data, &#039;bToA&#039;);
          this.busA.emit(type, transformed);
        }
      });
    });
  }

  render() {
    return null;
  }
}

// Usage with transformation
const bridge = new BidirectionalBridge(mainBus, widgetBus, {
  aToB: [&#039;theme-changed&#039;, &#039;user-logged-in&#039;],
  bToA: [&#039;widget-action&#039;],
  transform: (data, direction) =&gt; {
    // Add metadata for tracking
    return {
      ...data,
      bridged: true,
      direction,
      timestamp: Date.now()
    };
  },
  filter: (type, data, direction) =&gt; {
    // Don&#039;t forward internal messages
    return !type.startsWith(&#039;internal-&#039;);
  }
});</code></pre>
<h3>Message Translation</h3>
<p>When buses speak different dialects:</p>
<pre><code class="language-javascript">class MessageTranslator extends Component {
  constructor(sourceBus, targetBus, translations) {
    super();
    this.sourceBus = sourceBus;
    this.targetBus = targetBus;
    this.translations = translations;
  }

  init() {
    Object.entries(this.translations).forEach(([sourceType, config]) =&gt; {
      this.sourceBus.on(sourceType, (data) =&gt; {
        const targetType = config.type || sourceType;
        const targetData = config.transform
          ? config.transform(data)
          : data;

        this.targetBus.emit(targetType, targetData);
      });
    });
  }

  render() {
    return null;
  }
}

// Usage: Translate between LARC app and legacy jQuery plugin
const translator = new MessageTranslator(larcBus, jqueryBus, {
  &#039;user-logged-in&#039;: {
    type: &#039;userLogin&#039;, // Different naming convention
    transform: (data) =&gt; ({
      userId: data.id, // Different property names
      userName: data.username,
      timestamp: new Date().toISOString()
    })
  },
  &#039;cart-updated&#039;: {
    type: &#039;cartChange&#039;,
    transform: (data) =&gt; ({
      items: data.cartItems.map(item =&gt; ({
        id: item.productId,
        qty: item.quantity,
        price: item.unitPrice
      }))
    })
  }
});</code></pre>
<h2>Multi-Bus Architectures</h2>
<p>One bus is good. Multiple buses? That's when things get interesting (and complicated).</p>
<h3>Domain-Segregated Buses</h3>
<p>Separate concerns by domain:</p>
<pre><code class="language-javascript">class MultiDomainApp {
  constructor() {
    // Separate buses for different domains
    this.buses = {
      auth: createBus({ namespace: &#039;auth&#039; }),
      cart: createBus({ namespace: &#039;cart&#039; }),
      ui: createBus({ namespace: &#039;ui&#039; }),
      analytics: createBus({ namespace: &#039;analytics&#039; })
    };

    // Create cross-domain bridges
    this.setupBridges();
  }

  setupBridges() {
    // Auth events trigger analytics
    new MessageBridge(
      this.buses.auth,
      this.buses.analytics,
      [&#039;user-logged-in&#039;, &#039;user-logged-out&#039;]
    );

    // Cart events trigger UI updates
    new MessageBridge(
      this.buses.cart,
      this.buses.ui,
      [&#039;cart-updated&#039;]
    );

    // Auth changes affect cart
    this.buses.auth.on(&#039;user-logged-out&#039;, () =&gt; {
      this.buses.cart.emit(&#039;clear-cart&#039;);
    });
  }

  getComponentProps(domain) {
    return {
      bus: this.buses[domain],
      globalBus: this.buses.ui // Some components need global access
    };
  }
}

// Usage
const app = new MultiDomainApp();

class LoginForm extends Component {
  constructor(props) {
    super(props);
    this.authBus = props.bus; // Domain-specific bus
  }

  async handleLogin(username, password) {
    // Emit on auth bus
    this.authBus.emit(&#039;login-attempt&#039;, { username });

    const result = await this.authenticate(username, password);

    if (result.success) {
      this.authBus.emit(&#039;user-logged-in&#039;, {
        userId: result.userId,
        username: username
      });
    }
  }
}

const loginForm = new LoginForm(app.getComponentProps(&#039;auth&#039;));</code></pre>
<h3>Hierarchical Bus Structure</h3>
<p>Create parent-child bus relationships:</p>
<pre><code class="language-javascript">class HierarchicalBus {
  constructor(parent = null) {
    this.parent = parent;
    this.children = new Set();
    this.handlers = new Map();

    if (parent) {
      parent.children.add(this);
    }
  }

  emit(type, data, options = {}) {
    const { bubble = false, propagate = false } = options;

    // Handle locally
    this._emitLocal(type, data);

    // Bubble up to parent
    if (bubble &amp;&amp; this.parent) {
      this.parent.emit(type, data, { bubble: true });
    }

    // Propagate down to children
    if (propagate) {
      this.children.forEach(child =&gt; {
        child.emit(type, data, { propagate: true });
      });
    }
  }

  _emitLocal(type, data) {
    const handlers = this.handlers.get(type) || [];
    handlers.forEach(handler =&gt; handler(data));

    const wildcardHandlers = this.handlers.get(&#039;*&#039;) || [];
    wildcardHandlers.forEach(handler =&gt; handler(type, data));
  }

  on(type, handler) {
    if (!this.handlers.has(type)) {
      this.handlers.set(type, []);
    }
    this.handlers.get(type).push(handler);
  }

  destroy() {
    if (this.parent) {
      this.parent.children.delete(this);
    }
    this.children.clear();
    this.handlers.clear();
  }
}

// Usage: App with nested modules
const appBus = new HierarchicalBus();
const moduleBus = new HierarchicalBus(appBus);
const subModuleBus = new HierarchicalBus(moduleBus);

// Local event
subModuleBus.emit(&#039;button-clicked&#039;, { id: 123 });

// Bubble up to parent
subModuleBus.emit(&#039;critical-error&#039;, { error: &#039;Oh no!&#039; }, { bubble: true });

// Propagate down to all children
appBus.emit(&#039;theme-changed&#039;, { theme: &#039;dark&#039; }, { propagate: true });</code></pre>
<h2>Backend Integration Strategies</h2>
<p>LARC runs in the browser, but your data lives on a server. Let's build bridges between these two worlds.</p>
<h3>API Gateway Component</h3>
<p>Centralize all API calls in one component:</p>
<pre><code class="language-javascript">class APIGateway extends Component {
  init() {
    this.state = {
      baseURL: &#039;/api&#039;,
      token: localStorage.getItem(&#039;authToken&#039;),
      requestQueue: [],
      online: navigator.onLine
    };

    // Listen for API requests
    this.on(&#039;api-request&#039;, this.handleRequest);
    this.on(&#039;auth-token-updated&#039;, (data) =&gt; {
      this.state.token = data.token;
    });

    // Handle online/offline
    window.addEventListener(&#039;online&#039;, () =&gt; {
      this.state.online = true;
      this.flushQueue();
    });
    window.addEventListener(&#039;offline&#039;, () =&gt; {
      this.state.online = false;
    });
  }

  async handleRequest({ method, endpoint, data, requestId }) {
    if (!this.state.online) {
      this.state.requestQueue.push({ method, endpoint, data, requestId });
      this.emit(&#039;api-offline&#039;, { requestId });
      return;
    }

    try {
      const response = await fetch(`${this.state.baseURL}${endpoint}`, {
        method,
        headers: {
          &#039;Content-Type&#039;: &#039;application/json&#039;,
          &#039;Authorization&#039;: `Bearer ${this.state.token}`
        },
        body: data ? JSON.stringify(data) : undefined
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();

      this.emit(&#039;api-success&#039;, {
        requestId,
        endpoint,
        result
      });

    } catch (error) {
      this.emit(&#039;api-error&#039;, {
        requestId,
        endpoint,
        error: error.message
      });
    }
  }

  async flushQueue() {
    const queue = [...this.state.requestQueue];
    this.state.requestQueue = [];

    for (const request of queue) {
      await this.handleRequest(request);
    }
  }

  render() {
    return null;
  }
}

// Usage in other components
class UserProfile extends Component {
  loadUserData(userId) {
    const requestId = crypto.randomUUID();

    this.emit(&#039;api-request&#039;, {
      method: &#039;GET&#039;,
      endpoint: `/users/${userId}`,
      requestId
    });

    this.once(`api-success`, (data) =&gt; {
      if (data.requestId === requestId) {
        this.state.user = data.result;
      }
    });

    this.once(`api-error`, (data) =&gt; {
      if (data.requestId === requestId) {
        this.state.error = data.error;
      }
    });
  }
}</code></pre>
<h3>WebSocket Integration</h3>
<p>Real-time bidirectional communication:</p>
<pre><code class="language-javascript">class WebSocketBridge extends Component {
  init() {
    this.state = {
      connected: false,
      reconnectAttempts: 0,
      maxReconnectAttempts: 5
    };

    this.ws = null;
    this.connect();

    // Listen for outgoing messages
    this.on(&#039;ws-send&#039;, this.sendMessage);
    this.on(&#039;ws-disconnect&#039;, () =&gt; this.disconnect());
  }

  connect() {
    const protocol = window.location.protocol === &#039;https:&#039; ? &#039;wss:&#039; : &#039;ws:&#039;;
    const wsURL = `${protocol}//${window.location.host}/ws`;

    this.ws = new WebSocket(wsURL);

    this.ws.onopen = () =&gt; {
      this.state.connected = true;
      this.state.reconnectAttempts = 0;
      this.emit(&#039;ws-connected&#039;);
    };

    this.ws.onmessage = (event) =&gt; {
      try {
        const message = JSON.parse(event.data);
        // Emit as LARC message
        this.emit(message.type, message.data);
      } catch (error) {
        console.error(&#039;Invalid WebSocket message:&#039;, event.data);
      }
    };

    this.ws.onclose = () =&gt; {
      this.state.connected = false;
      this.emit(&#039;ws-disconnected&#039;);
      this.attemptReconnect();
    };

    this.ws.onerror = (error) =&gt; {
      this.emit(&#039;ws-error&#039;, { error });
    };
  }

  sendMessage({ type, data }) {
    if (this.ws &amp;&amp; this.state.connected) {
      this.ws.send(JSON.stringify({ type, data }));
    } else {
      console.warn(&#039;WebSocket not connected, message queued&#039;);
      // Could implement a queue here
    }
  }

  attemptReconnect() {
    if (this.state.reconnectAttempts &gt;= this.state.maxReconnectAttempts) {
      this.emit(&#039;ws-reconnect-failed&#039;);
      return;
    }

    this.state.reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, this.state.reconnectAttempts), 30000);

    setTimeout(() =&gt; {
      this.connect();
    }, delay);
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  render() {
    return null;
  }
}

// Usage
class ChatComponent extends Component {
  init() {
    this.state = { messages: [] };

    // Receive messages from WebSocket
    this.on(&#039;chat-message&#039;, (data) =&gt; {
      this.state.messages.push(data);
    });
  }

  sendMessage(text) {
    // Send via WebSocket
    this.emit(&#039;ws-send&#039;, {
      type: &#039;chat-message&#039;,
      data: {
        text,
        userId: this.getCurrentUserId(),
        timestamp: Date.now()
      }
    });
  }
}</code></pre>
<h3>GraphQL Integration</h3>
<p>For those who prefer structured queries:</p>
<pre><code class="language-javascript">class GraphQLClient extends Component {
  init() {
    this.state = {
      endpoint: &#039;/graphql&#039;,
      cache: new Map()
    };

    this.on(&#039;graphql-query&#039;, this.executeQuery);
    this.on(&#039;graphql-mutation&#039;, this.executeMutation);
  }

  async executeQuery({ query, variables, requestId, cache = true }) {
    // Check cache
    const cacheKey = JSON.stringify({ query, variables });
    if (cache &amp;&amp; this.state.cache.has(cacheKey)) {
      this.emit(&#039;graphql-result&#039;, {
        requestId,
        data: this.state.cache.get(cacheKey),
        cached: true
      });
      return;
    }

    try {
      const response = await fetch(this.state.endpoint, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify({ query, variables })
      });

      const result = await response.json();

      if (result.errors) {
        throw new Error(result.errors[0].message);
      }

      // Cache result
      if (cache) {
        this.state.cache.set(cacheKey, result.data);
      }

      this.emit(&#039;graphql-result&#039;, {
        requestId,
        data: result.data
      });

    } catch (error) {
      this.emit(&#039;graphql-error&#039;, {
        requestId,
        error: error.message
      });
    }
  }

  async executeMutation({ mutation, variables, requestId }) {
    try {
      const response = await fetch(this.state.endpoint, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify({ query: mutation, variables })
      });

      const result = await response.json();

      if (result.errors) {
        throw new Error(result.errors[0].message);
      }

      // Invalidate cache on mutation
      this.state.cache.clear();

      this.emit(&#039;graphql-result&#039;, {
        requestId,
        data: result.data
      });

    } catch (error) {
      this.emit(&#039;graphql-error&#039;, {
        requestId,
        error: error.message
      });
    }
  }

  render() {
    return null;
  }
}

// Usage
class UserList extends Component {
  loadUsers() {
    const requestId = crypto.randomUUID();

    this.emit(&#039;graphql-query&#039;, {
      query: `
        query GetUsers($limit: Int) {
          users(limit: $limit) {
            id
            username
            email
          }
        }
      `,
      variables: { limit: 10 },
      requestId
    });

    this.once(&#039;graphql-result&#039;, (data) =&gt; {
      if (data.requestId === requestId) {
        this.state.users = data.data.users;
      }
    });
  }
}</code></pre>
<h2>Micro-Frontends with LARC</h2>
<p>Split your monolith into independently deployable micro-frontends. It's like microservices, but with more JavaScript!</p>
<h3>Module Federation Pattern</h3>
<p>Load remote LARC modules dynamically:</p>
<pre><code class="language-javascript">class MicroFrontendLoader extends Component {
  init() {
    this.state = {
      modules: new Map(),
      loading: new Set()
    };

    this.on(&#039;load-module&#039;, this.loadModule);
    this.on(&#039;unload-module&#039;, this.unloadModule);
  }

  async loadModule({ name, url, props }) {
    if (this.state.modules.has(name)) {
      console.warn(`Module ${name} already loaded`);
      return;
    }

    if (this.state.loading.has(name)) {
      console.warn(`Module ${name} is already loading`);
      return;
    }

    this.state.loading.add(name);
    this.emit(&#039;module-loading&#039;, { name });

    try {
      // Dynamic import
      const module = await import(/* webpackIgnore: true */ url);

      // Initialize module with props
      const instance = new module.default(props);

      this.state.modules.set(name, instance);
      this.state.loading.delete(name);

      this.emit(&#039;module-loaded&#039;, { name });

    } catch (error) {
      this.state.loading.delete(name);
      this.emit(&#039;module-load-error&#039;, {
        name,
        error: error.message
      });
    }
  }

  unloadModule({ name }) {
    const module = this.state.modules.get(name);
    if (module &amp;&amp; module.destroy) {
      module.destroy();
    }
    this.state.modules.delete(name);
    this.emit(&#039;module-unloaded&#039;, { name });
  }

  render() {
    return html`
      &lt;div class=&quot;micro-frontend-container&quot;&gt;
        ${Array.from(this.state.modules.entries()).map(([name, module]) =&gt; html`
          &lt;div key=${name} class=&quot;module-wrapper&quot; data-module=${name}&gt;
            ${module.render ? module.render() : &#039;&#039;}
          &lt;/div&gt;
        `)}
      &lt;/div&gt;
    `;
  }
}

// Usage: Load shopping cart from different server
loader.receive(&#039;load-module&#039;, {
  name: &#039;shopping-cart&#039;,
  url: &#039;https://cdn.example.com/modules/cart.js&#039;,
  props: {
    bus: sharedBus,
    apiEndpoint: &#039;/api/cart&#039;
  }
});</code></pre>
<h3>Shell Application Pattern</h3>
<p>Create a shell that hosts multiple micro-frontends:</p>
<pre><code class="language-javascript">class MicroFrontendShell extends Component {
  init() {
    this.state = {
      activeModule: null,
      modules: {
        &#039;dashboard&#039;: {
          url: &#039;/modules/dashboard.js&#039;,
          title: &#039;Dashboard&#039;
        },
        &#039;products&#039;: {
          url: &#039;/modules/products.js&#039;,
          title: &#039;Products&#039;
        },
        &#039;checkout&#039;: {
          url: &#039;/modules/checkout.js&#039;,
          title: &#039;Checkout&#039;
        }
      }
    };

    this.loader = new MicroFrontendLoader({ bus: this.bus });
    this.on(&#039;navigate-to-module&#039;, this.navigateToModule);
  }

  async navigateToModule({ module }) {
    // Unload previous module
    if (this.state.activeModule) {
      this.emit(&#039;unload-module&#039;, { name: this.state.activeModule });
    }

    // Load new module
    const config = this.state.modules[module];
    if (config) {
      await this.emit(&#039;load-module&#039;, {
        name: module,
        url: config.url,
        props: {
          bus: this.bus,
          navigate: (to) =&gt; this.navigateToModule({ module: to })
        }
      });

      this.state.activeModule = module;
    }
  }

  render() {
    return html`
      &lt;div class=&quot;shell&quot;&gt;
        &lt;nav class=&quot;shell-nav&quot;&gt;
          ${Object.entries(this.state.modules).map(([key, config]) =&gt; html`
            &lt;button
              key=${key}
              class=${this.state.activeModule === key ? &#039;active&#039; : &#039;&#039;}
              onclick=${() =&gt; this.navigateToModule({ module: key })}
            &gt;
              ${config.title}
            &lt;/button&gt;
          `)}
        &lt;/nav&gt;
        &lt;main class=&quot;shell-content&quot;&gt;
          ${this.loader.render()}
        &lt;/main&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h2>Plugin Systems</h2>
<p>Let users extend your application with their own components.</p>
<h3>Plugin Registry</h3>
<pre><code class="language-javascript">class PluginRegistry extends Component {
  init() {
    this.state = {
      plugins: new Map(),
      hooks: new Map()
    };

    this.on(&#039;register-plugin&#039;, this.registerPlugin);
    this.on(&#039;unregister-plugin&#039;, this.unregisterPlugin);
    this.on(&#039;execute-hook&#039;, this.executeHook);
  }

  registerPlugin({ id, plugin }) {
    if (this.state.plugins.has(id)) {
      throw new Error(`Plugin ${id} already registered`);
    }

    // Validate plugin interface
    if (!plugin.init || typeof plugin.init !== &#039;function&#039;) {
      throw new Error(&#039;Plugin must have an init() method&#039;);
    }

    this.state.plugins.set(id, plugin);

    // Register plugin hooks
    if (plugin.hooks) {
      Object.entries(plugin.hooks).forEach(([hookName, handler]) =&gt; {
        if (!this.state.hooks.has(hookName)) {
          this.state.hooks.set(hookName, []);
        }
        this.state.hooks.get(hookName).push({ id, handler });
      });
    }

    // Initialize plugin
    plugin.init({
      bus: this.bus,
      emit: (type, data) =&gt; this.emit(type, data)
    });

    this.emit(&#039;plugin-registered&#039;, { id });
  }

  unregisterPlugin({ id }) {
    const plugin = this.state.plugins.get(id);
    if (!plugin) return;

    // Remove hooks
    this.state.hooks.forEach((handlers, hookName) =&gt; {
      this.state.hooks.set(
        hookName,
        handlers.filter(h =&gt; h.id !== id)
      );
    });

    // Cleanup plugin
    if (plugin.destroy) {
      plugin.destroy();
    }

    this.state.plugins.delete(id);
    this.emit(&#039;plugin-unregistered&#039;, { id });
  }

  async executeHook({ hook, data }) {
    const handlers = this.state.hooks.get(hook) || [];

    let result = data;

    for (const { id, handler } of handlers) {
      try {
        result = await handler(result);
      } catch (error) {
        console.error(`Plugin ${id} hook ${hook} failed:`, error);
      }
    }

    return result;
  }

  render() {
    return null;
  }
}

// Example plugin
const analyticsPlugin = {
  init({ bus, emit }) {
    this.bus = bus;
    this.emit = emit;

    // Listen to all messages
    bus.on(&#039;*&#039;, (type, data) =&gt; {
      this.trackEvent(type, data);
    });
  },

  hooks: {
    &#039;before-submit&#039;: async (formData) =&gt; {
      // Validate or transform data
      console.log(&#039;Analytics: Form submission&#039;, formData);
      return formData;
    },

    &#039;after-navigation&#039;: async (route) =&gt; {
      // Track page view
      console.log(&#039;Analytics: Page view&#039;, route);
      return route;
    }
  },

  trackEvent(type, data) {
    // Send to analytics service
    if (window.gtag) {
      window.gtag(&#039;event&#039;, type, data);
    }
  },

  destroy() {
    console.log(&#039;Analytics plugin destroyed&#039;);
  }
};

// Register plugin
registry.receive(&#039;register-plugin&#039;, {
  id: &#039;analytics&#039;,
  plugin: analyticsPlugin
});

// Use hooks
const formData = { name: &#039;Alice&#039;, email: &#039;alice@example.com&#039; };
registry.receive(&#039;execute-hook&#039;, {
  hook: &#039;before-submit&#039;,
  data: formData
}).then(result =&gt; {
  console.log(&#039;After hook:&#039;, result);
});</code></pre>
<h2>Middleware Patterns</h2>
<p>Intercept and transform messages as they flow through your application.</p>
<h3>Message Middleware</h3>
<pre><code class="language-javascript">class MessageMiddleware extends Component {
  init() {
    this.state = {
      middlewares: []
    };

    this.on(&#039;register-middleware&#039;, this.registerMiddleware);

    // Intercept all messages
    this.interceptBus();
  }

  registerMiddleware({ middleware, priority = 0 }) {
    this.state.middlewares.push({ middleware, priority });

    // Sort by priority (higher first)
    this.state.middlewares.sort((a, b) =&gt; b.priority - a.priority);
  }

  interceptBus() {
    const originalEmit = this.bus.emit.bind(this.bus);

    this.bus.emit = async (type, data) =&gt; {
      let context = {
        type,
        data,
        timestamp: Date.now(),
        stopped: false
      };

      // Run through middleware chain
      for (const { middleware } of this.state.middlewares) {
        context = await middleware(context);

        if (context.stopped) {
          return; // Stop propagation
        }
      }

      // Emit transformed message
      originalEmit(context.type, context.data);
    };
  }

  render() {
    return null;
  }
}

// Example middleware: Logging
const loggingMiddleware = async (context) =&gt; {
  console.log(`[Middleware] ${context.type}`, context.data);
  return context;
};

// Example middleware: Rate limiting
const rateLimitMiddleware = (() =&gt; {
  const limits = new Map();

  return async (context) =&gt; {
    const key = context.type;
    const now = Date.now();
    const limit = limits.get(key) || { count: 0, resetAt: now + 1000 };

    if (now &gt; limit.resetAt) {
      limit.count = 0;
      limit.resetAt = now + 1000;
    }

    limit.count++;

    if (limit.count &gt; 10) {
      console.warn(`Rate limit exceeded for ${key}`);
      context.stopped = true;
    }

    limits.set(key, limit);
    return context;
  };
})();

// Example middleware: Transform
const transformMiddleware = async (context) =&gt; {
  // Add metadata to all messages
  context.data = {
    ...context.data,
    _meta: {
      timestamp: context.timestamp,
      version: &#039;1.0&#039;
    }
  };
  return context;
};

// Register middleware
middleware.receive(&#039;register-middleware&#039;, {
  middleware: loggingMiddleware,
  priority: 100
});

middleware.receive(&#039;register-middleware&#039;, {
  middleware: rateLimitMiddleware,
  priority: 90
});

middleware.receive(&#039;register-middleware&#039;, {
  middleware: transformMiddleware,
  priority: 80
});</code></pre>
<h3>Async Middleware with Error Handling</h3>
<pre><code class="language-javascript">class AsyncMiddleware extends Component {
  init() {
    this.state = {
      middlewares: []
    };
  }

  async runMiddleware(context) {
    try {
      for (const middleware of this.state.middlewares) {
        context = await middleware(context);

        if (context.stopped) {
          break;
        }
      }

      return context;

    } catch (error) {
      console.error(&#039;Middleware error:&#039;, error);

      // Emit error event
      this.emit(&#039;middleware-error&#039;, {
        error: error.message,
        context
      });

      // Stop propagation on error
      context.stopped = true;
      return context;
    }
  }
}

// Example: Authentication middleware
const authMiddleware = async (context) =&gt; {
  const protectedMessages = [&#039;api-request&#039;, &#039;user-action&#039;];

  if (protectedMessages.includes(context.type)) {
    const token = localStorage.getItem(&#039;authToken&#039;);

    if (!token) {
      console.warn(&#039;Authentication required&#039;);
      context.stopped = true;

      // Redirect to login
      setTimeout(() =&gt; {
        bus.emit(&#039;navigate&#039;, { route: &#039;/login&#039; });
      }, 0);
    }
  }

  return context;
};</code></pre>
<h2>Conclusion</h2>
<p>These advanced patterns are powerful tools in your LARC toolkit. Use them judiciously. Not every application needs a multi-bus architecture or a plugin system. But when you do need them, you'll be glad you have them.</p>
<p>Remember: the goal is to build maintainable, scalable applications—not to use every pattern just because you can. Choose patterns that solve real problems in your codebase, and your future self (and your teammates) will thank you.</p>
<p>In the next chapter, we'll take your LARC application from development to production, covering deployment strategies, performance optimization, and how to sleep soundly knowing your app is running smoothly in the wild.</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/docs/building-with-larc/chapter-19-advanced-patterns.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
</body>
</html>