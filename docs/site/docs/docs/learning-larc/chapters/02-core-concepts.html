<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chapter 2: Core Concepts · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Chapter 2: Core Concepts">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">docs</a> / <a href="#">learning-larc</a> / <a href="#">chapters</a> / <span>02-core-concepts</span>
      </div>
      <article class="docs-content">
        <h1>Chapter 2: Core Concepts</h1>
<p>Now that you understand LARC's philosophy, let's explore the technical foundation that makes it work. This chapter introduces the core concepts you'll use throughout the book: Web Components, the PAN bus, event-driven architecture, and the component lifecycle.</p>
<p>Don't worry if some of these concepts are new to you. We'll build understanding progressively, starting with the basics and working toward more sophisticated patterns.</p>
<h2>Web Components Refresher</h2>
<p>!<a href="../images/01-architecture-overview-1.png"><strong>Figure 2.1:</strong> LARC High-Level Architecture</a></p>
<strong><em>Figure 2.1:</strong> LARC High-Level Architecture</em>
<p>Web Components are a suite of browser APIs that let you create custom, reusable HTML elements. Unlike framework components, Web Components are browser standards supported natively across all modern browsers.</p>
<h3>The Three Pillars</h3>
<p>Web Components rest on three main technologies:</p>
<p>#### 1. Custom Elements</p>
<p>!<a href="../images/02-component-structure-2.png"><strong>Figure 2.2:</strong> Web Component Anatomy</a></p>
<strong><em>Figure 2.2:</strong> Web Component Anatomy</em>
<p>Custom Elements let you define new HTML tags with custom behavior:</p>
<pre><code class="language-javascript">// Define a custom element
class HelloWorld extends HTMLElement {
  connectedCallback() {
    this.textContent = &#039;Hello, World!&#039;;
  }
}

// Register it
customElements.define(&#039;hello-world&#039;, HelloWorld);</code></pre>
<p>Now you can use <code><hello-world></hello-world></code> in your HTML, and it works like any built-in element.</p>
<strong>Key Points:</strong>
<ul><li>Element names must contain a hyphen (e.g., <code>my-component</code>, not <code>mycomponent</code>)</li>
<li>Custom elements inherit from <code>HTMLElement</code> or another HTML element</li>
<li>They have lifecycle callbacks for creation, connection, and removal</li>
</ul>
#### 2. Shadow DOM
<p>!<a href="../images/02-component-structure-4.png"><strong>Figure 2.3:</strong> Shadow DOM Tree Structure</a></p>
<strong><em>Figure 2.3:</strong> Shadow DOM Tree Structure</em>
<p>!<a href="../images/02-component-structure-4.png"><strong>Figure 2.4:</strong> Shadow DOM Tree Structure</a>
<strong><em>Figure 2.4:</strong> Shadow DOM Tree Structure</em></p>
<p>Shadow DOM provides style and markup encapsulation:</p>
<pre><code class="language-javascript">class FancyButton extends HTMLElement {
  constructor() {
    super();
    // Create shadow root
    this.attachShadow({ mode: &#039;open&#039; });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button {
          background: blue;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
        }
      &lt;/style&gt;
      &lt;button&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/button&gt;
    `;
  }
}

customElements.define(&#039;fancy-button&#039;, FancyButton);</code></pre>
<p>The styles inside Shadow DOM don't leak out, and external styles don't leak in:</p>
<pre><code class="language-html">&lt;!-- This button is blue (from shadow DOM) --&gt;
&lt;fancy-button&gt;Click Me&lt;/fancy-button&gt;

&lt;!-- This button is not affected by fancy-button&#039;s styles --&gt;
&lt;button&gt;Regular Button&lt;/button&gt;

&lt;style&gt;
  /* This won&#039;t affect fancy-button&#039;s internal button */
  button { background: red; }
&lt;/style&gt;</code></pre>
<strong>Key Points:</strong>
<ul><li>Shadow DOM creates an isolated scope for styles and DOM</li>
<li>Use <code><slot></code> elements to project content from light DOM into shadow DOM</li>
<li><code>mode: 'open'</code> makes shadow root accessible via <code>element.shadowRoot</code></li>
</ul>
#### 3. HTML Templates
<p>Templates define reusable chunks of markup that aren't rendered until activated:</p>
<pre><code class="language-html">&lt;template id=&quot;card-template&quot;&gt;
  &lt;style&gt;
    .card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 16px;
    }
  &lt;/style&gt;
  &lt;div class=&quot;card&quot;&gt;
    &lt;h2 class=&quot;title&quot;&gt;&lt;/h2&gt;
    &lt;p class=&quot;content&quot;&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  class SimpleCard extends HTMLElement {
    connectedCallback() {
      const template = document.getElementById(&#039;card-template&#039;);
      const clone = template.content.cloneNode(true);

      clone.querySelector(&#039;.title&#039;).textContent = this.getAttribute(&#039;title&#039;);
      clone.querySelector(&#039;.content&#039;).textContent = this.getAttribute(&#039;content&#039;);

      this.attachShadow({ mode: &#039;open&#039; });
      this.shadowRoot.appendChild(clone);
    }
  }

  customElements.define(&#039;simple-card&#039;, SimpleCard);
&lt;/script&gt;</code></pre>
<strong>Key Points:</strong>
<ul><li>Template content is inert (scripts don't run, images don't load)</li>
<li>Templates can be defined in HTML or created programmatically</li>
<li>Clone template content before using it</li>
</ul>
<h3>Web Components vs Framework Components</h3>
<p>It's worth understanding how Web Components differ from framework components:</p>
<p>| Aspect | Web Components | React Components |
|--------|---------------|------------------|
| <strong>Definition</strong> | Browser standard | Library-specific |
| <strong>Syntax</strong> | JavaScript classes | JSX or functions |
| <strong>Lifecycle</strong> | Native callbacks | Virtual DOM lifecycle |
| <strong>Reusability</strong> | Works everywhere | Requires React |
| <strong>Build step</strong> | Optional | Required (for JSX) |
| <strong>Encapsulation</strong> | Shadow DOM | CSS Modules/CSS-in-JS |</p>
<p>Both approaches have their place. Web Components excel at true reusability and standards-based development. Framework components often provide better ergonomics within their specific ecosystem.</p>
<p>LARC chooses Web Components because they align with the "standards first" principle.</p>
<h2>The Page Area Network (PAN)</h2>
<p>!<a href="../images/01-architecture-overview-2.png"><strong>Figure 2.4:</strong> Component Communication Flow</a></p>
<strong><em>Figure 2.4:</strong> Component Communication Flow</em>
<p>The Page Area Network, or PAN bus, is LARC's event-driven communication system. It's inspired by microservices architecture but designed for browser components.</p>
<h3>The Problem It Solves</h3>
<p>In a traditional component tree, communication flows up and down:</p>
<pre><code class="language-plaintext">App
├── Header
│   └── UserMenu
│       └── LogoutButton
└── Content
    └── UserProfile</code></pre>
<p>If <code>LogoutButton</code> needs to notify <code>UserProfile</code> that the user logged out, you have several options:</p>
<li><strong>Pass callbacks down</strong> through props (prop drilling)</li>
<li><strong>Lift state up</strong> to a common ancestor</li>
<li><strong>Use context</strong> or global state</li>
<li><strong>Dispatch custom events</strong> that bubble up</li>
<p>Each approach has tradeoffs. Prop drilling creates tight coupling. Global state makes testing harder. Event bubbling is limited by DOM structure.</p>
<h3>The PAN Bus Approach</h3>
<p>The PAN bus provides a <strong>decoupled pub/sub system</strong>:</p>
<pre><code class="language-javascript">// LogoutButton publishes an event
pan.publish(&#039;user.logout&#039;, { userId: 123 });

// UserProfile subscribes to events (anywhere in the app)
pan.subscribe(&#039;user.logout&#039;, (data) =&gt; {
  console.log(&#039;User logged out:&#039;, data.userId);
  this.clearUserData();
});</code></pre>
<p>Components don't need to know about each other. They communicate through topics (like <code>'user.logout'</code>) with no direct coupling.</p>
<h3>Topic Namespaces</h3>
<p>Topics use dot notation for organization:</p>
<pre><code class="language-javascript">&#039;user.login&#039;          // User logged in
&#039;user.logout&#039;         // User logged out
&#039;user.profile.update&#039; // Profile was updated

&#039;cart.item.add&#039;       // Item added to cart
&#039;cart.item.remove&#039;    // Item removed
&#039;cart.checkout&#039;       // Checkout initiated

&#039;app.theme.change&#039;    // Theme changed
&#039;app.error&#039;           // Application error</code></pre>
<p>You can subscribe to specific topics or use wildcards:</p>
<pre><code class="language-javascript">// Specific topic
pan.subscribe(&#039;user.login&#039;, handler);

// Wildcard (all user events)
pan.subscribe(&#039;user.*&#039;, handler);

// All events (useful for debugging)
pan.subscribe(&#039;*&#039;, handler);</code></pre>
<h3>Message Patterns</h3>
<p>The PAN bus supports several messaging patterns:</p>
<p>#### 1. Fire and Forget</p>
<p>Most common pattern. Publish a message and continue:</p>
<pre><code class="language-javascript">pan.publish(&#039;notification.show&#039;, {
  type: &#039;success&#039;,
  message: &#039;Saved successfully&#039;
});</code></pre>
<p>#### 2. Request/Response</p>
<p>Publish a message and wait for a response:</p>
<pre><code class="language-javascript">const result = await pan.request(&#039;api.fetch&#039;, {
  url: &#039;/api/users&#039;,
  method: &#039;GET&#039;
});</code></pre>
<p>A subscriber handles the request and returns data:</p>
<pre><code class="language-javascript">pan.respond(&#039;api.fetch&#039;, async (data) =&gt; {
  const response = await fetch(data.url, { method: data.method });
  return response.json();
});</code></pre>
<p>#### 3. State Broadcast</p>
<p>Publish state changes that multiple components need:</p>
<pre><code class="language-javascript">// Theme switcher publishes
pan.publish(&#039;app.theme.change&#039;, { theme: &#039;dark&#039; });

// Multiple components subscribe
class Header extends HTMLElement {
  connectedCallback() {
    pan.subscribe(&#039;app.theme.change&#039;, ({ theme }) =&gt; {
      this.applyTheme(theme);
    });
  }
}

class Sidebar extends HTMLElement {
  connectedCallback() {
    pan.subscribe(&#039;app.theme.change&#039;, ({ theme }) =&gt; {
      this.applyTheme(theme);
    });
  }
}</code></pre>
<h3>Why PAN Bus?</h3>
<p>The PAN bus provides several advantages:</p>
<strong>Loose Coupling</strong>
Components don't need references to each other. Add or remove components without changing others.
<strong>Testability</strong>
Test components in isolation. Mock the bus or test actual pub/sub behavior.
<strong>Debuggability</strong>
Subscribe to <code>'*'</code> to log all messages. Visualize message flow easily.
<strong>Scalability</strong>
Add new features by subscribing to existing topics. No need to modify existing code.
<strong>Flexibility</strong>
Mix different communication patterns (events, requests, broadcasts) as needed.
<h2>Event-Driven Architecture</h2>
<p>LARC applications use event-driven architecture (EDA) at multiple levels:</p>
<h3>Browser Events</h3>
<p>Standard DOM events for user interaction:</p>
<pre><code class="language-javascript">class ClickCounter extends HTMLElement {
  constructor() {
    super();
    this.count = 0;
  }

  connectedCallback() {
    this.innerHTML = `
      &lt;button id=&quot;btn&quot;&gt;Clicked ${this.count} times&lt;/button&gt;
    `;

    this.querySelector(&#039;#btn&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.count++;
      this.querySelector(&#039;#btn&#039;).textContent = `Clicked ${this.count} times`;
    });
  }
}</code></pre>
<h3>Custom Events</h3>
<p>Components can dispatch custom events for parent components:</p>
<pre><code class="language-javascript">class ColorPicker extends HTMLElement {
  selectColor(color) {
    // Dispatch custom event
    this.dispatchEvent(new CustomEvent(&#039;colorchange&#039;, {
      detail: { color },
      bubbles: true,
      composed: true  // Cross shadow DOM boundary
    }));
  }
}

// Parent can listen
document.querySelector(&#039;color-picker&#039;).addEventListener(&#039;colorchange&#039;, (e) =&gt; {
  console.log(&#039;Selected color:&#039;, e.detail.color);
});</code></pre>
<h3>PAN Bus Events</h3>
<p>For cross-component communication:</p>
<pre><code class="language-javascript">class SearchBox extends HTMLElement {
  handleInput(value) {
    pan.publish(&#039;search.query&#039;, { query: value });
  }
}

class SearchResults extends HTMLElement {
  connectedCallback() {
    pan.subscribe(&#039;search.query&#039;, ({ query }) =&gt; {
      this.search(query);
    });
  }
}</code></pre>
<h3>When to Use Each</h3>
<strong>Use DOM Events when:</strong>
<ul><li>Handling user interactions (click, input, focus, etc.)</li>
<li>Communication is parent-child relationship</li>
<li>Following HTML semantics matters</li>
</ul>
<strong>Use Custom Events when:</strong>
<ul><li>Component needs to notify parent/ancestors</li>
<li>Event should bubble up the DOM tree</li>
<li>Mimicking native element behavior</li>
</ul>
<strong>Use PAN Bus when:</strong>
<ul><li>Components are not in parent-child relationship</li>
<li>Multiple unrelated components need the same data</li>
<li>Decoupling is more important than DOM semantics</li>
<li>Building cross-cutting concerns (logging, analytics, etc.)</li>
</ul>
<h2>State Management Philosophy</h2>
<p>LARC takes a pragmatic approach to state management: use the simplest solution that works, then scale up if needed.</p>
<h3>State Hierarchy</h3>
<p>State can exist at different levels:</p>
<p>#### 1. Component-Local State</p>
<p>State that only matters to one component:</p>
<pre><code class="language-javascript">class TodoItem extends HTMLElement {
  constructor() {
    super();
    this.completed = false;  // Local state
  }

  toggle() {
    this.completed = !this.completed;
    this.render();
  }

  render() {
    this.classList.toggle(&#039;completed&#039;, this.completed);
  }
}</code></pre>
<strong>When to use:</strong> UI state, temporary values, component-specific configuration.
<p>#### 2. Shared State</p>
<p>State that multiple components need:</p>
<pre><code class="language-javascript">// Simple shared state object
const appState = {
  user: null,
  theme: &#039;light&#039;,
  notifications: []
};

// Components read from it
class UserMenu extends HTMLElement {
  connectedCallback() {
    this.render(appState.user);
  }
}

// Components write to it and notify via PAN
function updateTheme(theme) {
  appState.theme = theme;
  pan.publish(&#039;app.theme.change&#039;, { theme });
}</code></pre>
<strong>When to use:</strong> Application-wide settings, user data, feature flags.
<p>#### 3. Persistent State</p>
<p>State that survives page reloads:</p>
<pre><code class="language-javascript">class TodoList extends HTMLElement {
  loadTodos() {
    const saved = localStorage.getItem(&#039;todos&#039;);
    return saved ? JSON.parse(saved) : [];
  }

  saveTodos(todos) {
    localStorage.setItem(&#039;todos&#039;, JSON.stringify(todos));
  }
}</code></pre>
<strong>When to use:</strong> User preferences, draft content, offline data.
<p>#### 4. Server State</p>
<p>State that comes from and syncs with a server:</p>
<pre><code class="language-javascript">class UserProfile extends HTMLElement {
  async loadProfile() {
    const response = await fetch(&#039;/api/profile&#039;);
    this.profile = await response.json();
    this.render();
  }

  async saveProfile(updates) {
    await fetch(&#039;/api/profile&#039;, {
      method: &#039;PUT&#039;,
      body: JSON.stringify(updates)
    });
  }
}</code></pre>
<strong>When to use:</strong> Database records, API data, real-time updates.
<h3>Reactive State (Optional)</h3>
<p>For more complex state needs, LARC provides reactive patterns using JavaScript Proxies:</p>
<pre><code class="language-javascript">function createStore(initialState) {
  const listeners = new Set();

  const state = new Proxy(initialState, {
    set(target, property, value) {
      target[property] = value;
      listeners.forEach(fn =&gt; fn(property, value));
      return true;
    }
  });

  return {
    state,
    subscribe(fn) {
      listeners.add(fn);
      return () =&gt; listeners.delete(fn);
    }
  };
}

// Usage
const store = createStore({ count: 0 });

class Counter extends HTMLElement {
  connectedCallback() {
    // Subscribe to changes
    this.unsubscribe = store.subscribe((prop, value) =&gt; {
      if (prop === &#039;count&#039;) this.render();
    });

    this.render();
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  render() {
    this.textContent = `Count: ${store.state.count}`;
  }
}

// Update state (automatically notifies subscribers)
store.state.count++;</code></pre>
<p>This is similar to MobX or Vue's reactivity, but built with standard JavaScript.</p>
<h2>Module System</h2>
<p>LARC uses ES Modules, the native JavaScript module system.</p>
<h3>Import/Export Basics</h3>
<p>Export from a module:</p>
<pre><code class="language-javascript">// components/button.js
export class PanButton extends HTMLElement {
  // ...
}

export const BUTTON_TYPES = [&#039;primary&#039;, &#039;secondary&#039;, &#039;danger&#039;];

export default PanButton;</code></pre>
<p>Import into another module:</p>
<pre><code class="language-javascript">// app.js
import PanButton, { BUTTON_TYPES } from &#039;./components/button.js&#039;;

// Or import everything
import * as Button from &#039;./components/button.js&#039;;</code></pre>
<h3>Import Maps</h3>
<p>Import Maps let you define aliases for module paths:</p>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@2.0.0/pan.mjs&quot;,
    &quot;@larcjs/ui&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/components@2.0.0/pan-card.mjs&quot;,
    &quot;app/&quot;: &quot;/src/&quot;,
    &quot;components/&quot;: &quot;/&quot;
  }
}
&lt;/script&gt;

&lt;script type=&quot;module&quot;&gt;
  // Use aliases
  import { pan } from &#039;@larcjs/core&#039;;
  import { PanButton } from &#039;@larcjs/ui&#039;;
  import { Header } from &#039;components/header.js&#039;;
&lt;/script&gt;</code></pre>
<p>This is similar to webpack's resolve aliases, but it's a browser standard.</p>
<h3>Module Organization</h3>
<p>A typical LARC project structure:</p>
<pre><code class="language-plaintext">src/
├── components/
│   ├── header.js
│   ├── footer.js
│   └── sidebar.js
├── lib/
│   ├── api.js
│   ├── auth.js
│   └── utils.js
├── pages/
│   ├── home.js
│   ├── dashboard.js
│   └── profile.js
└── app.js</code></pre>
<p>Each file is a module with clear responsibilities:</p>
<pre><code class="language-javascript">// src/lib/api.js
export async function fetchJSON(url, options = {}) {
  const response = await fetch(url, {
    ...options,
    headers: {
      &#039;Content-Type&#039;: &#039;application/json&#039;,
      ...options.headers
    }
  });

  if (!response.ok) {
    throw new Error(`API error: ${response.status}`);
  }

  return response.json();
}

// src/components/user-list.js
import { fetchJSON } from &#039;../lib/api.js&#039;;

export class UserList extends HTMLElement {
  async connectedCallback() {
    const users = await fetchJSON(&#039;/api/users&#039;);
    this.render(users);
  }
}

customElements.define(&#039;user-list&#039;, UserList);</code></pre>
<h2>The Component Lifecycle</h2>
<p>Understanding the component lifecycle is essential for building robust LARC applications.</p>
<h3>Lifecycle Callbacks</h3>
<p>Web Components provide several lifecycle callbacks:</p>
<p>#### constructor()</p>
<p>Called when an instance is created:</p>
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  constructor() {
    // MUST call super() first
    super();

    // Initialize instance properties
    this.count = 0;
    this.data = null;

    // Attach shadow DOM if needed
    this.attachShadow({ mode: &#039;open&#039; });

    // DON&#039;T access attributes or children here
    // They might not be set yet
  }
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Always call <code>super()</code> first</li>
<li>Initialize instance properties</li>
<li>Attach shadow DOM</li>
<li>Don't access attributes, children, or parent elements</li>
<li>Don't render here (use <code>connectedCallback</code> instead)</li>
</ul>
#### connectedCallback()
<p>Called when the element is inserted into the DOM:</p>
<pre><code class="language-javascript">connectedCallback() {
  // Now it&#039;s safe to access attributes, children, parent
  const title = this.getAttribute(&#039;title&#039;);

  // Render initial content
  this.render();

  // Add event listeners
  this.addEventListener(&#039;click&#039;, this.handleClick);

  // Fetch data
  this.loadData();

  // Subscribe to PAN events
  this.unsubscribe = pan.subscribe(&#039;data.update&#039;, this.handleUpdate);
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Render initial content</li>
<li>Add event listeners</li>
<li>Subscribe to events</li>
<li>Fetch initial data</li>
<li>Can be called multiple times if element is moved</li>
</ul>
#### disconnectedCallback()
<p>Called when the element is removed from the DOM:</p>
<pre><code class="language-javascript">disconnectedCallback() {
  // Clean up event listeners
  this.removeEventListener(&#039;click&#039;, this.handleClick);

  // Unsubscribe from PAN events
  if (this.unsubscribe) {
    this.unsubscribe();
  }

  // Cancel pending operations
  if (this.fetchController) {
    this.fetchController.abort();
  }

  // Clear timers
  if (this.timer) {
    clearInterval(this.timer);
  }
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Remove event listeners to prevent memory leaks</li>
<li>Unsubscribe from PAN events</li>
<li>Cancel pending async operations</li>
<li>Clear timers and intervals</li>
</ul>
#### attributeChangedCallback(name, oldValue, newValue)
<p>Called when observed attributes change:</p>
<pre><code class="language-javascript">static get observedAttributes() {
  return [&#039;title&#039;, &#039;count&#039;, &#039;active&#039;];
}

attributeChangedCallback(name, oldValue, newValue) {
  // Called for each observed attribute that changes
  if (name === &#039;title&#039;) {
    this.updateTitle(newValue);
  } else if (name === &#039;count&#039;) {
    this.updateCount(Number(newValue));
  } else if (name === &#039;active&#039;) {
    this.updateActive(newValue !== null);
  }
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Only observe attributes you actually use</li>
<li>Convert string values to appropriate types</li>
<li>Handle null/undefined values</li>
<li>Update only what changed (don't re-render everything)</li>
</ul>
#### adoptedCallback()
<p>Called when the element is moved to a new document (rare):</p>
<pre><code class="language-javascript">adoptedCallback() {
  // Usually not needed
  // Called when element is moved between documents
  // (e.g., iframe scenarios)
}</code></pre>
<h3>Complete Lifecycle Example</h3>
<p>Here's a full component showing proper lifecycle management:</p>
<pre><code class="language-javascript">class DataTable extends HTMLElement {
  // Define which attributes to observe
  static get observedAttributes() {
    return [&#039;url&#039;, &#039;page-size&#039;];
  }

  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });

    // Initialize state
    this.data = [];
    this.pageSize = 10;
    this.currentPage = 1;
  }

  async connectedCallback() {
    // Initial render
    this.render();

    // Load data if URL is set
    const url = this.getAttribute(&#039;url&#039;);
    if (url) {
      await this.loadData(url);
    }

    // Subscribe to events
    this.unsubscribePan = pan.subscribe(&#039;table.refresh&#039;, () =&gt; {
      this.refresh();
    });

    // Set up event listeners
    this.addEventListener(&#039;page-change&#039;, this.handlePageChange);
  }

  disconnectedCallback() {
    // Clean up subscriptions
    if (this.unsubscribePan) {
      this.unsubscribePan();
    }

    // Remove event listeners
    this.removeEventListener(&#039;page-change&#039;, this.handlePageChange);

    // Cancel pending fetch
    if (this.fetchController) {
      this.fetchController.abort();
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    if (name === &#039;url&#039; &amp;&amp; newValue) {
      this.loadData(newValue);
    } else if (name === &#039;page-size&#039;) {
      this.pageSize = Number(newValue) || 10;
      this.render();
    }
  }

  async loadData(url) {
    // Cancel previous fetch if any
    if (this.fetchController) {
      this.fetchController.abort();
    }

    this.fetchController = new AbortController();

    try {
      const response = await fetch(url, {
        signal: this.fetchController.signal
      });
      this.data = await response.json();
      this.render();
    } catch (error) {
      if (error.name !== &#039;AbortError&#039;) {
        console.error(&#039;Failed to load data:&#039;, error);
      }
    }
  }

  render() {
    // Render logic here
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
      &lt;/style&gt;
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Status&lt;/th&gt;&lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          ${this.data.map(row =&gt; `
            &lt;tr&gt;
              &lt;td&gt;${row.id}&lt;/td&gt;
              &lt;td&gt;${row.name}&lt;/td&gt;
              &lt;td&gt;${row.status}&lt;/td&gt;
            &lt;/tr&gt;
          `).join(&#039;&#039;)}
        &lt;/tbody&gt;
      &lt;/table&gt;
    `;
  }

  handlePageChange = (event) =&gt; {
    this.currentPage = event.detail.page;
    this.render();
  }

  async refresh() {
    const url = this.getAttribute(&#039;url&#039;);
    if (url) {
      await this.loadData(url);
    }
  }
}

customElements.define(&#039;data-table&#039;, DataTable);</code></pre>
<h2>Summary</h2>
<p>This chapter introduced LARC's core concepts:</p>
<ul><li><strong>Web Components</strong> provide standard, reusable elements with Custom Elements, Shadow DOM, and Templates</li>
<li><strong>The PAN Bus</strong> enables decoupled pub/sub communication between components</li>
<li><strong>Event-Driven Architecture</strong> uses DOM events, custom events, and PAN messages for different scenarios</li>
<li><strong>State Management</strong> starts simple (local state) and scales to shared, persistent, and server state</li>
<li><strong>ES Modules</strong> organize code with standard imports/exports and import maps</li>
<li><strong>Component Lifecycle</strong> provides callbacks for creation, connection, attribute changes, and cleanup</li>
</ul>
In the next chapter, we'll put these concepts into practice by setting up a development environment and building your first LARC application.
<hr>
<h2>Key Takeaways</h2>
<ul><li>Web Components are browser standards, not framework abstractions</li>
<li>Shadow DOM provides true style encapsulation</li>
<li>The PAN bus decouples components through pub/sub messaging</li>
<li>Use the simplest state management that works, then scale up</li>
<li>ES Modules and Import Maps replace build-time bundling</li>
<li>Proper lifecycle management prevents bugs and memory leaks</li>
<li>Components should be self-contained but composable</li>
</ul>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/docs/learning-larc/chapters/02-core-concepts.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
</body>
</html>