<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- CRITICAL: Load theme BEFORE CSS to prevent flash -->
  <script src="../../../../../playground/theme-init.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Forms and User Input · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Forms and User Input">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">building-with-larc</a> / <span>chapter-10-forms-and-user-input</span>
      </div>
      <article class="docs-content">
        <h1>Forms and User Input</h1>
<em>In which we learn to gracefully accept data from users, who are simultaneously your application's reason for existing and its greatest source of chaos</em>
<p>Forms are the primary way users communicate with your application, which means they're simultaneously the most important and most frustrating part of web development. Users will try to enter phone numbers with letters, paste entire essays into single-line inputs, and somehow manage to submit forms with negative quantities of products. Your job is to accept their input gracefully while gently steering them toward something your database can actually process.</p>
<p>In this chapter, we'll explore LARC's approach to form handling, from basic input binding to sophisticated schema-driven forms. We'll cover validation strategies that don't make users want to throw their keyboards, file upload patterns that work with modern APIs, and rich text editing that goes beyond the humble textarea. By the end, you'll be equipped to build forms that are both powerful and forgiving—a rare combination in web development.</p>
<h2>The Fundamentals of Form Handling</h2>
<p>Let's start with the basics. A form in LARC is just HTML with JavaScript event handling—no magic, no framework-specific syntax, just the web platform doing what it does best.</p>
<h3>Basic Form Structure</h3>
<p>Here's a simple login form:</p>
<pre><code class="language-javascript">class LoginForm extends LarcComponent {
  constructor() {
    super();
    this.error = null;
    this.loading = false;
  }

  async handleSubmit(event) {
    event.preventDefault(); // Prevent default form submission

    this.loading = true;
    this.error = null;
    this.render();

    const formData = new FormData(event.target);
    const credentials = {
      email: formData.get(&#039;email&#039;),
      password: formData.get(&#039;password&#039;),
      remember: formData.get(&#039;remember&#039;) === &#039;on&#039;
    };

    try {
      const response = await fetch(&#039;/api/login&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify(credentials)
      });

      if (response.ok) {
        const user = await response.json();
        this.handleLoginSuccess(user);
      } else {
        const error = await response.json();
        this.error = error.message;
      }
    } catch (err) {
      this.error = &#039;Network error. Please try again.&#039;;
    } finally {
      this.loading = false;
      this.render();
    }
  }

  handleLoginSuccess(user) {
    localStorage.setItem(&#039;user&#039;, JSON.stringify(user));
    navigate(&#039;/dashboard&#039;);
  }

  template() {
    return `
      &lt;form class=&quot;login-form&quot; onsubmit=&quot;this.handleSubmit(event)&quot;&gt;
        &lt;h2&gt;Login&lt;/h2&gt;

        ${this.error ? `&lt;div class=&quot;error&quot;&gt;${this.error}&lt;/div&gt;` : &#039;&#039;}

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;
          &lt;input
            type=&quot;email&quot;
            id=&quot;email&quot;
            name=&quot;email&quot;
            required
            autocomplete=&quot;email&quot;&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;
          &lt;input
            type=&quot;password&quot;
            id=&quot;password&quot;
            name=&quot;password&quot;
            required
            autocomplete=&quot;current-password&quot;&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt;
            Remember me
          &lt;/label&gt;
        &lt;/div&gt;

        &lt;button type=&quot;submit&quot; ?disabled=&quot;${this.loading}&quot;&gt;
          ${this.loading ? &#039;Logging in...&#039; : &#039;Login&#039;}
        &lt;/button&gt;
      &lt;/form&gt;
    `;
  }
}</code></pre>
<p>This example demonstrates several key patterns:</p>
<li><strong><code>preventDefault()</code></strong> stops the browser's default form submission</li>
<li><strong><code>FormData</code></strong> extracts values from form inputs</li>
<li><strong>Loading states</strong> provide feedback during async operations</li>
<li><strong>Error handling</strong> displays meaningful messages to users</li>
<h3>Two-Way Data Binding</h3>
<p>Sometimes you want form inputs to sync with component state in real-time. While LARC doesn't provide automatic two-way binding (we're not monsters), you can implement it easily:</p>
<pre><code class="language-javascript">class UserProfile extends LarcComponent {
  constructor() {
    super();
    this.user = {
      name: &#039;&#039;,
      email: &#039;&#039;,
      bio: &#039;&#039;,
      notifications: true
    };
  }

  handleInput(field, event) {
    this.user[field] = event.target.value;
    // Optionally re-render to update dependent UI
    this.updatePreview();
  }

  handleCheckbox(field, event) {
    this.user[field] = event.target.checked;
    this.render();
  }

  updatePreview() {
    const preview = this.querySelector(&#039;.profile-preview&#039;);
    if (preview) {
      preview.textContent = this.user.bio || &#039;No bio provided&#039;;
    }
  }

  template() {
    return `
      &lt;form class=&quot;profile-form&quot;&gt;
        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
          &lt;input
            type=&quot;text&quot;
            id=&quot;name&quot;
            value=&quot;${this.user.name}&quot;
            oninput=&quot;this.handleInput(&#039;name&#039;, event)&quot;&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;
          &lt;input
            type=&quot;email&quot;
            id=&quot;email&quot;
            value=&quot;${this.user.email}&quot;
            oninput=&quot;this.handleInput(&#039;email&#039;, event)&quot;&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;bio&quot;&gt;Bio&lt;/label&gt;
          &lt;textarea
            id=&quot;bio&quot;
            rows=&quot;4&quot;
            oninput=&quot;this.handleInput(&#039;bio&#039;, event)&quot;&gt;${this.user.bio}&lt;/textarea&gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label&gt;
            &lt;input
              type=&quot;checkbox&quot;
              ?checked=&quot;${this.user.notifications}&quot;
              onchange=&quot;this.handleCheckbox(&#039;notifications&#039;, event)&quot;&gt;
            Email notifications
          &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class=&quot;profile-preview&quot;&gt;
          ${this.user.bio || &#039;No bio provided&#039;}
        &lt;/div&gt;
      &lt;/form&gt;
    `;
  }
}</code></pre>
<h2>Validation Strategies</h2>
<p>Validation is like parenting: you need to set boundaries, but if you're too strict, everyone ends up frustrated. The key is providing helpful guidance without being obnoxious about it.</p>
<h3>HTML5 Built-in Validation</h3>
<p>Start with HTML5's native validation attributes—they're free, accessible, and work even if JavaScript fails:</p>
<pre><code class="language-html">&lt;input type=&quot;email&quot; required
       pattern=&quot;[^@]+@[^@]+\.[^@]+&quot;
       title=&quot;Please enter a valid email address&quot;&gt;

&lt;input type=&quot;tel&quot;
       pattern=&quot;[0-9]{3}-[0-9]{3}-[0-9]{4}&quot;
       placeholder=&quot;123-456-7890&quot;
       title=&quot;Format: 123-456-7890&quot;&gt;

&lt;input type=&quot;number&quot;
       min=&quot;1&quot;
       max=&quot;100&quot;
       step=&quot;1&quot;&gt;

&lt;input type=&quot;url&quot;
       placeholder=&quot;https://example.com&quot;&gt;

&lt;input type=&quot;text&quot;
       minlength=&quot;3&quot;
       maxlength=&quot;50&quot;
       required&gt;</code></pre>
<h3>Custom Validation Logic</h3>
<p>For more sophisticated validation, implement custom logic:</p>
<pre><code class="language-javascript">class RegistrationForm extends LarcComponent {
  constructor() {
    super();
    this.errors = {};
    this.touched = {};
  }

  validateEmail(email) {
    if (!email) {
      return &#039;Email is required&#039;;
    }
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return &#039;Please enter a valid email address&#039;;
    }
    return null;
  }

  validatePassword(password) {
    if (!password) {
      return &#039;Password is required&#039;;
    }
    if (password.length &lt; 8) {
      return &#039;Password must be at least 8 characters&#039;;
    }
    if (!/[A-Z]/.test(password)) {
      return &#039;Password must contain at least one uppercase letter&#039;;
    }
    if (!/[a-z]/.test(password)) {
      return &#039;Password must contain at least one lowercase letter&#039;;
    }
    if (!/[0-9]/.test(password)) {
      return &#039;Password must contain at least one number&#039;;
    }
    return null;
  }

  validatePasswordConfirm(password, confirm) {
    if (!confirm) {
      return &#039;Please confirm your password&#039;;
    }
    if (password !== confirm) {
      return &#039;Passwords do not match&#039;;
    }
    return null;
  }

  validateField(field, value, allValues = {}) {
    switch (field) {
      case &#039;email&#039;:
        return this.validateEmail(value);
      case &#039;password&#039;:
        return this.validatePassword(value);
      case &#039;passwordConfirm&#039;:
        return this.validatePasswordConfirm(allValues.password, value);
      default:
        return null;
    }
  }

  handleBlur(field, event) {
    this.touched[field] = true;
    const error = this.validateField(field, event.target.value, this.getFormValues());
    this.errors[field] = error;
    this.render();
  }

  handleSubmit(event) {
    event.preventDefault();

    const values = this.getFormValues();
    const newErrors = {};

    // Validate all fields
    Object.keys(values).forEach(field =&gt; {
      const error = this.validateField(field, values[field], values);
      if (error) {
        newErrors[field] = error;
      }
    });

    if (Object.keys(newErrors).length &gt; 0) {
      this.errors = newErrors;
      this.touched = Object.keys(values).reduce((acc, key) =&gt; {
        acc[key] = true;
        return acc;
      }, {});
      this.render();
      return;
    }

    // Form is valid, submit it
    this.submitRegistration(values);
  }

  getFormValues() {
    const form = this.querySelector(&#039;form&#039;);
    const formData = new FormData(form);
    return {
      email: formData.get(&#039;email&#039;),
      password: formData.get(&#039;password&#039;),
      passwordConfirm: formData.get(&#039;passwordConfirm&#039;)
    };
  }

  template() {
    return `
      &lt;form onsubmit=&quot;this.handleSubmit(event)&quot;&gt;
        &lt;div class=&quot;form-group ${this.errors.email &amp;&amp; this.touched.email ? &#039;error&#039; : &#039;&#039;}&quot;&gt;
          &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;
          &lt;input
            type=&quot;email&quot;
            id=&quot;email&quot;
            name=&quot;email&quot;
            onblur=&quot;this.handleBlur(&#039;email&#039;, event)&quot;&gt;
          ${this.errors.email &amp;&amp; this.touched.email ?
            `&lt;span class=&quot;error-message&quot;&gt;${this.errors.email}&lt;/span&gt;` : &#039;&#039;}
        &lt;/div&gt;

        &lt;div class=&quot;form-group ${this.errors.password &amp;&amp; this.touched.password ? &#039;error&#039; : &#039;&#039;}&quot;&gt;
          &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;
          &lt;input
            type=&quot;password&quot;
            id=&quot;password&quot;
            name=&quot;password&quot;
            onblur=&quot;this.handleBlur(&#039;password&#039;, event)&quot;&gt;
          ${this.errors.password &amp;&amp; this.touched.password ?
            `&lt;span class=&quot;error-message&quot;&gt;${this.errors.password}&lt;/span&gt;` : &#039;&#039;}
        &lt;/div&gt;

        &lt;div class=&quot;form-group ${this.errors.passwordConfirm &amp;&amp; this.touched.passwordConfirm ? &#039;error&#039; : &#039;&#039;}&quot;&gt;
          &lt;label for=&quot;passwordConfirm&quot;&gt;Confirm Password&lt;/label&gt;
          &lt;input
            type=&quot;password&quot;
            id=&quot;passwordConfirm&quot;
            name=&quot;passwordConfirm&quot;
            onblur=&quot;this.handleBlur(&#039;passwordConfirm&#039;, event)&quot;&gt;
          ${this.errors.passwordConfirm &amp;&amp; this.touched.passwordConfirm ?
            `&lt;span class=&quot;error-message&quot;&gt;${this.errors.passwordConfirm}&lt;/span&gt;` : &#039;&#039;}
        &lt;/div&gt;

        &lt;button type=&quot;submit&quot;&gt;Register&lt;/button&gt;
      &lt;/form&gt;
    `;
  }
}</code></pre>
<h3>Debounced Validation</h3>
<p>For fields that require server-side validation (like username availability), debounce the requests:</p>
<pre><code class="language-javascript">class UsernameField extends LarcComponent {
  constructor() {
    super();
    this.username = &#039;&#039;;
    this.checking = false;
    this.available = null;
    this.debounceTimer = null;
  }

  handleInput(event) {
    this.username = event.target.value;
    this.available = null; // Reset availability

    clearTimeout(this.debounceTimer);

    if (this.username.length &gt;= 3) {
      this.checking = true;
      this.render();

      this.debounceTimer = setTimeout(() =&gt; {
        this.checkAvailability(this.username);
      }, 500); // Wait 500ms after user stops typing
    } else {
      this.checking = false;
      this.render();
    }
  }

  async checkAvailability(username) {
    try {
      const response = await fetch(`/api/check-username?username=${encodeURIComponent(username)}`);
      const data = await response.json();
      this.available = data.available;
    } catch (err) {
      console.error(&#039;Error checking username:&#039;, err);
    } finally {
      this.checking = false;
      this.render();
    }
  }

  template() {
    return `
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt;
        &lt;input
          type=&quot;text&quot;
          id=&quot;username&quot;
          value=&quot;${this.username}&quot;
          oninput=&quot;this.handleInput(event)&quot;
          minlength=&quot;3&quot;
          maxlength=&quot;20&quot;&gt;

        ${this.checking ? &#039;&lt;span class=&quot;checking&quot;&gt;Checking...&lt;/span&gt;&#039; : &#039;&#039;}

        ${this.available === true ?
          &#039;&lt;span class=&quot;success&quot;&gt;[v] Available&lt;/span&gt;&#039; : &#039;&#039;}

        ${this.available === false ?
          &#039;&lt;span class=&quot;error&quot;&gt;[x] Username taken&lt;/span&gt;&#039; : &#039;&#039;}
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h2>Schema-Driven Forms</h2>
<p>For complex forms, manually writing validation for each field becomes tedious. Schema-driven forms define the structure and rules in data, then generate the UI automatically.</p>
<h3>Defining a Schema</h3>
<pre><code class="language-javascript">const productSchema = {
  name: {
    type: &#039;text&#039;,
    label: &#039;Product Name&#039;,
    required: true,
    minLength: 3,
    maxLength: 100
  },
  description: {
    type: &#039;textarea&#039;,
    label: &#039;Description&#039;,
    required: true,
    minLength: 10,
    rows: 5
  },
  category: {
    type: &#039;select&#039;,
    label: &#039;Category&#039;,
    required: true,
    options: [
      { value: &#039;electronics&#039;, label: &#039;Electronics&#039; },
      { value: &#039;clothing&#039;, label: &#039;Clothing&#039; },
      { value: &#039;food&#039;, label: &#039;Food &amp; Beverage&#039; },
      { value: &#039;other&#039;, label: &#039;Other&#039; }
    ]
  },
  price: {
    type: &#039;number&#039;,
    label: &#039;Price&#039;,
    required: true,
    min: 0.01,
    step: 0.01,
    prefix: &#039;$&#039;
  },
  inStock: {
    type: &#039;checkbox&#039;,
    label: &#039;In Stock&#039;,
    defaultValue: true
  },
  tags: {
    type: &#039;text&#039;,
    label: &#039;Tags (comma-separated)&#039;,
    placeholder: &#039;organic, gluten-free, local&#039;
  }
};</code></pre>
<h3>Schema Form Component</h3>
<pre><code class="language-javascript">class SchemaForm extends LarcComponent {
  constructor(schema, initialValues = {}) {
    super();
    this.schema = schema;
    this.values = { ...initialValues };
    this.errors = {};
    this.touched = {};
  }

  handleInput(field, event) {
    const fieldSchema = this.schema[field];

    if (fieldSchema.type === &#039;checkbox&#039;) {
      this.values[field] = event.target.checked;
    } else {
      this.values[field] = event.target.value;
    }

    // Clear error when user starts correcting
    if (this.errors[field]) {
      delete this.errors[field];
      this.render();
    }
  }

  handleBlur(field) {
    this.touched[field] = true;
    const error = this.validateField(field);
    if (error) {
      this.errors[field] = error;
      this.render();
    }
  }

  validateField(field) {
    const value = this.values[field];
    const fieldSchema = this.schema[field];

    if (fieldSchema.required &amp;&amp; !value) {
      return `${fieldSchema.label} is required`;
    }

    if (fieldSchema.minLength &amp;&amp; value.length &lt; fieldSchema.minLength) {
      return `${fieldSchema.label} must be at least ${fieldSchema.minLength} characters`;
    }

    if (fieldSchema.maxLength &amp;&amp; value.length &gt; fieldSchema.maxLength) {
      return `${fieldSchema.label} must be no more than ${fieldSchema.maxLength} characters`;
    }

    if (fieldSchema.min !== undefined &amp;&amp; parseFloat(value) &lt; fieldSchema.min) {
      return `${fieldSchema.label} must be at least ${fieldSchema.min}`;
    }

    if (fieldSchema.max !== undefined &amp;&amp; parseFloat(value) &gt; fieldSchema.max) {
      return `${fieldSchema.label} must be no more than ${fieldSchema.max}`;
    }

    if (fieldSchema.pattern &amp;&amp; !new RegExp(fieldSchema.pattern).test(value)) {
      return fieldSchema.patternMessage || `${fieldSchema.label} is invalid`;
    }

    return null;
  }

  validateAll() {
    const newErrors = {};

    Object.keys(this.schema).forEach(field =&gt; {
      const error = this.validateField(field);
      if (error) {
        newErrors[field] = error;
      }
    });

    return newErrors;
  }

  renderField(fieldName) {
    const field = this.schema[fieldName];
    const value = this.values[fieldName] ?? field.defaultValue ?? &#039;&#039;;
    const error = this.errors[fieldName] &amp;&amp; this.touched[fieldName];

    const commonAttrs = `
      id=&quot;${fieldName}&quot;
      name=&quot;${fieldName}&quot;
      onblur=&quot;this.handleBlur(&#039;${fieldName}&#039;)&quot;
    `;

    let input;

    switch (field.type) {
      case &#039;textarea&#039;:
        input = `
          &lt;textarea ${commonAttrs}
                    rows=&quot;${field.rows || 3}&quot;
                    oninput=&quot;this.handleInput(&#039;${fieldName}&#039;, event)&quot;
                    ${field.required ? &#039;required&#039; : &#039;&#039;}&gt;${value}&lt;/textarea&gt;
        `;
        break;

      case &#039;select&#039;:
        input = `
          &lt;select ${commonAttrs}
                  onchange=&quot;this.handleInput(&#039;${fieldName}&#039;, event)&quot;
                  ${field.required ? &#039;required&#039; : &#039;&#039;}&gt;
            &lt;option value=&quot;&quot;&gt;Select ${field.label}&lt;/option&gt;
            ${field.options.map(opt =&gt; `
              &lt;option value=&quot;${opt.value}&quot; ${value === opt.value ? &#039;selected&#039; : &#039;&#039;}&gt;
                ${opt.label}
              &lt;/option&gt;
            `).join(&#039;&#039;)}
          &lt;/select&gt;
        `;
        break;

      case &#039;checkbox&#039;:
        input = `
          &lt;input type=&quot;checkbox&quot; ${commonAttrs}
                 onchange=&quot;this.handleInput(&#039;${fieldName}&#039;, event)&quot;
                 ${value ? &#039;checked&#039; : &#039;&#039;}&gt;
        `;
        break;

      case &#039;number&#039;:
        input = `
          ${field.prefix || &#039;&#039;}
          &lt;input type=&quot;number&quot; ${commonAttrs}
                 value=&quot;${value}&quot;
                 oninput=&quot;this.handleInput(&#039;${fieldName}&#039;, event)&quot;
                 ${field.min !== undefined ? `min=&quot;${field.min}&quot;` : &#039;&#039;}
                 ${field.max !== undefined ? `max=&quot;${field.max}&quot;` : &#039;&#039;}
                 ${field.step !== undefined ? `step=&quot;${field.step}&quot;` : &#039;&#039;}
                 ${field.required ? &#039;required&#039; : &#039;&#039;}&gt;
          ${field.suffix || &#039;&#039;}
        `;
        break;

      default: // text, email, tel, url, etc.
        input = `
          &lt;input type=&quot;${field.type}&quot; ${commonAttrs}
                 value=&quot;${value}&quot;
                 oninput=&quot;this.handleInput(&#039;${fieldName}&#039;, event)&quot;
                 ${field.placeholder ? `placeholder=&quot;${field.placeholder}&quot;` : &#039;&#039;}
                 ${field.required ? &#039;required&#039; : &#039;&#039;}&gt;
        `;
    }

    return `
      &lt;div class=&quot;form-group ${error ? &#039;error&#039; : &#039;&#039;}&quot;&gt;
        &lt;label for=&quot;${fieldName}&quot;&gt;${field.label}&lt;/label&gt;
        ${input}
        ${error ? `&lt;span class=&quot;error-message&quot;&gt;${this.errors[fieldName]}&lt;/span&gt;` : &#039;&#039;}
      &lt;/div&gt;
    `;
  }

  handleSubmit(event) {
    event.preventDefault();

    const errors = this.validateAll();

    if (Object.keys(errors).length &gt; 0) {
      this.errors = errors;
      this.touched = Object.keys(this.schema).reduce((acc, key) =&gt; {
        acc[key] = true;
        return acc;
      }, {});
      this.render();
      return;
    }

    this.onSubmit(this.values);
  }

  onSubmit(values) {
    // Override in subclass or pass as parameter
    console.log(&#039;Form submitted:&#039;, values);
  }

  template() {
    return `
      &lt;form class=&quot;schema-form&quot; onsubmit=&quot;this.handleSubmit(event)&quot;&gt;
        ${Object.keys(this.schema).map(field =&gt; this.renderField(field)).join(&#039;&#039;)}

        &lt;div class=&quot;form-actions&quot;&gt;
          &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
          &lt;button type=&quot;button&quot; onclick=&quot;this.handleReset()&quot;&gt;Reset&lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    `;
  }
}</code></pre>
<h3>Using the Schema Form</h3>
<pre><code class="language-javascript">class ProductForm extends SchemaForm {
  constructor() {
    super(productSchema);
  }

  async onSubmit(values) {
    try {
      const response = await fetch(&#039;/api/products&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify(values)
      });

      if (response.ok) {
        navigate(&#039;/products&#039;);
      } else {
        const error = await response.json();
        alert(`Error: ${error.message}`);
      }
    } catch (err) {
      alert(&#039;Network error. Please try again.&#039;);
    }
  }
}

customElements.define(&#039;product-form&#039;, ProductForm);</code></pre>
<h2>File Uploads</h2>
<p>File uploads are where form handling gets interesting (read: complicated). You need to handle previews, progress indicators, size limits, and mime type validation.</p>
<h3>Basic File Upload</h3>
<pre><code class="language-javascript">class FileUpload extends LarcComponent {
  constructor() {
    super();
    this.file = null;
    this.preview = null;
    this.uploading = false;
    this.progress = 0;
  }

  handleFileSelect(event) {
    const file = event.target.files[0];

    if (!file) {
      return;
    }

    // Validate file type
    const allowedTypes = [&#039;image/jpeg&#039;, &#039;image/png&#039;, &#039;image/gif&#039;];
    if (!allowedTypes.includes(file.type)) {
      alert(&#039;Please select a valid image file (JPEG, PNG, or GIF)&#039;);
      return;
    }

    // Validate file size (max 5MB)
    const maxSize = 5 * 1024 * 1024;
    if (file.size &gt; maxSize) {
      alert(&#039;File size must be less than 5MB&#039;);
      return;
    }

    this.file = file;
    this.generatePreview(file);
    this.render();
  }

  generatePreview(file) {
    const reader = new FileReader();

    reader.onload = (e) =&gt; {
      this.preview = e.target.result;
      this.render();
    };

    reader.readAsDataURL(file);
  }

  async handleUpload() {
    if (!this.file) {
      return;
    }

    this.uploading = true;
    this.progress = 0;
    this.render();

    const formData = new FormData();
    formData.append(&#039;file&#039;, this.file);

    try {
      const response = await fetch(&#039;/api/upload&#039;, {
        method: &#039;POST&#039;,
        body: formData
      });

      if (response.ok) {
        const result = await response.json();
        this.handleUploadSuccess(result);
      } else {
        alert(&#039;Upload failed&#039;);
      }
    } catch (err) {
      alert(&#039;Network error&#039;);
    } finally {
      this.uploading = false;
      this.render();
    }
  }

  handleUploadSuccess(result) {
    console.log(&#039;File uploaded:&#039;, result.url);
    this.file = null;
    this.preview = null;
    this.render();
  }

  template() {
    return `
      &lt;div class=&quot;file-upload&quot;&gt;
        &lt;input
          type=&quot;file&quot;
          accept=&quot;image/*&quot;
          onchange=&quot;this.handleFileSelect(event)&quot;
          ?disabled=&quot;${this.uploading}&quot;&gt;

        ${this.preview ? `
          &lt;div class=&quot;preview&quot;&gt;
            &lt;img src=&quot;${this.preview}&quot; alt=&quot;Preview&quot;&gt;
            &lt;button onclick=&quot;this.handleUpload()&quot;
                    ?disabled=&quot;${this.uploading}&quot;&gt;
              ${this.uploading ? &#039;Uploading...&#039; : &#039;Upload&#039;}
            &lt;/button&gt;
          &lt;/div&gt;
        ` : &#039;&#039;}

        ${this.uploading ? `
          &lt;div class=&quot;progress&quot;&gt;
            &lt;div class=&quot;progress-bar&quot; style=&quot;width: ${this.progress}%&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
        ` : &#039;&#039;}
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h3>Upload Progress with XMLHttpRequest</h3>
<p>For detailed progress tracking, use XMLHttpRequest instead of fetch:</p>
<pre><code class="language-javascript">uploadWithProgress(file, onProgress) {
  return new Promise((resolve, reject) =&gt; {
    const xhr = new XMLHttpRequest();
    const formData = new FormData();
    formData.append(&#039;file&#039;, file);

    xhr.upload.addEventListener(&#039;progress&#039;, (e) =&gt; {
      if (e.lengthComputable) {
        const progress = (e.loaded / e.total) * 100;
        onProgress(progress);
      }
    });

    xhr.addEventListener(&#039;load&#039;, () =&gt; {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.responseText));
      } else {
        reject(new Error(&#039;Upload failed&#039;));
      }
    });

    xhr.addEventListener(&#039;error&#039;, () =&gt; {
      reject(new Error(&#039;Network error&#039;));
    });

    xhr.open(&#039;POST&#039;, &#039;/api/upload&#039;);
    xhr.send(formData);
  });
}

async handleUpload() {
  this.uploading = true;
  this.render();

  try {
    const result = await this.uploadWithProgress(this.file, (progress) =&gt; {
      this.progress = progress;
      this.render();
    });

    this.handleUploadSuccess(result);
  } catch (err) {
    alert(&#039;Upload failed&#039;);
  } finally {
    this.uploading = false;
    this.render();
  }
}</code></pre>
<h2>Rich Text Editing</h2>
<p>Sometimes a plain textarea isn't enough, and you need formatted text. You have two main approaches: WYSIWYG editors and markdown.</p>
<h3>Markdown Editor</h3>
<p>Markdown is developer-friendly and produces clean, semantic output:</p>
<pre><code class="language-javascript">class MarkdownEditor extends LarcComponent {
  constructor() {
    super();
    this.content = &#039;&#039;;
    this.previewMode = false;
  }

  handleInput(event) {
    this.content = event.target.value;
    if (this.previewMode) {
      this.updatePreview();
    }
  }

  togglePreview() {
    this.previewMode = !this.previewMode;
    this.render();
  }

  updatePreview() {
    const preview = this.querySelector(&#039;.markdown-preview&#039;);
    if (preview) {
      preview.innerHTML = this.renderMarkdown(this.content);
    }
  }

  renderMarkdown(text) {
    // Simple markdown parser (use a library like marked.js for production)
    return text
      .replace(/^### (.*$)/gim, &#039;&lt;h3&gt;$1&lt;/h3&gt;&#039;)
      .replace(/^## (.*$)/gim, &#039;&lt;h2&gt;$1&lt;/h2&gt;&#039;)
      .replace(/^# (.*$)/gim, &#039;&lt;h1&gt;$1&lt;/h1&gt;&#039;)
      .replace(/\*\*(.*)\*\*/gim, &#039;&lt;strong&gt;$1&lt;/strong&gt;&#039;)
      .replace(/\*(.*)\*/gim, &#039;&lt;em&gt;$1&lt;/em&gt;&#039;)
      .replace(/!\[(.*?)\]\((.*?)\)/gim, &#039;&lt;img alt=&quot;$1&quot; src=&quot;$2&quot;&gt;&#039;)
      .replace(/\[(.*?)\]\((.*?)\)/gim, &#039;&lt;a href=&quot;$2&quot;&gt;$1&lt;/a&gt;&#039;)
      .replace(/\n/gim, &#039;&lt;br&gt;&#039;);
  }

  insertFormatting(format) {
    const textarea = this.querySelector(&#039;textarea&#039;);
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = this.content.substring(start, end);

    let insertion;
    switch (format) {
      case &#039;bold&#039;:
        insertion = `**${selectedText}**`;
        break;
      case &#039;italic&#039;:
        insertion = `*${selectedText}*`;
        break;
      case &#039;link&#039;:
        insertion = `[${selectedText}](url)`;
        break;
      case &#039;heading&#039;:
        insertion = `## ${selectedText}`;
        break;
      default:
        return;
    }

    this.content = this.content.substring(0, start) +
                   insertion +
                   this.content.substring(end);

    this.render();
  }

  template() {
    return `
      &lt;div class=&quot;markdown-editor&quot;&gt;
        &lt;div class=&quot;toolbar&quot;&gt;
          &lt;button type=&quot;button&quot; onclick=&quot;this.insertFormatting(&#039;bold&#039;)&quot;&gt;
            &lt;strong&gt;B&lt;/strong&gt;
          &lt;/button&gt;
          &lt;button type=&quot;button&quot; onclick=&quot;this.insertFormatting(&#039;italic&#039;)&quot;&gt;
            &lt;em&gt;I&lt;/em&gt;
          &lt;/button&gt;
          &lt;button type=&quot;button&quot; onclick=&quot;this.insertFormatting(&#039;link&#039;)&quot;&gt;
            Link
          &lt;/button&gt;
          &lt;button type=&quot;button&quot; onclick=&quot;this.insertFormatting(&#039;heading&#039;)&quot;&gt;
            H2
          &lt;/button&gt;
          &lt;button type=&quot;button&quot; onclick=&quot;this.togglePreview()&quot;&gt;
            ${this.previewMode ? &#039;Edit&#039; : &#039;Preview&#039;}
          &lt;/button&gt;
        &lt;/div&gt;

        ${this.previewMode ? `
          &lt;div class=&quot;markdown-preview&quot;&gt;
            ${this.renderMarkdown(this.content)}
          &lt;/div&gt;
        ` : `
          &lt;textarea
            rows=&quot;10&quot;
            oninput=&quot;this.handleInput(event)&quot;&gt;${this.content}&lt;/textarea&gt;
        `}
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h3>Integrating Third-Party Editors</h3>
<p>For full-featured rich text editing, integrate libraries like Quill or TipTap:</p>
<pre><code class="language-javascript">import Quill from &#039;quill&#039;;

class RichTextEditor extends LarcComponent {
  constructor() {
    super();
    this.content = &#039;&#039;;
    this.editor = null;
  }

  afterRender() {
    if (!this.editor) {
      const container = this.querySelector(&#039;.editor-container&#039;);
      this.editor = new Quill(container, {
        theme: &#039;snow&#039;,
        modules: {
          toolbar: [
            [&#039;bold&#039;, &#039;italic&#039;, &#039;underline&#039;, &#039;strike&#039;],
            [&#039;blockquote&#039;, &#039;code-block&#039;],
            [{ &#039;header&#039;: 1 }, { &#039;header&#039;: 2 }],
            [{ &#039;list&#039;: &#039;ordered&#039;}, { &#039;list&#039;: &#039;bullet&#039; }],
            [{ &#039;indent&#039;: &#039;-1&#039;}, { &#039;indent&#039;: &#039;+1&#039; }],
            [&#039;link&#039;, &#039;image&#039;],
            [&#039;clean&#039;]
          ]
        }
      });

      this.editor.on(&#039;text-change&#039;, () =&gt; {
        this.content = this.editor.root.innerHTML;
      });
    }
  }

  getContent() {
    return this.content;
  }

  setContent(html) {
    if (this.editor) {
      this.editor.root.innerHTML = html;
      this.content = html;
    }
  }

  template() {
    return &#039;&lt;div class=&quot;editor-container&quot;&gt;&lt;/div&gt;&#039;;
  }
}</code></pre>
<h2>Form State Management</h2>
<p>For complex forms with multiple steps or interdependent fields, centralized state management helps maintain sanity:</p>
<pre><code class="language-javascript">class FormState {
  constructor(initialValues = {}) {
    this.values = { ...initialValues };
    this.errors = {};
    this.touched = {};
    this.dirty = false;
    this.listeners = [];
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () =&gt; {
      this.listeners = this.listeners.filter(l =&gt; l !== listener);
    };
  }

  notify() {
    this.listeners.forEach(listener =&gt; listener(this.getState()));
  }

  getState() {
    return {
      values: { ...this.values },
      errors: { ...this.errors },
      touched: { ...this.touched },
      dirty: this.dirty
    };
  }

  setValue(field, value) {
    this.values[field] = value;
    this.dirty = true;
    this.notify();
  }

  setError(field, error) {
    if (error) {
      this.errors[field] = error;
    } else {
      delete this.errors[field];
    }
    this.notify();
  }

  setTouched(field) {
    this.touched[field] = true;
    this.notify();
  }

  reset(values = {}) {
    this.values = { ...values };
    this.errors = {};
    this.touched = {};
    this.dirty = false;
    this.notify();
  }

  isValid() {
    return Object.keys(this.errors).length === 0;
  }
}</code></pre>
<p>Use this state manager in your forms:</p>
<pre><code class="language-javascript">class MultiStepForm extends LarcComponent {
  constructor() {
    super();
    this.currentStep = 1;
    this.formState = new FormState({
      // Step 1
      name: &#039;&#039;,
      email: &#039;&#039;,
      // Step 2
      address: &#039;&#039;,
      city: &#039;&#039;,
      // Step 3
      payment: &#039;&#039;
    });

    this.unsubscribe = this.formState.subscribe(() =&gt; {
      this.render();
    });
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  nextStep() {
    if (this.validateCurrentStep()) {
      this.currentStep++;
      this.render();
    }
  }

  previousStep() {
    this.currentStep--;
    this.render();
  }

  validateCurrentStep() {
    // Validate fields for current step
    return true;
  }

  template() {
    const state = this.formState.getState();

    return `
      &lt;form class=&quot;multi-step-form&quot;&gt;
        &lt;div class=&quot;steps&quot;&gt;
          ${this.currentStep === 1 ? this.renderStep1(state) : &#039;&#039;}
          ${this.currentStep === 2 ? this.renderStep2(state) : &#039;&#039;}
          ${this.currentStep === 3 ? this.renderStep3(state) : &#039;&#039;}
        &lt;/div&gt;

        &lt;div class=&quot;navigation&quot;&gt;
          ${this.currentStep &gt; 1 ? `
            &lt;button type=&quot;button&quot; onclick=&quot;this.previousStep()&quot;&gt;
              Previous
            &lt;/button&gt;
          ` : &#039;&#039;}

          ${this.currentStep &lt; 3 ? `
            &lt;button type=&quot;button&quot; onclick=&quot;this.nextStep()&quot;&gt;
              Next
            &lt;/button&gt;
          ` : `
            &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
          `}
        &lt;/div&gt;
      &lt;/form&gt;
    `;
  }
}</code></pre>
<h2>Conclusion</h2>
<p>Forms are the battleground where user intent meets application logic. By combining HTML5's built-in capabilities with LARC's component model, you can create forms that validate intelligently, provide helpful feedback, and gracefully handle the chaos users inevitably introduce. Whether you're building simple login forms or complex multi-step wizards, the patterns in this chapter will help you create user inputs that are both powerful and forgiving.</p>
<p>In the next chapter, we'll explore data fetching and APIs—because forms are useless without somewhere to send their data.</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/building-with-larc/chapter-10-forms-and-user-input.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
  <pan-bus debug="false"></pan-bus>
  <pan-theme-provider></pan-theme-provider>
</body>
</html>