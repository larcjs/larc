<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- CRITICAL: Load theme BEFORE CSS to prevent flash -->
  <script src="../../../../../playground/theme-init.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Routing and Navigation · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Routing and Navigation">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">building-with-larc</a> / <span>chapter-09-routing-and-navigation</span>
      </div>
      <article class="docs-content">
        <h1>Routing and Navigation</h1>
<em>In which we learn to guide users through our applications without getting lost in the woods (or the browser's back button)</em>
<p>Navigation is to web applications what hallways are to buildings: theoretically simple, but surprisingly easy to get wrong. You've probably experienced the horror of clicking the back button only to be ejected from the application entirely, or the confusion of bookmarking a URL that leads nowhere meaningful. LARC's routing system aims to prevent these digital disasters by making client-side navigation feel as natural as walking through a well-designed building.</p>
<p>In this chapter, we'll explore LARC's routing architecture, which leverages the <code>pan-routes</code> component to create seamless navigation experiences. We'll cover route definitions, pattern matching, navigation guards, deep linking, history management, and even touch on SEO considerations because, let's face it, even the most beautiful application is useless if no one can find it.</p>
<h2>Understanding Client-Side Routing</h2>
<p>Before we dive into LARC's implementation, let's establish what client-side routing actually means. In the ancient days of the web (circa 2005), every navigation triggered a full page reload. Click a link, wait for the server, watch the screen flash white, and finally see your new content. It was like rebooting your computer every time you wanted to switch applications.</p>
<p>Client-side routing changes this paradigm. Instead of requesting new HTML from the server for each navigation, the JavaScript application intercepts link clicks, updates the URL, and renders the appropriate component—all without reloading the page. It's like having a building where rooms can instantly rearrange themselves rather than making you walk outside and back in through a different door.</p>
<p>LARC implements client-side routing through the <code>pan-routes</code> component, which acts as a traffic controller for your application's navigation. It watches for URL changes, matches them against defined route patterns, and renders the corresponding components.</p>
<h2>The pan-routes Component</h2>
<p>The <code>pan-routes</code> component is your application's navigation hub. It sits in your main application component and declares all the routes your application recognizes. Here's a basic example:</p>
<pre><code class="language-html">&lt;pan-app id=&quot;app&quot;&gt;
  &lt;pan-routes&gt;
    &lt;pan-route path=&quot;/&quot; component=&quot;home-view&quot;&gt;&lt;/pan-route&gt;
    &lt;pan-route path=&quot;/about&quot; component=&quot;about-view&quot;&gt;&lt;/pan-route&gt;
    &lt;pan-route path=&quot;/products&quot; component=&quot;product-list&quot;&gt;&lt;/pan-route&gt;
    &lt;pan-route path=&quot;/products/:id&quot; component=&quot;product-detail&quot;&gt;&lt;/pan-route&gt;
    &lt;pan-route path=&quot;/user/:username&quot; component=&quot;user-profile&quot;&gt;&lt;/pan-route&gt;
    &lt;pan-route path=&quot;*&quot; component=&quot;not-found-view&quot;&gt;&lt;/pan-route&gt;
  &lt;/pan-routes&gt;
&lt;/pan-app&gt;</code></pre>
<p>Each <code>pan-route</code> element defines a mapping between a URL path and a component. When the URL matches a route's path, LARC renders the corresponding component. Think of it as a telephone switchboard operator from the 1950s, connecting callers to the right extension—except digital and without the period-appropriate hairstyle.</p>
<h3>Route Matching Order</h3>
<p>Routes are evaluated in the order they're defined, which means specificity matters. The wildcard route (<code>path="*"</code>) should always come last, as it matches everything. If you put it first, your users will only ever see your 404 page, which is a bold design choice but probably not what you intended.</p>
<p>Here's a more realistic example showing route organization:</p>
<pre><code class="language-html">&lt;pan-routes&gt;
  &lt;!-- Exact matches first --&gt;
  &lt;pan-route path=&quot;/&quot; component=&quot;home-view&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/login&quot; component=&quot;login-view&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/logout&quot; component=&quot;logout-view&quot;&gt;&lt;/pan-route&gt;

  &lt;!-- Static paths before dynamic ones --&gt;
  &lt;pan-route path=&quot;/products/new&quot; component=&quot;product-create&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/products/:id&quot; component=&quot;product-detail&quot;&gt;&lt;/pan-route&gt;

  &lt;!-- More specific patterns before general ones --&gt;
  &lt;pan-route path=&quot;/admin/users/:id&quot; component=&quot;admin-user-detail&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/admin/:section&quot; component=&quot;admin-section&quot;&gt;&lt;/pan-route&gt;

  &lt;!-- Catch-all last --&gt;
  &lt;pan-route path=&quot;*&quot; component=&quot;not-found-view&quot;&gt;&lt;/pan-route&gt;
&lt;/pan-routes&gt;</code></pre>
<h2>Route Parameters and Pattern Matching</h2>
<p>Dynamic route parameters are where routing gets interesting. Instead of defining a separate route for every product, user, or blog post, you use parameter placeholders prefixed with a colon (<code>:parameter</code>). LARC extracts these values and makes them available to your components.</p>
<h3>Basic Parameters</h3>
<p>The most common pattern is a single dynamic segment:</p>
<pre><code class="language-html">&lt;pan-route path=&quot;/products/:id&quot; component=&quot;product-detail&quot;&gt;&lt;/pan-route&gt;
&lt;pan-route path=&quot;/users/:username&quot; component=&quot;user-profile&quot;&gt;&lt;/pan-route&gt;
&lt;pan-route path=&quot;/posts/:year/:month/:slug&quot; component=&quot;blog-post&quot;&gt;&lt;/pan-route&gt;</code></pre>
<p>In your component, access these parameters through the route context:</p>
<pre><code class="language-javascript">class ProductDetail extends LarcComponent {
  constructor() {
    super();
    this.product = null;
  }

  onRoute(params) {
    // params.id contains the value from the URL
    this.loadProduct(params.id);
  }

  async loadProduct(id) {
    const response = await fetch(`/api/products/${id}`);
    this.product = await response.json();
    this.render();
  }

  template() {
    if (!this.product) {
      return &#039;&lt;div&gt;Loading...&lt;/div&gt;&#039;;
    }

    return `
      &lt;div class=&quot;product-detail&quot;&gt;
        &lt;h1&gt;${this.product.name}&lt;/h1&gt;
        &lt;p&gt;${this.product.description}&lt;/p&gt;
        &lt;span class=&quot;price&quot;&gt;$${this.product.price}&lt;/span&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h3>Multiple Parameters</h3>
<p>Routes can contain multiple parameters, which is useful for hierarchical data:</p>
<pre><code class="language-html">&lt;pan-route path=&quot;/store/:category/:subcategory/:productId&quot;
           component=&quot;product-view&quot;&gt;&lt;/pan-route&gt;</code></pre>
<pre><code class="language-javascript">class ProductView extends LarcComponent {
  onRoute(params) {
    // params = { category: &#039;electronics&#039;, subcategory: &#039;phones&#039;, productId: &#039;123&#039; }
    this.loadProduct(params.category, params.subcategory, params.productId);
  }
}</code></pre>
<h3>Optional Parameters</h3>
<p>Sometimes you want a route to work with or without certain parameters. While LARC doesn't have built-in optional parameter syntax, you can achieve this with multiple route definitions:</p>
<pre><code class="language-html">&lt;pan-routes&gt;
  &lt;pan-route path=&quot;/blog/:year/:month/:day&quot; component=&quot;blog-archive&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/blog/:year/:month&quot; component=&quot;blog-archive&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/blog/:year&quot; component=&quot;blog-archive&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/blog&quot; component=&quot;blog-archive&quot;&gt;&lt;/pan-route&gt;
&lt;/pan-routes&gt;</code></pre>
<pre><code class="language-javascript">class BlogArchive extends LarcComponent {
  onRoute(params) {
    const { year, month, day } = params;

    if (day) {
      this.loadPostsForDay(year, month, day);
    } else if (month) {
      this.loadPostsForMonth(year, month);
    } else if (year) {
      this.loadPostsForYear(year);
    } else {
      this.loadAllPosts();
    }
  }
}</code></pre>
<h2>Programmatic Navigation</h2>
<p>Clicking links is great, but sometimes you need to navigate programmatically—after form submissions, authentication changes, or when playing a game of "redirect the user until they give up and close the tab."</p>
<p>LARC provides the <code>navigate()</code> function for programmatic navigation:</p>
<pre><code class="language-javascript">import { navigate } from &#039;@larc/core&#039;;

class LoginForm extends LarcComponent {
  async handleLogin(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const credentials = {
      username: formData.get(&#039;username&#039;),
      password: formData.get(&#039;password&#039;)
    };

    try {
      const response = await fetch(&#039;/api/login&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify(credentials)
      });

      if (response.ok) {
        // Success! Navigate to dashboard
        navigate(&#039;/dashboard&#039;);
      } else {
        this.showError(&#039;Invalid credentials&#039;);
      }
    } catch (error) {
      this.showError(&#039;Network error&#039;);
    }
  }

  template() {
    return `
      &lt;form onsubmit=&quot;this.handleLogin(event)&quot;&gt;
        &lt;input name=&quot;username&quot; type=&quot;text&quot; required&gt;
        &lt;input name=&quot;password&quot; type=&quot;password&quot; required&gt;
        &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;
      &lt;/form&gt;
    `;
  }
}</code></pre>
<h3>Navigation Options</h3>
<p>The <code>navigate()</code> function accepts an options object for controlling navigation behavior:</p>
<pre><code class="language-javascript">// Replace current history entry instead of pushing a new one
navigate(&#039;/login&#039;, { replace: true });

// Prevent navigation if user has unsaved changes
if (this.hasUnsavedChanges()) {
  const confirmed = confirm(&#039;You have unsaved changes. Leave anyway?&#039;);
  if (!confirmed) {
    return; // Don&#039;t navigate
  }
}
navigate(&#039;/other-page&#039;);

// Navigate back and forward
navigate(-1); // Go back
navigate(1);  // Go forward
navigate(-2); // Go back two pages</code></pre>
<h2>Navigation Guards</h2>
<p>Navigation guards are like bouncers at an exclusive club—they decide who gets in and who gets redirected to the login page. Guards let you intercept navigation attempts and redirect, cancel, or allow them based on application state.</p>
<h3>Implementing Auth Guards</h3>
<p>A common use case is protecting routes that require authentication:</p>
<pre><code class="language-javascript">class AuthGuard {
  constructor() {
    this.user = null;
    this.loadUserFromStorage();
  }

  loadUserFromStorage() {
    const stored = localStorage.getItem(&#039;user&#039;);
    if (stored) {
      this.user = JSON.parse(stored);
    }
  }

  canActivate(route) {
    if (!this.user) {
      // Not logged in, redirect to login
      navigate(&#039;/login?redirect=&#039; + encodeURIComponent(route.path));
      return false;
    }
    return true;
  }

  requiresRole(role) {
    return this.user &amp;&amp; this.user.roles.includes(role);
  }
}

const authGuard = new AuthGuard();</code></pre>
<p>Now integrate this guard into your components:</p>
<pre><code class="language-javascript">class DashboardView extends LarcComponent {
  beforeRoute(params) {
    if (!authGuard.canActivate(this.route)) {
      return false; // Cancel navigation
    }
    return true; // Allow navigation
  }

  onRoute(params) {
    this.loadDashboardData();
  }
}

class AdminPanel extends LarcComponent {
  beforeRoute(params) {
    if (!authGuard.requiresRole(&#039;admin&#039;)) {
      navigate(&#039;/unauthorized&#039;);
      return false;
    }
    return true;
  }
}</code></pre>
<h3>Route Transition Guards</h3>
<p>Sometimes you need to prevent users from leaving a page—usually because they have unsaved changes and you're trying to save them from themselves:</p>
<pre><code class="language-javascript">class PostEditor extends LarcComponent {
  constructor() {
    super();
    this.isDirty = false;
    this.originalContent = &#039;&#039;;
  }

  beforeRouteLeave(to, from) {
    if (this.isDirty) {
      const answer = confirm(
        &#039;You have unsaved changes. Are you sure you want to leave?&#039;
      );
      return answer; // true = allow navigation, false = cancel
    }
    return true;
  }

  handleContentChange(event) {
    this.isDirty = event.target.value !== this.originalContent;
  }

  async handleSave() {
    await this.savePost();
    this.isDirty = false;
    this.originalContent = this.getEditorContent();
  }
}</code></pre>
<h2>Deep Linking and URL State</h2>
<p>Deep linking is the practice of encoding application state in the URL so users can bookmark, share, or return to specific states. It's the difference between sharing "myapp.com" and sharing "myapp.com/products?category=electronics&sort=price&page=3"—one is helpful, the other is a digital shrug.</p>
<h3>Query Parameters</h3>
<p>Query parameters are perfect for filters, search terms, pagination, and other non-hierarchical state:</p>
<pre><code class="language-javascript">class ProductList extends LarcComponent {
  onRoute(params, query) {
    // params from route pattern, query from ?key=value
    const {
      category = &#039;all&#039;,
      sort = &#039;name&#039;,
      page = 1,
      search = &#039;&#039;
    } = query;

    this.loadProducts({ category, sort, page, search });
  }

  handleFilterChange(category) {
    const currentQuery = this.getQueryParams();
    navigate(`/products?${new URLSearchParams({
      ...currentQuery,
      category,
      page: 1 // Reset to first page when filter changes
    })}`);
  }

  handleSortChange(sort) {
    const currentQuery = this.getQueryParams();
    navigate(`/products?${new URLSearchParams({
      ...currentQuery,
      sort
    })}`);
  }

  getQueryParams() {
    return Object.fromEntries(
      new URLSearchParams(window.location.search)
    );
  }
}</code></pre>
<h3>Hash Fragments</h3>
<p>Hash fragments (<code>#section-name</code>) are useful for scrolling to specific sections and maintaining scroll position:</p>
<pre><code class="language-javascript">class DocumentationView extends LarcComponent {
  onRoute(params) {
    this.loadDocument(params.docId);
  }

  afterRender() {
    // Scroll to hash target if present
    const hash = window.location.hash;
    if (hash) {
      const element = this.querySelector(hash);
      if (element) {
        element.scrollIntoView({ behavior: &#039;smooth&#039; });
      }
    }
  }

  template() {
    return `
      &lt;article&gt;
        &lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
        &lt;p&gt;Content here...&lt;/p&gt;

        &lt;h2 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h2&gt;
        &lt;p&gt;More content...&lt;/p&gt;

        &lt;nav class=&quot;table-of-contents&quot;&gt;
          &lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;
          &lt;a href=&quot;#getting-started&quot;&gt;Getting Started&lt;/a&gt;
        &lt;/nav&gt;
      &lt;/article&gt;
    `;
  }
}</code></pre>
<h2>History Management</h2>
<p>The browser's history API is like a time machine, but one that only goes to boring places like "the page you were just on." LARC wraps this API to make history management more pleasant.</p>
<h3>Push vs. Replace</h3>
<p>When navigating, you can either push a new entry onto the history stack or replace the current entry:</p>
<pre><code class="language-javascript">// Push new entry (default behavior)
// User can click back to return to previous page
navigate(&#039;/products/123&#039;);

// Replace current entry
// User clicks back and skips this page entirely
navigate(&#039;/login&#039;, { replace: true });</code></pre>
<p>Replace is useful for:</p>
<ul><li>Redirect chains (login -> loading -> dashboard)</li>
<li>Temporary states (splash screens, loading views)</li>
<li>Fixing invalid URLs (redirect /old-path to /new-path)</li>
</ul>
<h3>Listening to History Changes</h3>
<p>Sometimes you need to react to back/forward button clicks:</p>
<pre><code class="language-javascript">class App extends LarcComponent {
  constructor() {
    super();
    this.setupHistoryListener();
  }

  setupHistoryListener() {
    window.addEventListener(&#039;popstate&#039;, (event) =&gt; {
      // User clicked back or forward
      this.handleNavigation(event.state);
    });
  }

  handleNavigation(state) {
    // Restore application state from history state
    if (state &amp;&amp; state.scrollPosition) {
      window.scrollTo(0, state.scrollPosition);
    }
  }

  saveScrollPosition() {
    history.replaceState({
      scrollPosition: window.scrollY
    }, &#039;&#039;);
  }
}</code></pre>
<h3>Preserving Scroll Position</h3>
<p>Nothing frustrates users more than losing their scroll position when navigating. Here's a pattern for preserving it:</p>
<pre><code class="language-javascript">class ScrollManager {
  constructor() {
    this.positions = new Map();
    this.setupListeners();
  }

  setupListeners() {
    // Save scroll position before navigating away
    window.addEventListener(&#039;beforeunload&#039;, () =&gt; {
      this.savePosition(window.location.pathname);
    });

    // Restore scroll position after navigation
    window.addEventListener(&#039;load&#039;, () =&gt; {
      this.restorePosition(window.location.pathname);
    });
  }

  savePosition(path) {
    this.positions.set(path, {
      x: window.scrollX,
      y: window.scrollY
    });
  }

  restorePosition(path) {
    const position = this.positions.get(path);
    if (position) {
      window.scrollTo(position.x, position.y);
    } else {
      window.scrollTo(0, 0); // Default to top
    }
  }
}</code></pre>
<h2>Nested Routes and Layouts</h2>
<p>Real applications have hierarchical navigation structures. You might have a main layout with a header and sidebar, then nested views that change based on the route. LARC supports this through component composition:</p>
<pre><code class="language-html">&lt;pan-app id=&quot;app&quot;&gt;
  &lt;app-layout&gt;
    &lt;pan-routes&gt;
      &lt;pan-route path=&quot;/&quot; component=&quot;home-view&quot;&gt;&lt;/pan-route&gt;
      &lt;pan-route path=&quot;/products*&quot; component=&quot;product-section&quot;&gt;&lt;/pan-route&gt;
      &lt;pan-route path=&quot;/admin*&quot; component=&quot;admin-section&quot;&gt;&lt;/pan-route&gt;
    &lt;/pan-routes&gt;
  &lt;/app-layout&gt;
&lt;/pan-app&gt;</code></pre>
<p>The <code>product-section</code> component contains its own nested routes:</p>
<pre><code class="language-javascript">class ProductSection extends LarcComponent {
  template() {
    return `
      &lt;div class=&quot;product-section&quot;&gt;
        &lt;nav class=&quot;sidebar&quot;&gt;
          &lt;a href=&quot;/products&quot;&gt;All Products&lt;/a&gt;
          &lt;a href=&quot;/products/categories&quot;&gt;Categories&lt;/a&gt;
          &lt;a href=&quot;/products/new&quot;&gt;Add New&lt;/a&gt;
        &lt;/nav&gt;

        &lt;main class=&quot;content&quot;&gt;
          &lt;pan-routes&gt;
            &lt;pan-route path=&quot;/products&quot; component=&quot;product-list&quot;&gt;&lt;/pan-route&gt;
            &lt;pan-route path=&quot;/products/categories&quot; component=&quot;category-list&quot;&gt;&lt;/pan-route&gt;
            &lt;pan-route path=&quot;/products/new&quot; component=&quot;product-form&quot;&gt;&lt;/pan-route&gt;
            &lt;pan-route path=&quot;/products/:id&quot; component=&quot;product-detail&quot;&gt;&lt;/pan-route&gt;
          &lt;/pan-routes&gt;
        &lt;/main&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h2>Link Handling and Active States</h2>
<p>Navigation links should indicate which page is currently active. LARC provides utilities for this:</p>
<pre><code class="language-javascript">class NavBar extends LarcComponent {
  constructor() {
    super();
    this.currentPath = window.location.pathname;

    // Update active state when route changes
    window.addEventListener(&#039;popstate&#039;, () =&gt; {
      this.currentPath = window.location.pathname;
      this.render();
    });
  }

  isActive(path) {
    return this.currentPath === path;
  }

  isActivePrefix(prefix) {
    return this.currentPath.startsWith(prefix);
  }

  template() {
    return `
      &lt;nav class=&quot;navbar&quot;&gt;
        &lt;a href=&quot;/&quot; class=&quot;${this.isActive(&#039;/&#039;) ? &#039;active&#039; : &#039;&#039;}&quot;&gt;
          Home
        &lt;/a&gt;
        &lt;a href=&quot;/products&quot; class=&quot;${this.isActivePrefix(&#039;/products&#039;) ? &#039;active&#039; : &#039;&#039;}&quot;&gt;
          Products
        &lt;/a&gt;
        &lt;a href=&quot;/about&quot; class=&quot;${this.isActive(&#039;/about&#039;) ? &#039;active&#039; : &#039;&#039;}&quot;&gt;
          About
        &lt;/a&gt;
      &lt;/nav&gt;
    `;
  }
}</code></pre>
<h2>SEO Considerations</h2>
<p>Client-side routing can be problematic for search engines if not handled properly. While modern search crawlers can execute JavaScript, it's still wise to follow best practices:</p>
<h3>Server-Side Rendering (SSR)</h3>
<p>For maximum SEO, consider implementing server-side rendering:</p>
<pre><code class="language-javascript">// server.js
import { renderToString } from &#039;@larc/ssr&#039;;
import { App } from &#039;./app.js&#039;;

app.get(&#039;*&#039;, async (req, res) =&gt; {
  const html = await renderToString(App, {
    path: req.path,
    query: req.query
  });

  res.send(`
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;${getTitle(req.path)}&lt;/title&gt;
        &lt;meta name=&quot;description&quot; content=&quot;${getDescription(req.path)}&quot;&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;${html}&lt;/div&gt;
        &lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  `);
});</code></pre>
<h3>Meta Tags and Titles</h3>
<p>Update document title and meta tags when routes change:</p>
<pre><code class="language-javascript">class SEOManager {
  updateMeta(route, data) {
    // Update title
    document.title = data.title || &#039;Default Title&#039;;

    // Update description
    this.setMetaTag(&#039;description&#039;, data.description || &#039;&#039;);

    // Update Open Graph tags for social sharing
    this.setMetaTag(&#039;og:title&#039;, data.title);
    this.setMetaTag(&#039;og:description&#039;, data.description);
    this.setMetaTag(&#039;og:url&#039;, window.location.href);

    // Update canonical URL
    this.setLinkTag(&#039;canonical&#039;, window.location.href);
  }

  setMetaTag(name, content) {
    let element = document.querySelector(`meta[name=&quot;${name}&quot;]`) ||
                  document.querySelector(`meta[property=&quot;${name}&quot;]`);

    if (!element) {
      element = document.createElement(&#039;meta&#039;);
      const attr = name.startsWith(&#039;og:&#039;) ? &#039;property&#039; : &#039;name&#039;;
      element.setAttribute(attr, name);
      document.head.appendChild(element);
    }

    element.setAttribute(&#039;content&#039;, content);
  }

  setLinkTag(rel, href) {
    let element = document.querySelector(`link[rel=&quot;${rel}&quot;]`);

    if (!element) {
      element = document.createElement(&#039;link&#039;);
      element.setAttribute(&#039;rel&#039;, rel);
      document.head.appendChild(element);
    }

    element.setAttribute(&#039;href&#039;, href);
  }
}

const seoManager = new SEOManager();

class ProductDetail extends LarcComponent {
  async onRoute(params) {
    const product = await this.loadProduct(params.id);

    seoManager.updateMeta(this.route, {
      title: `${product.name} - Our Store`,
      description: product.description,
      image: product.imageUrl
    });
  }
}</code></pre>
<h3>Prerendering</h3>
<p>For static content, consider prerendering routes at build time:</p>
<pre><code class="language-javascript">// build-prerender.js
import { prerender } from &#039;@larc/prerender&#039;;

const routes = [
  &#039;/&#039;,
  &#039;/about&#039;,
  &#039;/products&#039;,
  &#039;/contact&#039;
];

async function buildPrerenderedPages() {
  for (const route of routes) {
    const html = await prerender(route);
    const filename = route === &#039;/&#039; ? &#039;index.html&#039; : `${route}/index.html`;
    await fs.writeFile(`dist/${filename}`, html);
  }
}

buildPrerenderedPages();</code></pre>
<h2>Putting It All Together</h2>
<p>Let's create a complete example that demonstrates all these concepts:</p>
<pre><code class="language-javascript">// app.js
import { LarcComponent, navigate } from &#039;@larc/core&#039;;

class MainApp extends LarcComponent {
  constructor() {
    super();
    this.authGuard = new AuthGuard();
    this.seoManager = new SEOManager();
    this.setupNavigation();
  }

  setupNavigation() {
    window.addEventListener(&#039;popstate&#039;, () =&gt; {
      this.render();
    });
  }

  template() {
    return `
      &lt;div class=&quot;app&quot;&gt;
        &lt;app-header&gt;&lt;/app-header&gt;
        &lt;pan-routes&gt;
          &lt;pan-route path=&quot;/&quot; component=&quot;home-view&quot;&gt;&lt;/pan-route&gt;
          &lt;pan-route path=&quot;/products&quot; component=&quot;product-list&quot;&gt;&lt;/pan-route&gt;
          &lt;pan-route path=&quot;/products/:id&quot; component=&quot;product-detail&quot;&gt;&lt;/pan-route&gt;
          &lt;pan-route path=&quot;/cart&quot; component=&quot;shopping-cart&quot;&gt;&lt;/pan-route&gt;
          &lt;pan-route path=&quot;/checkout&quot; component=&quot;checkout-view&quot;&gt;&lt;/pan-route&gt;
          &lt;pan-route path=&quot;/account*&quot; component=&quot;account-section&quot;&gt;&lt;/pan-route&gt;
          &lt;pan-route path=&quot;*&quot; component=&quot;not-found-view&quot;&gt;&lt;/pan-route&gt;
        &lt;/pan-routes&gt;
        &lt;app-footer&gt;&lt;/app-footer&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;main-app&#039;, MainApp);</code></pre>
<p>Routing in LARC transforms your application from a collection of disconnected pages into a cohesive, navigable experience. With proper route organization, parameter handling, navigation guards, and SEO considerations, you can build applications that feel responsive, intelligent, and easy to use—even when users inevitably click the back button seventeen times trying to find that one product they saw earlier.</p>
<p>In the next chapter, we'll tackle forms and user input, which is where users finally get to talk back to your application (and boy, do they have opinions).</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/building-with-larc/chapter-09-routing-and-navigation.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
  <pan-bus debug="false"></pan-bus>
  <pan-theme-provider></pan-theme-provider>
</body>
</html>