<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- CRITICAL: Load theme BEFORE CSS to prevent flash -->
  <script src="../../../../../../playground/theme-init.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Data Fetching and APIs Â· PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Data Fetching and APIs">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">building-with-larc</a> / <a href="#">chapters</a> / <span>07-data-fetching-and-apis</span>
      </div>
      <article class="docs-content">
        <h1>Data Fetching and APIs</h1>
<p>Quick reference for API integration and data fetching in LARC applications. For detailed tutorials, see <em>Learning LARC</em> Chapter 11.</p>
<h2>Overview</h2>
<p>Modern web applications fetch data from APIs using REST, GraphQL, or WebSockets. LARC provides components and patterns for handling async data loading, caching, error recovery, and real-time updates.</p>
<strong>Key Concepts</strong>:
<ul><li>REST APIs: Standard HTTP methods (GET, POST, PUT, DELETE)</li>
<li>GraphQL: Query-based data fetching with precise field selection</li>
<li>Error handling: Retry logic, fallbacks, user feedback</li>
<li>Caching strategies: In-memory, localStorage, IndexedDB</li>
<li>Loading states: Skeleton screens, spinners, optimistic updates</li>
</ul>
<h2>Quick Example</h2>
<pre><code class="language-javascript">class ProductList extends LarcComponent {
  constructor() {
    super();
    this.products = [];
    this.loading = true;
    this.error = null;
  }

  async connectedCallback() {
    await this.loadProducts();
  }

  async loadProducts() {
    this.loading = true;
    this.error = null;
    this.render();

    try {
      const response = await fetch(&#039;/api/products&#039;);
      if (!response.ok) throw new Error(&#039;Failed to load products&#039;);
      
      this.products = await response.json();
    } catch (err) {
      this.error = err.message;
    } finally {
      this.loading = false;
      this.render();
    }
  }

  template() {
    if (this.loading) return &#039;&lt;div class=&quot;spinner&quot;&gt;Loading...&lt;/div&gt;&#039;;
    if (this.error) return `&lt;div class=&quot;error&quot;&gt;${this.error}&lt;/div&gt;`;

    return `
      &lt;div class=&quot;product-list&quot;&gt;
        ${this.products.map(p =&gt; `
          &lt;div class=&quot;product-card&quot;&gt;
            &lt;h3&gt;${p.name}&lt;/h3&gt;
            &lt;p&gt;${p.price}&lt;/p&gt;
          &lt;/div&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h2>REST API Patterns</h2>
<p>| HTTP Method | Purpose | Example |
|-------------|---------|---------|
| GET | Fetch data | <code>GET /api/products?category=electronics</code> |
| POST | Create resource | <code>POST /api/products</code> + body |
| PUT | Replace resource | <code>PUT /api/products/123</code> + body |
| PATCH | Update fields | <code>PATCH /api/products/123</code> + partial body |
| DELETE | Remove resource | <code>DELETE /api/products/123</code> |</p>
<h3>REST Example with Error Handling</h3>
<pre><code class="language-javascript">async createProduct(data) {
  try {
    const response = await fetch(&#039;/api/products&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || &#039;Failed to create product&#039;);
    }

    return await response.json();
  } catch (err) {
    console.error(&#039;Create product failed:&#039;, err);
    throw err;
  }
}</code></pre>
<h2>GraphQL Integration</h2>
<h3>Basic Query</h3>
<pre><code class="language-javascript">async fetchUser(userId) {
  const query = `
    query GetUser($id: ID!) {
      user(id: $id) {
        id
        name
        email
        posts {
          id
          title
        }
      }
    }
  `;

  const response = await fetch(&#039;/graphql&#039;, {
    method: &#039;POST&#039;,
    headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
    body: JSON.stringify({
      query,
      variables: { id: userId }
    })
  });

  const result = await response.json();
  if (result.errors) throw new Error(result.errors[0].message);
  
  return result.data.user;
}</code></pre>
<h3>Mutation Example</h3>
<pre><code class="language-javascript">async updateUser(userId, updates) {
  const mutation = `
    mutation UpdateUser($id: ID!, $input: UserInput!) {
      updateUser(id: $id, input: $input) {
        id
        name
        email
      }
    }
  `;

  const response = await fetch(&#039;/graphql&#039;, {
    method: &#039;POST&#039;,
    headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
    body: JSON.stringify({
      query: mutation,
      variables: { id: userId, input: updates }
    })
  });

  const result = await response.json();
  if (result.errors) throw new Error(result.errors[0].message);
  
  return result.data.updateUser;
}</code></pre>
<h2>Caching Strategies</h2>
<p>| Strategy | Implementation | Use Case |
|----------|---------------|----------|
| <strong>In-memory</strong> | Store in component property | Session-only data |
| <strong>localStorage</strong> | <code>localStorage.setItem()</code> | Small datasets, settings |
| <strong>IndexedDB</strong> | <code>pan-idb</code> component | Large datasets, offline support |
| <strong>HTTP cache</strong> | <code>Cache-Control</code> headers | Static assets, CDN content |
| <strong>Stale-while-revalidate</strong> | Show cached + fetch fresh | Balance speed + freshness |</p>
<h3>Stale-While-Revalidate Pattern</h3>
<pre><code class="language-javascript">async loadProducts() {
  // Show cached data immediately
  const cached = this.getCache(&#039;products&#039;);
  if (cached) {
    this.products = cached;
    this.render();
  }

  // Fetch fresh data in background
  try {
    const response = await fetch(&#039;/api/products&#039;);
    const fresh = await response.json();
    
    this.products = fresh;
    this.setCache(&#039;products&#039;, fresh, 5 * 60 * 1000); // 5 min TTL
    this.render();
  } catch (err) {
    // Keep showing cached data on error
    if (!cached) {
      this.error = err.message;
      this.render();
    }
  }
}

getCache(key) {
  const item = localStorage.getItem(`cache:${key}`);
  if (!item) return null;
  
  const { data, expires } = JSON.parse(item);
  if (Date.now() &gt; expires) return null;
  
  return data;
}

setCache(key, data, ttl) {
  localStorage.setItem(`cache:${key}`, JSON.stringify({
    data,
    expires: Date.now() + ttl
  }));
}</code></pre>
<h2>Error Recovery Patterns</h2>
<h3>Retry with Exponential Backoff</h3>
<pre><code class="language-javascript">async fetchWithRetry(url, options = {}, maxRetries = 3) {
  for (let i = 0; i &lt; maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.ok) return await response.json();
      
      if (response.status &gt;= 500 &amp;&amp; i &lt; maxRetries - 1) {
        // Retry on server errors
        const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s
        await new Promise(resolve =&gt; setTimeout(resolve, delay));
        continue;
      }
      
      throw new Error(`HTTP ${response.status}`);
    } catch (err) {
      if (i === maxRetries - 1) throw err;
      
      const delay = Math.pow(2, i) * 1000;
      await new Promise(resolve =&gt; setTimeout(resolve, delay));
    }
  }
}</code></pre>
<h3>Fallback Data</h3>
<pre><code class="language-javascript">async loadProducts() {
  try {
    const response = await fetch(&#039;/api/products&#039;);
    this.products = await response.json();
  } catch (err) {
    console.error(&#039;API failed, using fallback data:&#039;, err);
    this.products = this.getFallbackProducts();
  }
  
  this.render();
}

getFallbackProducts() {
  return [
    { id: 1, name: &#039;Product 1&#039;, price: 19.99 },
    { id: 2, name: &#039;Product 2&#039;, price: 29.99 }
  ];
}</code></pre>
<h2>Loading States</h2>
<h3>Skeleton Screens</h3>
<pre><code class="language-javascript">template() {
  if (this.loading) {
    return `
      &lt;div class=&quot;product-list&quot;&gt;
        ${Array(6).fill(0).map(() =&gt; `
          &lt;div class=&quot;product-card skeleton&quot;&gt;
            &lt;div class=&quot;skeleton-title&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;skeleton-text&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;skeleton-price&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;
    `;
  }

  return this.renderProducts();
}</code></pre>
<h3>Progressive Loading</h3>
<pre><code class="language-javascript">async connectedCallback() {
  // Load critical data first
  await this.loadSummary();
  this.render();

  // Load details in background
  await this.loadDetails();
  this.render();
}</code></pre>
<h2>Component Reference</h2>
<ul><li><strong>pan-data-connector</strong>: REST API integration - See Chapter 20</li>
<li><strong>pan-graphql-connector</strong>: GraphQL integration - See Chapter 20</li>
<li><strong>pan-websocket</strong>: WebSocket connection management - See Chapter 20</li>
<li><strong>pan-idb</strong>: IndexedDB caching - See Chapter 18</li>
</ul>
<h2>Complete Example: Product Search with Caching</h2>
<pre><code class="language-javascript">class ProductSearch extends LarcComponent {
  constructor() {
    super();
    this.products = [];
    this.loading = false;
    this.error = null;
    this.searchTerm = &#039;&#039;;
    this.debounceTimer = null;
  }

  async connectedCallback() {
    // Load cached results
    const cached = this.getCache(&#039;products-all&#039;);
    if (cached) {
      this.products = cached;
      this.render();
    }

    // Fetch fresh data
    await this.loadProducts();
  }

  async loadProducts(search = &#039;&#039;) {
    this.loading = true;
    this.error = null;
    this.render();

    try {
      const url = search
        ? `/api/products/search?q=${encodeURIComponent(search)}`
        : &#039;/api/products&#039;;
      
      const response = await fetch(url);
      if (!response.ok) throw new Error(&#039;Search failed&#039;);

      this.products = await response.json();
      
      // Cache full product list only
      if (!search) {
        this.setCache(&#039;products-all&#039;, this.products, 5 * 60 * 1000);
      }
    } catch (err) {
      this.error = err.message;
    } finally {
      this.loading = false;
      this.render();
    }
  }

  handleSearchInput(event) {
    this.searchTerm = event.target.value;
    
    // Debounce search
    clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(() =&gt; {
      this.loadProducts(this.searchTerm);
    }, 300);
  }

  getCache(key) {
    const item = localStorage.getItem(`cache:${key}`);
    if (!item) return null;
    
    const { data, expires } = JSON.parse(item);
    return Date.now() &lt; expires ? data : null;
  }

  setCache(key, data, ttl) {
    localStorage.setItem(`cache:${key}`, JSON.stringify({
      data,
      expires: Date.now() + ttl
    }));
  }

  template() {
    return `
      &lt;div class=&quot;product-search&quot;&gt;
        &lt;input
          type=&quot;search&quot;
          placeholder=&quot;Search products...&quot;
          value=&quot;${this.searchTerm}&quot;
          oninput=&quot;this.handleSearchInput(event)&quot;&gt;

        ${this.loading ? &#039;&lt;div class=&quot;spinner&quot;&gt;Searching...&lt;/div&gt;&#039; : &#039;&#039;}
        ${this.error ? `&lt;div class=&quot;error&quot;&gt;${this.error}&lt;/div&gt;` : &#039;&#039;}

        &lt;div class=&quot;product-grid&quot;&gt;
          ${this.products.map(product =&gt; `
            &lt;div class=&quot;product-card&quot;&gt;
              &lt;img src=&quot;${product.image}&quot; alt=&quot;${product.name}&quot;&gt;
              &lt;h3&gt;${product.name}&lt;/h3&gt;
              &lt;p class=&quot;price&quot;&gt;$${product.price}&lt;/p&gt;
              &lt;button onclick=&quot;addToCart(${product.id})&quot;&gt;Add to Cart&lt;/button&gt;
            &lt;/div&gt;
          `).join(&#039;&#039;)}
        &lt;/div&gt;

        ${this.products.length === 0 &amp;&amp; !this.loading ? &#039;
          &lt;div class=&quot;no-results&quot;&gt;No products found&lt;/div&gt;
        &#039; : &#039;&#039;}
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;product-search&#039;, ProductSearch);</code></pre>
<h2>Cross-References</h2>
<ul><li><strong>Tutorial</strong>: <em>Learning LARC</em> Chapter 11 (Data Fetching and APIs)</li>
<li><strong>Components</strong>: Chapter 20 (pan-data-connector, pan-graphql-connector, pan-websocket)</li>
<li><strong>Patterns</strong>: Appendix E (API Integration Patterns)</li>
<li><strong>Related</strong>: Chapter 4 (State Management), Chapter 9 (Realtime Features)</li>
</ul>
<h2>Common Issues</h2>
<h3>Issue: CORS errors in development</h3>
<strong>Problem</strong>: <code>Access-Control-Allow-Origin</code> errors
<strong>Solution</strong>: Configure dev server proxy or add CORS headers to API
<h3>Issue: Stale cache data</h3>
<strong>Problem</strong>: Users see outdated information
<strong>Solution</strong>: Implement cache invalidation with TTL, version keys, or manual clear
<h3>Issue: Request waterfall</h3>
<strong>Problem</strong>: Sequential requests slow down page load
<strong>Solution</strong>: Batch requests, use GraphQL, or fetch data in parallel
<h3>Issue: Memory leaks from pending requests</h3>
<strong>Problem</strong>: Component unmounts but fetch continues
<strong>Solution</strong>: Use AbortController to cancel requests in <code>disconnectedCallback()</code>
<h3>Issue: Authentication tokens expired</h3>
<strong>Problem</strong>: 401 errors on API calls
<strong>Solution</strong>: Implement token refresh interceptor before retrying failed requests
<p>See <em>Learning LARC</em> Chapter 11 for detailed API patterns, authentication flows, and advanced caching strategies.</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/building-with-larc/chapters/07-data-fetching-and-apis.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
  <pan-bus debug="false"></pan-bus>
  <pan-theme-provider></pan-theme-provider>
</body>
</html>