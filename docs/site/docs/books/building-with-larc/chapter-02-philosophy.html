<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- CRITICAL: Load theme BEFORE CSS to prevent flash -->
  <script src="../../../../../playground/theme-init.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>The Philosophy of LARC · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - The Philosophy of LARC">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">building-with-larc</a> / <span>chapter-02-philosophy</span>
      </div>
      <article class="docs-content">
        <h1>The Philosophy of LARC</h1>
<h2>Introduction: Why Another Approach?</h2>
<p>If you've been developing web applications for any length of time, you've probably noticed that the complexity keeps climbing. Each year brings new tools, new frameworks, and new "best practices" that somehow require even more configuration files, build steps, and abstract concepts to master.</p>
<p>But here's the uncomfortable truth: most of this complexity isn't solving your actual problems. It's solving problems created by previous layers of abstraction.</p>
<p>LARC takes a different approach. Instead of adding another layer of abstraction on top of the existing stack, it asks a more fundamental question: <strong>What if we could build modern web applications using the platform itself?</strong></p>
<p>This chapter explores the philosophy behind LARC—the "why" that drives every design decision. Understanding this philosophy will help you use LARC more effectively and make better architectural decisions in your own projects.</p>
<h2>Build Tool Fatigue and the Web Components Promise</h2>
<h3>The Real Problem: Developer Onboarding Overhead</h3>
<p>Let's be honest about what actually drove the creation of LARC: <strong>build tool fatigue</strong>.</p>
<p>After years of watching developers spend more time configuring webpack, fighting with Babel, debugging TypeScript configs, and learning complex build pipelines than actually building features, it became clear that something was fundamentally wrong. New team members would join a project and spend their first week (or month!) learning the build system, understanding the toolchain, and navigating the maze of configuration files—all before they could write a single line of actual application code.</p>
<p>The barrier to entry had become absurd:</p>
<pre><code class="language-bash"># A typical modern project setup
npm install
# Wait 10 minutes
# Install 1,200+ dependencies
# 400MB of node_modules

# Then fight with:
- webpack.config.js (200 lines)
- babel.config.js
- tsconfig.json
- .eslintrc.js
- postcss.config.js
- vite.config.js
- And dozens more...</code></pre>
<p>This isn't what the web was supposed to be. The web platform itself requires none of this. You can write an HTML file, open it in a browser, and it works. So why did we accept all this complexity?</p>
<h3>The Web Components Disappointment</h3>
<p>Around the same time, Web Components promised to solve the reusability problem. The pitch was compelling: <strong>write a component once, use it anywhere</strong>. No framework lock-in. True portability. Native browser support. It sounded perfect.</p>
<p>But the reality was disappointing. Web Components solved the technical problem of creating custom elements, but they didn't solve the practical problem of building real applications. You still needed:</p>
<ul><li>A way to manage state across components</li>
<li>A way for components to communicate</li>
<li>A way to handle data fetching and updates</li>
<li>Build tools (ironically) for anything non-trivial</li>
</ul>
The most frustrating part was this: every web component I built ended up tightly coupled to its current context anyway. A "user-profile" component needed direct access to the user object. A "product-card" needed specific methods from a parent component. A "notification-list" needed to import the notification service directly.
<pre><code class="language-javascript">// This felt like defeat
class UserProfile extends HTMLElement {
  connectedCallback() {
    // Tightly coupled to global state
    const user = window.appState.user;

    // Tightly coupled to specific API
    this.api = window.userService;

    // Can&#039;t reuse this component in another project
    // because it depends on these specific globals
    this.render(user);
  }
}</code></pre>
<p>What was the point? Web Components were supposed to be <strong>reusable</strong>, but I was building components that were just as tightly coupled as any framework component—except now with extra steps of abstraction. The technology gave us encapsulation, but it didn't give us independence.</p>
<p>It felt like using a more verbose syntax to achieve the same result. Why write a Custom Element if it can't actually be portable? Why bother with the Web Components API if you still need to wire everything together manually with brittle global dependencies?</p>
<p>Web Components gave us the syntax for reusable components, but not the architecture for building with them. They became yet another piece that needed framework scaffolding around them to be useful.</p>
<h3>The PAN Experiment: How Far Can We Go?</h3>
<p>LARC started as a simple experiment with the <strong>PAN (Page Area Network) concept</strong>—a message bus for browser components inspired by MQTT and the Actor model. The initial question was straightforward: "What if components could communicate through messages instead of direct coupling?"</p>
<p>Of course, I knew about the pub/sub pattern. I knew that web components could technically communicate via <code>postMessage()</code> or <code>BroadcastChannel</code>. But here's the thing: both of those APIs are low-level primitives. They give you the <strong>mechanism</strong> for sending messages, but not the <strong>architecture</strong> for organizing them.</p>
<p>With <code>postMessage()</code>, you'd write code like this:</p>
<pre><code class="language-javascript">// Sender
window.postMessage({ type: &#039;USER_LOGIN&#039;, payload: user }, &#039;*&#039;);

// Receiver
window.addEventListener(&#039;message&#039;, (event) =&gt; {
  if (event.data.type === &#039;USER_LOGIN&#039;) {
    handleLogin(event.data.payload);
  }
});</code></pre>
<p>And with <code>BroadcastChannel</code>:</p>
<pre><code class="language-javascript">// Sender
const channel = new BroadcastChannel(&#039;app-events&#039;);
channel.postMessage({ type: &#039;USER_LOGIN&#039;, user: user });

// Receiver
const channel = new BroadcastChannel(&#039;app-events&#039;);
channel.onmessage = (event) =&gt; {
  if (event.data.type === &#039;USER_LOGIN&#039;) {
    handleLogin(event.data.user);
  }
};</code></pre>
<p>Both approaches have the same problem: <strong>every project rolls their own tightly coupled message format</strong>. You're back to the same coupling issues, just at a different level. Instead of coupling to <code>window.appState</code>, you're coupling to a specific message structure: <code>{ type: 'USER_LOGIN', payload: ... }</code> vs <code>{ type: 'USER_LOGIN', user: ... }</code>. Different projects would have different conventions, different payload shapes, different type naming schemes.</p>
<p>I saw this pattern repeated everywhere. Developers were independently creating custom messaging buses on top of <code>postMessage</code> and <code>BroadcastChannel</code>—each slightly different, each solving the same problems in slightly different ways. Everyone was building their own topic routing, their own message envelope format, their own subscription management.</p>
<p>It struck me: <strong>there should be a well-defined message standard</strong>. Not just "send messages," but a consistent format for:</p>
<ul><li><strong>Topic-based routing</strong>: <code>user.login</code> not <code>{ type: 'USER_LOGIN' }</code></li>
<li><strong>Message envelopes</strong>: Consistent structure with data, metadata, timestamps</li>
<li><strong>Subscription patterns</strong>: Wildcards like <code>user.<em></code> or <code></em>.login</code></li>
<li><strong>Retained messages</strong>: State that persists for late subscribers</li>
<li><strong>Lifecycle management</strong>: Automatic cleanup when components disconnect</li>
</ul>
The web had given us the transport layer (<code>BroadcastChannel</code>), but we needed an application layer—a protocol that components could depend on without coupling to specific implementations.
<p>That's when PAN moved from "let's try message passing" to "let's define a standard."</p>
<p>The moment this clicked was transformative. Instead of:</p>
<pre><code class="language-javascript">// Before: Tightly coupled
class UserProfile extends HTMLElement {
  connectedCallback() {
    const user = window.appState.user; // Coupled to specific global
    this.render(user);
  }
}</code></pre>
<p>Components could do this:</p>
<pre><code class="language-javascript">// After: Loosely coupled through messages
class UserProfile extends HTMLElement {
  connectedCallback() {
    // Subscribe to a topic - any component can publish to it
    panClient.subscribe(&#039;user.profile&#039;, ({ data }) =&gt; {
      this.render(data);
    });

    // Request current data
    panClient.publish(&#039;user.profile.request&#039;);
  }
}</code></pre>
<p>Now the component doesn't know <strong>where</strong> the user data comes from. It doesn't import anything. It doesn't depend on specific globals. It just subscribes to a topic. This component can be dropped into <strong>any</strong> project that has a PAN bus—different backend, different state management, different everything. As long as something publishes to 'user.profile', this component works.</p>
<strong>This</strong> was the reusability promise that Web Components couldn't deliver alone. The PAN bus provided the missing piece: a standard way for components to communicate without coupling.
<p>But that experiment led to a more interesting question: <strong>"How far can we go without any external, heavy, locked-in framework?"</strong></p>
<p>Not from an anti-framework ideology—frameworks solve real problems and have their place. But from a pragmatic curiosity: the web platform has matured dramatically over the past decade. The problems React and its contemporaries solved 15 years ago—managing DOM updates, providing component models, handling events, supporting modern JavaScript—have largely been addressed by open standards now:</p>
<ul><li><strong>Custom Elements</strong> provide a native component model</li>
<li><strong>ES Modules</strong> provide native code organization</li>
<li><strong>Shadow DOM</strong> provides style encapsulation</li>
<li><strong>JavaScript itself</strong> now has classes, async/await, destructuring, template literals</li>
<li><strong>CSS</strong> has custom properties, grid, flexbox, container queries</li>
<li><strong>Fetch API</strong> handles HTTP requests</li>
<li><strong>BroadcastChannel</strong> enables cross-context messaging</li>
</ul>
The question became: if we use these standards directly, without transpilation, without heavy frameworks, <strong>can we build real applications that are actually simpler to understand and maintain?</strong>
<h3>The Build System Burden</h3>
<p>Here's what really pushed the experiment forward: watching talented developers struggle not with code logic, not with algorithms, not with architecture—but with <strong>build configuration</strong>.</p>
<p>Consider this scenario (repeated countless times):</p>
<strong>Developer</strong>: "I need to add a simple feature—just fetch some data and display it."
<strong>Traditional Framework Workflow (React/Vue/Angular/etc.)</strong>:
<li>Pull latest code</li>
<li>Install/update dependencies (because the lockfile changed… again)</li>
<li>Create/update component file</li>
<li>Write fetch logic</li>
<li>Update state/store/actions</li>
<li>Update template/JSX</li>
<li>Update routing if needed</li>
<li>Update types/interfaces</li>
<li>Fix lint errors</li>
<li>Fix type errors</li>
<li>Start dev server (or wait for it to restart)</li>
<li>Wait for bundler to rebuild (don't forget about the source maps!)</li>
<li>Debug through layers of framework abstractions</li>
<li>Update tests and mocks</li>
<li>Commit changes</li>
<li>Push branch</li>
<li>Wait for CI: transpile, bundle, test, lint, type-check</li>
<li>Fix config/environment differences CI complains about</li>
<li>Merge when green</li>
<li>Build pipeline runs again for production artifacts</li>
<li>Deploy artifacts to server</li>
<li>Verify it works in production</li>
<strong>Time spent</strong>: 2 hours
<strong>Time actually coding</strong>: 15 minutes
<p>This is backwards. The tools should be invisible, not the primary challenge. Let's compare with the LARC workflow:</p>
<strong>LARC Workflow</strong>
<li>Pull latest code</li>
<li>Open component or create a new one</li>
<li>Write fetch logic using standard fetch()</li>
<li>Drop the results into the DOM (template literal, innerHTML, whatever fits)</li>
<li>Refresh browser tab</li>
<li>Debug directly in the browser with no abstraction layer</li>
<li>Commit + push</li>
<li>CI runs lint/tests (no build pipeline)</li>
<li>Deploy static files</li>
<li>Done</li>
<p>That’s it.   
No bundler.   
No transpiler.   
No dev server.   
No JSX.   
No toolchain waiting room.</p>
<h3>The Philosophy That Emerged</h3>
<p>These experiments crystallized LARC's core philosophy:</p>
<ul><li><strong>Use the platform.</strong> The web has matured. Build on standards directly instead of abstracting them away.</li>
<li><strong>Message-passing over shared state.</strong> Components that communicate through messages can truly be reused anywhere.</li>
<li><strong>Make builds optional.</strong> Use builds for production optimization, not as a development requirement.</li>
<li><strong>Enable true portability.</strong> Components that depend only on web standards and a lightweight message bus work in any project.</li>
</ul>
This isn't anti-framework ideology—React, Vue, and Svelte solve real problems. But for many projects, the web platform itself is sufficient. When it is, why take on unnecessary complexity?
<h2>Message-Passing Architecture: Learning from Distributed Systems</h2>
<h3>The Inspiration: Actor Model and Message Queues</h3>
<p>LARC's solution comes from distributed systems theory. When building systems with multiple independent processes, you don't use shared state—you use message passing. Each process maintains its own state and communicates with other processes by sending messages.</p>
<p>This pattern appears throughout computing:</p>
<ul><li><strong>Operating systems</strong>: Processes communicate via message queues</li>
<li><strong>Actor model</strong>: Erlang, Akka, and Orleans use message passing for concurrency</li>
<li><strong>Microservices</strong>: Services communicate via HTTP, message queues, or event streams</li>
<li><strong>MQTT</strong>: IoT devices coordinate through pub/sub messaging</li>
<li><strong>Event-driven architecture</strong>: Systems react to events without direct coupling</li>
</ul>
These patterns work because they solve fundamental problems:
<li><strong>Decoupling</strong>: Components don't need to know about each other</li>
<li><strong>Scalability</strong>: Add components without modifying existing ones</li>
<li><strong>Resilience</strong>: Failures are isolated and don't cascade</li>
<li><strong>Flexibility</strong>: Swap implementations without changing interfaces</li>
<p>LARC brings this pattern to the browser with the <strong>PAN (Page Area Network) bus</strong>—a publish/subscribe message system that allows components to communicate without knowing about each other.</p>
<h3>The PAN Bus: Pub/Sub for Components</h3>
<p>Here's how state management looks with the PAN bus:</p>
<pre><code class="language-javascript">// Publishing a message (any component can do this)
panClient.publish(&#039;cart.item.add&#039;, {
  id: &#039;product-123&#039;,
  name: &#039;Coffee Mug&#039;,
  price: 12.99,
  quantity: 1
}, { retain: true });

// Subscribing to messages (any component can listen)
panClient.subscribe(&#039;cart.item.add&#039;, ({ data }) =&gt; {
  console.log(&#039;Item added to cart:&#039;, data);
  updateCartDisplay();
});

// Multiple components can react to the same message
panClient.subscribe(&#039;cart.item.add&#039;, ({ data }) =&gt; {
  // Update cart count badge
  document.getElementById(&#039;cart-count&#039;).textContent =
    getCartItems().length;
});

panClient.subscribe(&#039;cart.item.add&#039;, ({ data }) =&gt; {
  // Show notification
  showNotification(`${data.name} added to cart`);
});</code></pre>
<p>No action creators. No reducers. No connect() functions. Just messages flowing through the system.</p>
<h3>Topic-Based Routing: Organization Without Central Control</h3>
<p>The PAN bus uses topic-based routing, similar to MQTT or RabbitMQ. Topics are hierarchical strings separated by dots:</p>
<pre><code class="language-plaintext">user.profile.update
cart.item.add
cart.item.remove
cart.checkout.start
inventory.product.update
ui.modal.open
ui.sidebar.toggle</code></pre>
<p>Components can subscribe to specific topics or use wildcards:</p>
<pre><code class="language-javascript">// Subscribe to specific topic
panClient.subscribe(&#039;cart.item.add&#039;, handler);

// Subscribe to all cart events
panClient.subscribe(&#039;cart.*&#039;, handler);

// Subscribe to all add events
panClient.subscribe(&#039;*.item.add&#039;, handler);

// Subscribe to everything
panClient.subscribe(&#039;*&#039;, handler);</code></pre>
<p>This creates natural organization:</p>
<ul><li><strong>Namespace separation</strong>: Different domains have different topic prefixes</li>
<li><strong>Granular subscriptions</strong>: Subscribe only to what you need</li>
<li><strong>Discoverability</strong>: Topic names describe what they do</li>
<li><strong>No central registry</strong>: Components define their own topics</li>
</ul>
<h3>Retained Messages: State Without Stores</h3>
<p>Traditional message buses are ephemeral—messages are delivered once and then disappear. But web applications need state: when a new component loads, it needs the current state, not just future updates.</p>
<p>LARC solves this with <strong>retained messages</strong>—the last message published to a topic can be stored and delivered to new subscribers:</p>
<pre><code class="language-javascript">// Publish with retention
panClient.publish(&#039;user.preferences.theme&#039;, &#039;dark&#039;, { retain: true });

// Later, a new component subscribes...
panClient.subscribe(&#039;user.preferences.theme&#039;, ({ data }) =&gt; {
  // Immediately receives &#039;dark&#039; even though it subscribed after publication
  applyTheme(data);
});</code></pre>
<p>This provides state management without a central store:</p>
<ul><li><strong>Current state</strong>: Retrieved by subscribing to retained topics</li>
<li><strong>State updates</strong>: Published as new messages</li>
<li><strong>No special API</strong>: Same subscribe() method works for both</li>
<li><strong>Automatic synchronization</strong>: New components automatically get current state</li>
</ul>
Think of retained messages as "stateful topics"—each topic can hold exactly one value, similar to a key in a key-value store, but with pub/sub semantics.
<h3>Benefits of Message-Passing</h3>
<p>Why is this better than centralized state management?</p>
<li><strong> Zero coupling between components</strong></li>
<p>Components don't import each other. They don't know each other exist. They just publish and subscribe to topics. This means:</p>
<ul><li><strong>Add components freely</strong>: New components can subscribe to existing topics</li>
<li><strong>Remove components safely</strong>: Unsubscribing doesn't break other components</li>
<li><strong>Test in isolation</strong>: Mock the bus, not the entire application state</li>
<li><strong>Reuse anywhere</strong>: Components work in any application with a PAN bus</li>
</ul>
<li><strong> Progressive complexity</strong></li>
<p>Start simple and add sophistication only when needed:</p>
<pre><code class="language-javascript">// Simple: Direct message handling
panClient.subscribe(&#039;cart.item.add&#039;, ({ data }) =&gt; {
  items.push(data);
  render();
});

// Advanced: Add validation
panClient.subscribe(&#039;cart.item.add&#039;, ({ data }) =&gt; {
  if (validateItem(data)) {
    items.push(data);
    render();
  } else {
    panClient.publish(&#039;cart.error&#039;, &#039;Invalid item&#039;);
  }
});

// Sophisticated: Add persistence
panClient.subscribe(&#039;cart.item.add&#039;, async ({ data }) =&gt; {
  if (validateItem(data)) {
    items.push(data);
    await saveToLocalStorage(items);
    panClient.publish(&#039;cart.synced&#039;, items);
    render();
  }
});</code></pre>
<p>No refactoring required. Just add features incrementally.</p>
<li><strong> Natural debugging</strong></li>
<p>Every message flows through the bus. Want to debug state changes? Subscribe to all topics:</p>
<pre><code class="language-javascript">// Development debugging
panClient.subscribe(&#039;*&#039;, ({ topic, data, meta }) =&gt; {
  console.log(`[${topic}]`, data, meta);
});</code></pre>
<p>Want to trace a specific feature? Subscribe to its topics:</p>
<pre><code class="language-javascript">// Track all cart operations
panClient.subscribe(&#039;cart.*&#039;, ({ topic, data }) =&gt; {
  console.log(&#039;Cart event:&#039;, topic, data);
});</code></pre>
<p>Compare this to stepping through Redux reducers or tracing Vue reactivity. Message-passing makes data flow explicit and observable.</p>
<li><strong> Multi-component coordination</strong></li>
<p>Traditional state management struggles with coordinating multiple components:</p>
<pre><code class="language-javascript">// Redux: Components must import actions and know about each other
import { openModal } from &#039;./modalActions&#039;;
import { pauseVideo } from &#039;./videoActions&#039;;
import { saveFormData } from &#039;./formActions&#039;;

function handleSaveAndClose() {
  dispatch(saveFormData(data));
  dispatch(pauseVideo());
  dispatch(openModal(&#039;confirmation&#039;));
}</code></pre>
<p>With message-passing, components coordinate through messages:</p>
<pre><code class="language-javascript">// Publisher doesn&#039;t know who&#039;s listening
panClient.publish(&#039;form.save.request&#039;, formData);

// Multiple components react independently
panClient.subscribe(&#039;form.save.request&#039;, ({ data }) =&gt; {
  // Form component saves data
  saveToDatabase(data);
});

panClient.subscribe(&#039;form.save.request&#039;, () =&gt; {
  // Video component pauses playback
  pauseVideo();
});

panClient.subscribe(&#039;form.save.request&#039;, () =&gt; {
  // Modal component shows confirmation
  showModal(&#039;confirmation&#039;);
});</code></pre>
<p>Each component handles its own concerns. No central coordinator needed.</p>
<h2>DOM-Native Communication Principles</h2>
<h3>Leveraging Existing Standards</h3>
<p>LARC doesn't invent new communication patterns—it leverages patterns already present in the DOM:</p>
<li><strong>Events</strong>: The DOM uses events for component interaction</li>
<li><strong>Attributes</strong>: Components configure via attributes</li>
<li><strong>Properties</strong>: JavaScript interfaces use properties</li>
<li><strong>Custom Elements</strong>: The browser provides a component system</li>
<p>The PAN bus extends these patterns to handle application-level communication:</p>
<pre><code class="language-html">&lt;!-- DOM events: Local communication --&gt;
&lt;button onclick=&quot;handleClick()&quot;&gt;Click me&lt;/button&gt;

&lt;!-- PAN messages: Application-level communication --&gt;
&lt;pan-button topic=&quot;ui.action.click&quot;&gt;Click me&lt;/pan-button&gt;</code></pre>
<p>This creates a natural mental model:</p>
<ul><li><strong>DOM events</strong> = Component-to-parent communication</li>
<li><strong>PAN messages</strong> = Component-to-application communication</li>
<li><strong>Attributes</strong> = Configuration</li>
<li><strong>Properties</strong> = JavaScript API</li>
</ul>
<h3>BroadcastChannel: The Foundation</h3>
<p>Under the hood, LARC can use the browser's <code>BroadcastChannel</code> API—a standard way to communicate between browser contexts (tabs, windows, iframes, workers):</p>
<pre><code class="language-javascript">// Native BroadcastChannel
const channel = new BroadcastChannel(&#039;my-app&#039;);
channel.postMessage({ type: &#039;update&#039;, data: &#039;value&#039; });
channel.onmessage = (event) =&gt; {
  console.log(&#039;Received:&#039;, event.data);
};</code></pre>
<p>The PAN bus builds on this foundation but adds:</p>
<ul><li>Topic-based routing with wildcards</li>
<li>Retained messages for state</li>
<li>Message metadata and timestamps</li>
<li>Synchronous and asynchronous delivery</li>
<li>Type safety and validation (optional)</li>
</ul>
By building on web standards, LARC remains simple, debuggable, and future-proof.
<h3>Custom Elements: Native Components</h3>
<p>LARC components are standard Custom Elements:</p>
<pre><code class="language-javascript">class PanCard extends HTMLElement {
  connectedCallback() {
    this.render();

    // Subscribe to theme changes
    this.subscription = panClient.subscribe(&#039;theme.change&#039;, ({ data }) =&gt; {
      this.applyTheme(data);
    });
  }

  disconnectedCallback() {
    // Clean up subscriptions
    this.subscription.unsubscribe();
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;card&quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;pan-card&#039;, PanCard);</code></pre>
<p>No framework required. Just standard Web Components that happen to communicate via the PAN bus.</p>
<h2>Zero-Dependency, Zero-Build Philosophy</h2>
<p>We've already seen the problems with build tool complexity. LARC's solution is straightforward: use only features that browsers understand natively—ES Modules, standard JavaScript (ES2015+), CSS Custom Properties, and Web Components.</p>
<p>The result is the simple development workflow shown earlier: edit a file, refresh the browser, see changes instantly. No bundler, no transpiler, no waiting.</p>
<h3>But What About Production?</h3>
<p>The zero-build philosophy applies to <strong>development</strong>, not necessarily production. For production, you can (and often should) use build tools:</p>
<pre><code class="language-bash"># Production build with Vite (optional)
vite build

# Result: Minified, tree-shaken, optimized bundle</code></pre>
<p>But here's the key difference: <strong>builds are optional, not required</strong>.</p>
<ul><li>Developing locally? No build needed.</li>
<li>Prototyping? No build needed.</li>
<li>Small sites? Deploy directly, no build needed.</li>
<li>Large applications? Add a build for optimization.</li>
</ul>
The build is an optimization, not a requirement.
<h2>Progressive Enhancement and Graceful Degradation</h2>
<h3>Layering Functionality</h3>
<p>LARC embraces the web's fundamental principle: <strong>progressive enhancement</strong>. Start with a basic HTML structure that works, then enhance it with JavaScript.</p>
<strong>Level 0: Static HTML</strong>
<pre><code class="language-html">&lt;article class=&quot;card&quot;&gt;
  &lt;h2&gt;Product Name&lt;/h2&gt;
  &lt;p&gt;Description of the product&lt;/p&gt;
  &lt;a href=&quot;/product/123&quot;&gt;View Details&lt;/a&gt;
&lt;/article&gt;</code></pre>
<p>Works everywhere. No JavaScript required. Search engines can index it. Screen readers can navigate it.</p>
<strong>Level 1: Basic Web Component</strong>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
  class ProductCard extends HTMLElement {
    connectedCallback() {
      const product = JSON.parse(this.getAttribute(&#039;data-product&#039;));
      this.innerHTML = `
        &lt;article class=&quot;card&quot;&gt;
          &lt;h2&gt;${product.name}&lt;/h2&gt;
          &lt;p&gt;${product.description}&lt;/p&gt;
          &lt;a href=&quot;/product/${product.id}&quot;&gt;View Details&lt;/a&gt;
        &lt;/article&gt;
      `;
    }
  }
  customElements.define(&#039;product-card&#039;, ProductCard);
&lt;/script&gt;

&lt;product-card data-product=&#039;{&quot;name&quot;:&quot;Product&quot;,&quot;description&quot;:&quot;Description&quot;,&quot;id&quot;:&quot;123&quot;}&#039;&gt;&lt;/product-card&gt;</code></pre>
<p>Enhanced with JavaScript, but the content is still in the DOM. Still indexable. Still accessible.</p>
<strong>Level 2: PAN Integration</strong>
<pre><code class="language-javascript">class ProductCard extends HTMLElement {
  connectedCallback() {
    // Subscribe to product updates
    this.subscription = panClient.subscribe(
      `product.${this.productId}.*`,
      ({ data }) =&gt; this.update(data)
    );

    // Request current data
    panClient.publish(`product.${this.productId}.fetch`, null);
  }

  disconnectedCallback() {
    this.subscription.unsubscribe();
  }

  update(data) {
    this.render(data);
  }
}</code></pre>
<p>Now the component participates in the application's message flow. It reacts to updates, coordinates with other components, and manages state.</p>
<strong>Level 3: Advanced Features</strong>
<pre><code class="language-javascript">class ProductCard extends HTMLElement {
  connectedCallback() {
    // Theme support
    panClient.subscribe(&#039;theme.change&#039;, ({ data }) =&gt; {
      this.applyTheme(data);
    });

    // Internationalization
    panClient.subscribe(&#039;locale.change&#039;, ({ data }) =&gt; {
      this.updateLocale(data);
    });

    // Real-time updates
    panClient.subscribe(`product.${this.productId}.update`, ({ data }) =&gt; {
      this.animateUpdate(data);
    });

    // Analytics
    this.addEventListener(&#039;click&#039;, () =&gt; {
      panClient.publish(&#039;analytics.event&#039;, {
        type: &#039;product-click&#039;,
        id: this.productId
      });
    });
  }
}</code></pre>
<p>Each layer adds functionality without breaking previous layers. If JavaScript fails to load, the HTML still works. If the PAN bus isn't available, the component still renders.</p>
<h3>Graceful Degradation</h3>
<p>Progressive enhancement works in reverse too. As capabilities decrease, functionality gracefully degrades:</p>
<pre><code class="language-javascript">class EnhancedComponent extends HTMLElement {
  connectedCallback() {
    // Check for Web Components support (already guaranteed if this runs)

    // Check for ES Modules support
    if (&#039;noModule&#039; in HTMLScriptElement.prototype) {
      this.enableModuleFeatures();
    }

    // Check for Shadow DOM support
    if (this.attachShadow) {
      this.attachShadow({ mode: &#039;open&#039; });
      this.useShadowDOM = true;
    } else {
      // Fallback: Light DOM with scoped styles
      this.useShadowDOM = false;
    }

    // Check for BroadcastChannel (for cross-tab sync)
    if (&#039;BroadcastChannel&#039; in window) {
      this.enableCrossTabSync();
    }

    // Check for IndexedDB (for persistence)
    if (&#039;indexedDB&#039; in window) {
      this.enablePersistence();
    } else {
      // Fallback: localStorage
      this.enableBasicStorage();
    }

    this.render();
  }
}</code></pre>
<p>The component adapts to available APIs. It doesn't require cutting-edge features—it enhances the experience when they're available.</p>
<h3>Browser Support Strategy</h3>
<p>LARC targets modern browsers (Chrome 90+, Firefox 88+, Safari 14+, Edge 90+) that support:</p>
<ul><li>Custom Elements v1</li>
<li>Shadow DOM v1</li>
<li>ES Modules</li>
<li>ES2020 features</li>
</ul>
This covers 95%+ of global users. For the remaining 5%, you have options:
<strong>Option 1: Polyfills</strong>
<p>Load polyfills for older browsers:</p>
<pre><code class="language-html">&lt;script src=&quot;https://unpkg.com/@webcomponents/webcomponentsjs@2/webcomponents-loader.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;module&quot; src=&quot;/src/app.mjs&quot;&gt;&lt;/script&gt;</code></pre>
<strong>Option 2: Build Step</strong>
<p>For maximum compatibility, add a production build that transpiles to ES5:</p>
<pre><code class="language-bash">vite build --target es2015</code></pre>
<strong>Option 3: Server-Side Rendering</strong>
<p>Render content on the server for browsers without JavaScript:</p>
<pre><code class="language-javascript">// Node.js
import { renderToString } from &#039;@larcjs/ssr&#039;;
const html = renderToString(&#039;&lt;pan-card&gt;Hello&lt;/pan-card&gt;&#039;);</code></pre>
<p>But here's the key: these are <strong>optimizations</strong>, not requirements. Start with modern browsers and add compatibility only if needed.</p>
<h2>Comparison to Other Approaches</h2>
<h3>LARC vs. Redux</h3>
<strong>Redux:</strong>
<pre><code class="language-javascript">// Redux requires significant boilerplate

// 1. Define action types
const ADD_ITEM = &#039;ADD_ITEM&#039;;
const REMOVE_ITEM = &#039;REMOVE_ITEM&#039;;
const UPDATE_ITEM = &#039;UPDATE_ITEM&#039;;

// 2. Create action creators
const addItem = (item) =&gt; ({ type: ADD_ITEM, payload: item });
const removeItem = (id) =&gt; ({ type: REMOVE_ITEM, payload: id });
const updateItem = (id, data) =&gt; ({ type: UPDATE_ITEM, payload: { id, data } });

// 3. Write reducer
function itemsReducer(state = [], action) {
  switch (action.type) {
    case ADD_ITEM:
      return [...state, action.payload];
    case REMOVE_ITEM:
      return state.filter(item =&gt; item.id !== action.payload);
    case UPDATE_ITEM:
      return state.map(item =&gt;
        item.id === action.payload.id
          ? { ...item, ...action.payload.data }
          : item
      );
    default:
      return state;
  }
}

// 4. Create store
const store = createStore(combineReducers({ items: itemsReducer }));

// 5. Connect components
const mapStateToProps = (state) =&gt; ({ items: state.items });
const mapDispatchToProps = { addItem, removeItem, updateItem };
export default connect(mapStateToProps, mapDispatchToProps)(ItemList);</code></pre>
<strong>LARC:</strong>
<pre><code class="language-javascript">// LARC uses message-passing - no boilerplate

// Publish messages
panClient.publish(&#039;items.add&#039;, item, { retain: true });
panClient.publish(&#039;items.remove&#039;, id);
panClient.publish(&#039;items.update&#039;, { id, data });

// Subscribe in components
panClient.subscribe(&#039;items.*&#039;, ({ topic, data }) =&gt; {
  if (topic.endsWith(&#039;.add&#039;)) {
    items.push(data);
  } else if (topic.endsWith(&#039;.remove&#039;)) {
    items = items.filter(item =&gt; item.id !== data);
  } else if (topic.endsWith(&#039;.update&#039;)) {
    items = items.map(item =&gt;
      item.id === data.id ? { ...item, ...data.data } : item
    );
  }
  render();
});</code></pre>
<strong>Key Differences:</strong>
<p>| <strong>Redux</strong>     | <strong>LARC</strong> |
|---------------|----------|
| Centralized store, reducers, actions, selectors | Distributed messages, topics, subscribers |
| All state in one place | State distributed across components |
| Components coupled to store | Components coupled only to topics |
| Requires setup and configuration | Just publish and subscribe |</p>
<strong>When Redux is better:</strong>
<ul><li>Need single source of truth</li>
<li>Complex state transformations</li>
<li>Time-travel debugging is essential</li>
<li>Team is already trained in Redux</li>
</ul>
<strong>When LARC is better:</strong>
<ul><li>Loosely coupled components</li>
<li>Progressive enhancement</li>
<li>Mix of frameworks</li>
<li>Simple message-driven logic</li>
</ul>
<h3>Other State Management Approaches</h3>
<p>The same pattern applies to other state management solutions. Vuex (Vue), MobX, and React Context all share similar characteristics: centralized state, framework-specific APIs, and various degrees of boilerplate. LARC's message-passing approach offers a framework-agnostic alternative with explicit data flow.</p>
<h3>Summary: Architectural Trade-offs</h3>
<p>| Feature | Redux | Vuex | MobX | Context | LARC |
|---------|-------|------|------|---------|------|
| Learning curve | Steep | Medium | Medium | Low | Low |
| Boilerplate | High | Medium | Low | Low | Minimal |
| Framework lock-in | No<em> | Yes | No</em> | Yes | No |
| Testability | Excellent | Good | Good | Fair | Excellent |
| DevTools | Excellent | Excellent | Good | Limited | Good |
| Bundle size | ~8KB | ~3KB | ~16KB | 0KB | ~5KB |
| Async handling | Middleware | Built-in | Built-in | Manual | Manual |
| Type safety | Good | Fair | Excellent | Good | Optional |
| Cross-framework | Possible | No | Possible | No | Yes |
| Component coupling | Store | Store | Store | Context | Topics |</p>
<p>*Requires framework integration libraries</p>
<strong>LARC's sweet spot:</strong>
<ul><li>You need loose coupling between components</li>
<li>You're mixing frameworks or using vanilla JS</li>
<li>You want simple, explicit data flow</li>
<li>You value progressive enhancement</li>
<li>You want minimal dependencies</li>
</ul>
<strong>LARC's limitations:</strong>
<ul><li>No automatic reactivity (explicit subscriptions required)</li>
<li>No built-in transaction/rollback</li>
<li>No built-in middleware system (yet)</li>
<li>No official browser DevTools extension (yet)</li>
</ul>
<h2>Additional Practical Benefits</h2>
<p>Beyond the architectural advantages, LARC offers practical benefits for everyday development:</p>
<h3>Simplified Component Testing</h3>
<strong>Traditional approach:</strong>
<p>Testing a Redux-connected component requires:</p>
<pre><code class="language-javascript">import { Provider } from &#039;react-redux&#039;;
import configureMockStore from &#039;redux-mock-store&#039;;
import { render } from &#039;@testing-library/react&#039;;

const mockStore = configureMockStore();
const store = mockStore({
  items: [],
  user: { name: &#039;Test&#039; },
  theme: &#039;light&#039;
});

test(&#039;renders item list&#039;, () =&gt; {
  render(
    &lt;Provider store={store}&gt;
      &lt;ItemList /&gt;
    &lt;/Provider&gt;
  );
  // Test assertions...
});</code></pre>
<p>You have to:</p>
<li>Mock the entire store</li>
<li>Provide store structure</li>
<li>Wrap component in Provider</li>
<li>Understand Redux internals</li>
<strong>LARC approach:</strong>
<pre><code class="language-javascript">import { mockPanClient } from &#039;@larcjs/testing&#039;;

test(&#039;renders item list&#039;, () =&gt; {
  const client = mockPanClient();
  const itemList = document.createElement(&#039;item-list&#039;);
  document.body.appendChild(itemList);

  // Publish test data
  client.publish(&#039;items.list&#039;, [
    { id: 1, name: &#039;Item 1&#039; },
    { id: 2, name: &#039;Item 2&#039; }
  ], { retain: true });

  // Test assertions on DOM...
});</code></pre>
<p>Simpler. Mock the message bus, not the entire application state.</p>
<h3>Multi-Tab Synchronization</h3>
<strong>Traditional approach:</strong>
<p>Synchronizing state across browser tabs is painful:</p>
<pre><code class="language-javascript">// Tab 1: Update state
localStorage.setItem(&#039;user&#039;, JSON.stringify(user));

// Tab 2: Poll for changes
setInterval(() =&gt; {
  const stored = localStorage.getItem(&#039;user&#039;);
  const user = JSON.parse(stored);
  updateState(user);
}, 1000);

// Or use storage events (but they&#039;re clunky)
window.addEventListener(&#039;storage&#039;, (e) =&gt; {
  if (e.key === &#039;user&#039;) {
    updateState(JSON.parse(e.newValue));
  }
});</code></pre>
<strong>LARC approach:</strong>
<p>LARC can use <code>BroadcastChannel</code> for cross-tab communication:</p>
<pre><code class="language-javascript">// Tab 1: Publish message
panClient.publish(&#039;user.update&#039;, user, { retain: true });

// Tab 2: Automatically receives message
panClient.subscribe(&#039;user.update&#039;, ({ data }) =&gt; {
  updateState(data);
});

// No polling. No storage events. Just messages.</code></pre>
<p>Tabs stay synchronized automatically through the PAN bus.</p>
<h2>Conclusion: A Pragmatic Philosophy</h2>
<p>LARC's philosophy can be summarized in a few principles:</p>
<li><strong>Build on standards, not abstractions</strong> — Use what browsers provide natively</li>
<li><strong>Message-passing over shared state</strong> — Loose coupling through pub/sub</li>
<li><strong>Zero-build development</strong> — Edit code and see results immediately</li>
<li><strong>Progressive enhancement</strong> — Start simple, add complexity only when needed</li>
<li><strong>Framework-agnostic</strong> — Components work everywhere</li>
<li><strong>Explicit over implicit</strong> — Data flow should be obvious</li>
<p>This philosophy makes trade-offs:</p>
<strong>What you gain:</strong>
<ul><li>Simplicity</li>
<li>Portability</li>
<li>Debuggability</li>
<li>Fast iteration</li>
<li>Low barrier to entry</li>
</ul>
<strong>What you give up:</strong>
<ul><li>Automatic reactivity</li>
<li>Framework-specific optimizations</li>
<li>Established ecosystem</li>
<li>Corporate backing</li>
</ul>
Is LARC right for your project? Consider these questions:
<ul><li>Do you value simplicity over framework features?</li>
<li>Do you need components that work across frameworks?</li>
<li>Do you want fast iteration during development?</li>
<li>Are you comfortable with explicit data flow?</li>
<li>Do you prefer standards over abstractions?</li>
</ul>
If you answered "yes" to most of these, LARC might be a good fit.
<p>In the next chapter, we'll explore the story of LARC—how it came to be, the design decisions along the way, and the real-world use cases that shaped its development.</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/building-with-larc/chapter-02-philosophy.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
  <pan-bus debug="false"></pan-bus>
  <pan-theme-provider></pan-theme-provider>
</body>
</html>