<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Business Logic Patterns · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Business Logic Patterns">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">learning-larc</a> / <a href="#">chapters</a> / <span>08-business-logic-patterns</span>
      </div>
      <article class="docs-content">
        <h1>Business Logic Patterns</h1>
<p>In the previous chapters, we've learned how to build components, communicate via the PAN bus, and manage state. But when building real-world applications, you'll inevitably need to inject your own custom business logic: validation rules, pricing calculations, access control, analytics tracking, and countless other domain-specific concerns.</p>
<p>A common question developers ask when adopting LARC is: <em>"Where do I put my business logic?"</em> This chapter explores the architectural patterns for integrating business logic into LARC applications, helping you make informed decisions about code organization and separation of concerns.</p>
<h2>The Philosophy: Separation of Concerns</h2>
<p>LARC's architecture naturally encourages a clean separation between:</p>
<ul><li><strong>Components</strong>: UI and interaction concerns</li>
<li><strong>PAN Bus</strong>: Communication layer</li>
<li><strong>Business Logic</strong>: Domain rules and workflows</li>
</ul>
This separation isn't just academic—it makes your code:
<ul><li><strong>Testable</strong>: Logic can be tested independently of UI</li>
<li><strong>Maintainable</strong>: Changes to business rules don't require touching components</li>
<li><strong>Reusable</strong>: Logic can be shared across multiple components</li>
<li><strong>Flexible</strong>: Easy to modify workflows without refactoring components</li>
</ul>
Let's explore the patterns that make this possible.
<h2>Pattern 1: PAN Bus Listeners (Recommended)</h2>
<p>The most common and recommended approach is to create separate modules that listen to PAN bus events and implement your business logic. This pattern treats business logic as a <strong>first-class concern</strong>, separate from both UI components and state management.</p>
<h3>When to Use</h3>
<p>Use PAN bus listeners when you need to:</p>
<ul><li>Coordinate behavior across multiple components</li>
<li>Implement cross-cutting concerns (analytics, logging, validation)</li>
<li>Add business rules that aren't tied to a specific component</li>
<li>Keep components generic and reusable</li>
</ul>
<h3>Basic Implementation</h3>
<p>Let's build an e-commerce application where we need to enforce business rules around cart operations:</p>
<pre><code class="language-javascript">// business-logic/cart-rules.js
import { pan } from &#039;@larcjs/core&#039;;

class CartBusinessRules {
  constructor() {
    this.maxItemsPerOrder = 50;
    this.maxQuantityPerItem = 10;
  }

  init() {
    // Subscribe to cart events
    pan.subscribe(&#039;cart.item.add&#039;, this.handleItemAdd.bind(this));
    pan.subscribe(&#039;cart.item.update&#039;, this.handleItemUpdate.bind(this));
    pan.subscribe(&#039;cart.checkout.start&#039;, this.handleCheckout.bind(this));
  }

  async handleItemAdd(data) {
    console.log(&#039;Business rule: Validating item add&#039;, data);

    // Check current cart state
    const currentCart = await pan.request(&#039;cart.get&#039;);

    // Business Rule 1: Maximum items per order
    if (currentCart.items.length &gt;= this.maxItemsPerOrder) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;MAX_ITEMS_EXCEEDED&#039;,
        message: `Cannot add more than ${this.maxItemsPerOrder} items to cart`
      });
      return;
    }

    // Business Rule 2: Check inventory
    const available = await this.checkInventory(data.product.id);
    if (!available || available &lt; data.quantity) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;INSUFFICIENT_INVENTORY&#039;,
        message: &#039;This item is currently out of stock&#039;,
        product: data.product
      });
      return;
    }

    // Business Rule 3: Apply pricing
    const pricing = await this.calculatePrice(data.product, data.quantity);

    // All validations passed - allow the add and publish enriched data
    pan.publish(&#039;cart.item.validated&#039;, {
      ...data,
      pricing,
      timestamp: Date.now()
    });
  }

  async handleItemUpdate(data) {
    // Business Rule: Quantity limits
    if (data.quantity &gt; this.maxQuantityPerItem) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;MAX_QUANTITY_EXCEEDED&#039;,
        message: `Maximum ${this.maxQuantityPerItem} per item`
      });
      return;
    }

    // Check inventory for new quantity
    const available = await this.checkInventory(data.productId);
    if (available &lt; data.quantity) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;INSUFFICIENT_INVENTORY&#039;,
        message: `Only ${available} available`,
        available
      });
      return;
    }

    pan.publish(&#039;cart.item.update.validated&#039;, data);
  }

  async handleCheckout(data) {
    // Business Rule: Minimum order value
    const cart = await pan.request(&#039;cart.get&#039;);
    const total = cart.items.reduce((sum, item) =&gt; sum + item.total, 0);

    if (total &lt; 10) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;MINIMUM_ORDER_NOT_MET&#039;,
        message: &#039;Minimum order value is $10&#039;,
        current: total,
        required: 10
      });
      return;
    }

    // Business Rule: User must be logged in
    const user = await pan.request(&#039;auth.user.get&#039;);
    if (!user) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;AUTH_REQUIRED&#039;,
        message: &#039;Please log in to continue&#039;
      });
      return;
    }

    pan.publish(&#039;checkout.validated&#039;, { cart, user });
  }

  async checkInventory(productId) {
    // In real app, this would call your backend
    const response = await fetch(`/api/inventory/${productId}`);
    const data = await response.json();
    return data.available;
  }

  async calculatePrice(product, quantity) {
    // Apply business logic: bulk discounts, promotions, etc.
    let unitPrice = product.price;

    // Bulk discount: 10% off for 5+ items
    if (quantity &gt;= 5) {
      unitPrice = unitPrice * 0.9;
    }

    // TODO: Check for active promotions
    // TODO: Apply user-specific pricing

    return {
      unitPrice,
      quantity,
      subtotal: unitPrice * quantity,
      discount: quantity &gt;= 5 ? (product.price - unitPrice) * quantity : 0
    };
  }
}

// Initialize and export
const cartRules = new CartBusinessRules();
export default cartRules;</code></pre>
<p>Now in your main application file:</p>
<pre><code class="language-javascript">// app.js
import { pan } from &#039;@larcjs/core&#039;;
import cartRules from &#039;./business-logic/cart-rules.js&#039;;

// Initialize business logic
cartRules.init();

// Your components just publish events - the business logic handles the rest
// No business logic in components themselves!</code></pre>
<p>Your components remain simple and focused on UI:</p>
<pre><code class="language-javascript">// components/product-card.js
class ProductCard extends HTMLElement {
  // ... component setup ...

  handleAddToCart() {
    // Just publish the event - business logic will validate
    pan.publish(&#039;cart.item.add&#039;, {
      product: this.product,
      quantity: this.quantity
    });

    // Show optimistic UI
    this.showAddingState();
  }

  connectedCallback() {
    super.connectedCallback();

    // Listen for validation results
    this.unsubscribers = [
      pan.subscribe(&#039;cart.item.validated&#039;, (data) =&gt; {
        if (data.product.id === this.product.id) {
          this.showSuccess();
        }
      }),

      pan.subscribe(&#039;cart.error&#039;, (error) =&gt; {
        this.showError(error.message);
      })
    ];
  }
}</code></pre>
<h3>Advantages</h3>
<p>This pattern provides several key benefits:</p>
<li><strong>Separation of Concerns</strong>: Components handle UI, business logic modules handle rules</li>
<li><strong>Easy Testing</strong>: Test business logic without rendering components</li>
<li><strong>Centralized Rules</strong>: All cart rules in one place, easy to modify</li>
<li><strong>Reusable</strong>: Multiple components can trigger the same logic</li>
<li><strong>Flexible</strong>: Easy to add, remove, or modify rules</li>
<h3>Advanced: Composable Business Logic</h3>
<p>For larger applications, you can compose multiple business logic modules:</p>
<pre><code class="language-javascript">// business-logic/index.js
import { pan } from &#039;@larcjs/core&#039;;
import cartRules from &#039;./cart-rules.js&#039;;
import pricingRules from &#039;./pricing-rules.js&#039;;
import inventoryRules from &#039;./inventory-rules.js&#039;;
import analyticsRules from &#039;./analytics-rules.js&#039;;

export function initBusinessLogic() {
  console.log(&#039;Initializing business logic...&#039;);

  // Initialize all business logic modules
  cartRules.init();
  pricingRules.init();
  inventoryRules.init();
  analyticsRules.init();

  console.log(&#039;Business logic ready&#039;);
}</code></pre>
<pre><code class="language-javascript">// app.js
import { initBusinessLogic } from &#039;./business-logic/index.js&#039;;

// Single call to initialize all business logic
initBusinessLogic();</code></pre>
<h2>Pattern 2: Extending Components</h2>
<p>Sometimes you need to add business logic directly to a component, especially when:</p>
<ul><li>The logic is specific to one component type</li>
<li>You need to override component behavior</li>
<li>You're creating specialized versions of generic components</li>
</ul>
<h3>When to Use</h3>
<p>Use component extension when:</p>
<ul><li>Logic is tightly coupled to component rendering</li>
<li>You need access to component internals (Shadow DOM, private methods)</li>
<li>Creating specialized variants of base components</li>
<li>Logic doesn't need to be shared across different component types</li>
</ul>
<h3>Implementation</h3>
<p>Let's extend a generic product card with business-specific behavior:</p>
<pre><code class="language-javascript">// components/base/product-card.js
export class ProductCard extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        /* Base styles */
      &lt;/style&gt;
      &lt;div class=&quot;card&quot;&gt;
        &lt;img src=&quot;${this.product.image}&quot; alt=&quot;${this.product.name}&quot;&gt;
        &lt;h3&gt;${this.product.name}&lt;/h3&gt;
        &lt;p class=&quot;price&quot;&gt;${this.formatPrice(this.product.price)}&lt;/p&gt;
        &lt;button class=&quot;add-to-cart&quot;&gt;Add to Cart&lt;/button&gt;
      &lt;/div&gt;
    `;

    this.shadowRoot.querySelector(&#039;.add-to-cart&#039;)
      .addEventListener(&#039;click&#039;, () =&gt; this.handleAddToCart());
  }

  handleAddToCart() {
    pan.publish(&#039;cart.item.add&#039;, {
      product: this.product,
      quantity: 1
    });
  }

  formatPrice(price) {
    return `$${price.toFixed(2)}`;
  }

  get product() {
    return JSON.parse(this.getAttribute(&#039;product&#039;));
  }
}

customElements.define(&#039;product-card&#039;, ProductCard);</code></pre>
<p>Now extend it with business-specific logic:</p>
<pre><code class="language-javascript">// components/premium-product-card.js
import { ProductCard } from &#039;./base/product-card.js&#039;;

export class PremiumProductCard extends ProductCard {
  connectedCallback() {
    super.connectedCallback();

    // Add business-specific subscriptions
    this._unsubscribers = [
      pan.subscribe(&#039;pricing.update&#039;, this.handlePriceUpdate.bind(this)),
      pan.subscribe(&#039;user.tier.changed&#039;, this.handleTierChange.bind(this))
    ];

    // Initialize premium features
    this.loadMemberPricing();
  }

  async loadMemberPricing() {
    const user = await pan.request(&#039;auth.user.get&#039;);
    if (user?.tier === &#039;premium&#039;) {
      this.applyPremiumDiscount();
    }
  }

  applyPremiumDiscount() {
    // Business Rule: 15% discount for premium members
    const discount = 0.15;
    const originalPrice = this.product.price;
    const discountedPrice = originalPrice * (1 - discount);

    this.product.price = discountedPrice;
    this.product.originalPrice = originalPrice;

    this.render(); // Re-render with new price
  }

  render() {
    // Call parent render
    super.render();

    // Add premium badge if applicable
    if (this.product.originalPrice) {
      this.addPremiumBadge();
    }
  }

  addPremiumBadge() {
    const badge = document.createElement(&#039;div&#039;);
    badge.className = &#039;premium-badge&#039;;
    badge.innerHTML = `
      &lt;style&gt;
        .premium-badge {
          position: absolute;
          top: 10px;
          right: 10px;
          background: gold;
          color: black;
          padding: 5px 10px;
          border-radius: 3px;
          font-weight: bold;
        }
        .original-price {
          text-decoration: line-through;
          color: #999;
          font-size: 0.9em;
        }
      &lt;/style&gt;
      &lt;span&gt;Premium Member&lt;/span&gt;
      &lt;div class=&quot;original-price&quot;&gt;
        ${this.formatPrice(this.product.originalPrice)}
      &lt;/div&gt;
    `;

    this.shadowRoot.querySelector(&#039;.card&#039;).prepend(badge);
  }

  async handleAddToCart() {
    // Business validation before adding
    const canAddPremiumItem = await this.validatePremiumAccess();

    if (!canAddPremiumItem) {
      pan.publish(&#039;app.error&#039;, {
        message: &#039;Premium membership required for this product&#039;
      });
      return;
    }

    // Track premium conversions
    this.trackPremiumConversion();

    // Call parent behavior
    super.handleAddToCart();
  }

  async validatePremiumAccess() {
    if (!this.product.premiumOnly) return true;

    const user = await pan.request(&#039;auth.user.get&#039;);
    return user?.tier === &#039;premium&#039;;
  }

  trackPremiumConversion() {
    pan.publish(&#039;analytics.track&#039;, {
      event: &#039;premium_product_add_to_cart&#039;,
      product: this.product.id,
      price: this.product.price,
      discount: this.product.originalPrice - this.product.price
    });
  }

  handlePriceUpdate(data) {
    if (data.productId === this.product.id) {
      this.product.price = data.newPrice;
      this.render();
    }
  }

  handleTierChange(data) {
    // User tier changed - recalculate pricing
    this.loadMemberPricing();
  }

  disconnectedCallback() {
    // Clean up subscriptions
    this._unsubscribers.forEach(unsub =&gt; unsub());
    super.disconnectedCallback?.();
  }
}

customElements.define(&#039;premium-product-card&#039;, PremiumProductCard);</code></pre>
<h3>When This Makes Sense</h3>
<p>Component extension works well when:</p>
<li><strong>The logic changes how the component renders or behaves</strong></li>
<li><strong>You need multiple variants of a base component</strong> (premium, free, guest, etc.)</li>
<li><strong>Business logic is closely tied to component lifecycle</strong></li>
<p>However, be cautious: overuse of extension can lead to:</p>
<ul><li>Tight coupling between business logic and UI</li>
<li>Harder to test business rules independently</li>
<li>Duplication if multiple components need the same logic</li>
</ul>
<h2>Pattern 3: Wrapper Components</h2>
<p>Wrapper components let you add behavior around existing components without modifying them. This is useful when you want to:</p>
<ul><li>Add behavior to third-party components</li>
<li>Keep base components pristine</li>
<li>Compose behaviors dynamically</li>
</ul>
<h3>Implementation</h3>
<pre><code class="language-javascript">// components/business-wrapper.js
class BusinessWrapper extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    // Intercept events from slotted content
    this.addEventListener(&#039;add-to-cart&#039;, this.handleBusinessLogic.bind(this));

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
        }
        .validation-message {
          color: red;
          padding: 10px;
          background: #fee;
          border-radius: 4px;
          margin-bottom: 10px;
        }
        .validation-message.hidden {
          display: none;
        }
      &lt;/style&gt;
      &lt;div class=&quot;validation-message hidden&quot;&gt;&lt;/div&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;
  }

  async handleBusinessLogic(e) {
    // Stop the event from propagating immediately
    e.stopPropagation();

    // Apply business validation
    const validation = await this.validateBusinessRules(e.detail);

    if (!validation.valid) {
      this.showError(validation.message);
      return;
    }

    // Validation passed - let the event continue
    pan.publish(&#039;cart.item.add&#039;, e.detail);
  }

  async validateBusinessRules(data) {
    // Check user eligibility
    const user = await pan.request(&#039;auth.user.get&#039;);
    if (!user) {
      return {
        valid: false,
        message: &#039;Please log in to add items to cart&#039;
      };
    }

    // Check age restriction
    if (data.product.ageRestricted &amp;&amp; user.age &lt; 21) {
      return {
        valid: false,
        message: &#039;This product requires age verification (21+)&#039;
      };
    }

    // Check geographic restriction
    if (data.product.geoRestricted &amp;&amp; !this.isAllowedRegion(user.region)) {
      return {
        valid: false,
        message: &#039;This product is not available in your region&#039;
      };
    }

    return { valid: true };
  }

  isAllowedRegion(region) {
    // Business logic for regional restrictions
    const allowedRegions = [&#039;US&#039;, &#039;CA&#039;, &#039;UK&#039;];
    return allowedRegions.includes(region);
  }

  showError(message) {
    const errorEl = this.shadowRoot.querySelector(&#039;.validation-message&#039;);
    errorEl.textContent = message;
    errorEl.classList.remove(&#039;hidden&#039;);

    setTimeout(() =&gt; {
      errorEl.classList.add(&#039;hidden&#039;);
    }, 5000);
  }
}

customElements.define(&#039;business-wrapper&#039;, BusinessWrapper);</code></pre>
<p>Usage:</p>
<pre><code class="language-html">&lt;!-- Wrap any component with business logic --&gt;
&lt;business-wrapper&gt;
  &lt;product-card product-id=&quot;123&quot;&gt;&lt;/product-card&gt;
&lt;/business-wrapper&gt;

&lt;business-wrapper&gt;
  &lt;quick-buy-button product-id=&quot;456&quot;&gt;&lt;/quick-buy-button&gt;
&lt;/business-wrapper&gt;</code></pre>
<p>The wrapper intercepts events and applies business logic <strong>without modifying</strong> the wrapped components.</p>
<h2>Pattern 4: Behavior Mixins</h2>
<p>Mixins let you share behavior across multiple component types. This is useful for cross-cutting concerns like analytics, logging, or validation.</p>
<h3>Implementation</h3>
<pre><code class="language-javascript">// mixins/analytics-mixin.js
export const AnalyticsMixin = (BaseClass) =&gt; class extends BaseClass {
  track(event, data = {}) {
    pan.publish(&#039;analytics.track&#039;, {
      event,
      data,
      component: this.tagName.toLowerCase(),
      timestamp: Date.now(),
      ...this.getAnalyticsContext()
    });
  }

  trackInteraction(element, action) {
    this.track(`${element}.${action}`, {
      element,
      action
    });
  }

  getAnalyticsContext() {
    // Add common context to all analytics events
    return {
      page: window.location.pathname,
      referrer: document.referrer
    };
  }

  connectedCallback() {
    super.connectedCallback?.();
    this.track(&#039;component.mounted&#039;, { id: this.id });
  }

  disconnectedCallback() {
    this.track(&#039;component.unmounted&#039;, { id: this.id });
    super.disconnectedCallback?.();
  }
};</code></pre>
<pre><code class="language-javascript">// mixins/validation-mixin.js
export const ValidationMixin = (BaseClass) =&gt; class extends BaseClass {
  async validate(data, rules) {
    const errors = [];

    for (const [field, rule] of Object.entries(rules)) {
      const value = data[field];

      if (rule.required &amp;&amp; !value) {
        errors.push(`${field} is required`);
      }

      if (rule.min &amp;&amp; value &lt; rule.min) {
        errors.push(`${field} must be at least ${rule.min}`);
      }

      if (rule.max &amp;&amp; value &gt; rule.max) {
        errors.push(`${field} must be at most ${rule.max}`);
      }

      if (rule.pattern &amp;&amp; !rule.pattern.test(value)) {
        errors.push(`${field} is invalid`);
      }

      if (rule.custom) {
        const customError = await rule.custom(value, data);
        if (customError) errors.push(customError);
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  showValidationErrors(errors) {
    pan.publish(&#039;validation.errors&#039;, {
      component: this.tagName.toLowerCase(),
      errors
    });
  }
};</code></pre>
<p>Use mixins to compose behavior:</p>
<pre><code class="language-javascript">import { AnalyticsMixin } from &#039;./mixins/analytics-mixin.js&#039;;
import { ValidationMixin } from &#039;./mixins/validation-mixin.js&#039;;

class CheckoutForm extends ValidationMixin(AnalyticsMixin(HTMLElement)) {
  async handleSubmit() {
    // Use validation from mixin
    const validation = await this.validate(this.formData, {
      email: {
        required: true,
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      },
      cardNumber: {
        required: true,
        custom: async (value) =&gt; {
          const valid = await this.validateCard(value);
          return valid ? null : &#039;Invalid card number&#039;;
        }
      }
    });

    if (!validation.valid) {
      this.showValidationErrors(validation.errors);
      return;
    }

    // Use analytics from mixin
    this.track(&#039;checkout.submit&#039;, {
      amount: this.total,
      items: this.items.length
    });

    // Process checkout
    this.processOrder();
  }
}</code></pre>
<h2>Pattern 5: Service Layer</h2>
<p>For complex business logic, create a dedicated service layer that components and PAN listeners can both use:</p>
<pre><code class="language-javascript">// services/pricing-service.js
class PricingService {
  async calculatePrice(product, quantity, user) {
    let price = product.basePrice;

    // Business Rule: Volume discounts
    if (quantity &gt;= 10) price *= 0.85;
    else if (quantity &gt;= 5) price *= 0.90;

    // Business Rule: Member discounts
    if (user?.tier === &#039;premium&#039;) {
      price *= 0.85;
    } else if (user?.tier === &#039;gold&#039;) {
      price *= 0.90;
    }

    // Business Rule: Active promotions
    const promotions = await this.getActivePromotions(product.id);
    for (const promo of promotions) {
      price = this.applyPromotion(price, promo);
    }

    return {
      unitPrice: price,
      quantity,
      subtotal: price * quantity,
      savings: (product.basePrice - price) * quantity
    };
  }

  async getActivePromotions(productId) {
    const response = await fetch(`/api/promotions?product=${productId}`);
    return response.json();
  }

  applyPromotion(price, promotion) {
    if (promotion.type === &#039;percentage&#039;) {
      return price * (1 - promotion.value / 100);
    } else if (promotion.type === &#039;fixed&#039;) {
      return Math.max(0, price - promotion.value);
    }
    return price;
  }

  async getTax(subtotal, region) {
    const taxRates = {
      &#039;CA&#039;: 0.0725,
      &#039;NY&#039;: 0.08,
      &#039;TX&#039;: 0.0625
    };

    return subtotal * (taxRates[region] || 0);
  }
}

export default new PricingService();</code></pre>
<p>Use the service from both components and PAN listeners:</p>
<pre><code class="language-javascript">// In a component
import pricingService from &#039;./services/pricing-service.js&#039;;

class ProductCard extends HTMLElement {
  async updatePrice() {
    const user = await pan.request(&#039;auth.user.get&#039;);
    const pricing = await pricingService.calculatePrice(
      this.product,
      this.quantity,
      user
    );

    this.displayPrice(pricing);
  }
}</code></pre>
<pre><code class="language-javascript">// In business logic
import pricingService from &#039;./services/pricing-service.js&#039;;

class CartBusinessLogic {
  init() {
    pan.subscribe(&#039;cart.item.add&#039;, async (data) =&gt; {
      const user = await pan.request(&#039;auth.user.get&#039;);
      const pricing = await pricingService.calculatePrice(
        data.product,
        data.quantity,
        user
      );

      pan.publish(&#039;cart.item.priced&#039;, { ...data, pricing });
    });
  }
}</code></pre>
<h2>Decision Matrix</h2>
<p>Here's how to choose the right pattern:</p>
<p>| Scenario | Recommended Pattern | Why |
|----------|-------------------|-----|
| Cross-component coordination | PAN Bus Listeners | Decoupled, flexible |
| Analytics/logging | Mixins | Reusable across all components |
| Validation before actions | PAN Bus Listeners | Centralized rules |
| Component-specific UI logic | Extend Component | Access to internals |
| Add behavior to third-party components | Wrapper | Non-invasive |
| Complex business calculations | Service Layer | Testable, reusable |
| Component variants (premium, free) | Extend Component | Clear inheritance |
| Feature flags / A-B testing | Wrapper or PAN Listeners | Easy to toggle |</p>
<h2>Real-World Example: E-Commerce Checkout</h2>
<p>Let's see how these patterns work together in a complete checkout flow:</p>
<pre><code class="language-javascript">// services/checkout-service.js
class CheckoutService {
  async processOrder(cart, paymentInfo, shippingInfo) {
    // Complex business logic
    const pricing = await this.calculateFinalPricing(cart);
    const shipping = await this.calculateShipping(cart, shippingInfo);
    const tax = await this.calculateTax(pricing.subtotal, shippingInfo.state);

    return {
      items: cart.items,
      pricing,
      shipping,
      tax,
      total: pricing.subtotal + shipping.cost + tax
    };
  }

  async calculateFinalPricing(cart) {
    // Apply all discounts, coupons, etc.
    let subtotal = 0;
    let savings = 0;

    for (const item of cart.items) {
      const itemPricing = await pricingService.calculatePrice(
        item.product,
        item.quantity,
        cart.user
      );
      subtotal += itemPricing.subtotal;
      savings += itemPricing.savings;
    }

    return { subtotal, savings };
  }

  async calculateShipping(cart, shippingInfo) {
    // Shipping business rules
    if (cart.total &gt;= 50) {
      return { method: &#039;standard&#039;, cost: 0, freeShipping: true };
    }

    const weight = cart.items.reduce((sum, item) =&gt; sum + item.weight, 0);
    const zone = this.getShippingZone(shippingInfo.state);

    return {
      method: &#039;standard&#039;,
      cost: this.calculateShippingCost(weight, zone),
      freeShipping: false
    };
  }

  calculateShippingCost(weight, zone) {
    const baseRate = { 1: 5, 2: 7, 3: 10 };
    return baseRate[zone] + (weight &gt; 5 ? (weight - 5) * 0.5 : 0);
  }

  getShippingZone(state) {
    const zones = {
      1: [&#039;CA&#039;, &#039;OR&#039;, &#039;WA&#039;],
      2: [&#039;NV&#039;, &#039;AZ&#039;, &#039;UT&#039;, &#039;ID&#039;],
      3: [] // All other states
    };

    for (const [zone, states] of Object.entries(zones)) {
      if (states.includes(state)) return parseInt(zone);
    }
    return 3;
  }

  async calculateTax(subtotal, state) {
    return pricingService.getTax(subtotal, state);
  }
}

export default new CheckoutService();</code></pre>
<pre><code class="language-javascript">// business-logic/checkout-rules.js
import checkoutService from &#039;../services/checkout-service.js&#039;;

class CheckoutBusinessRules {
  init() {
    pan.subscribe(&#039;checkout.start&#039;, this.handleCheckoutStart.bind(this));
    pan.subscribe(&#039;checkout.submit&#039;, this.handleCheckoutSubmit.bind(this));
  }

  async handleCheckoutStart(data) {
    // Business validations
    const cart = await pan.request(&#039;cart.get&#039;);
    const user = await pan.request(&#039;auth.user.get&#039;);

    // Validation 1: Cart not empty
    if (!cart.items.length) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;EMPTY_CART&#039;,
        message: &#039;Your cart is empty&#039;
      });
      return;
    }

    // Validation 2: User logged in
    if (!user) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;AUTH_REQUIRED&#039;,
        message: &#039;Please log in to continue&#039;
      });
      return;
    }

    // Validation 3: Inventory check
    for (const item of cart.items) {
      const available = await this.checkInventory(item.product.id);
      if (available &lt; item.quantity) {
        pan.publish(&#039;checkout.error&#039;, {
          code: &#039;INSUFFICIENT_INVENTORY&#039;,
          message: `Only ${available} of &quot;${item.product.name}&quot; available`,
          item
        });
        return;
      }
    }

    // All validations passed
    pan.publish(&#039;checkout.validated&#039;, { cart, user });
  }

  async handleCheckoutSubmit(data) {
    try {
      // Process order through service
      const order = await checkoutService.processOrder(
        data.cart,
        data.paymentInfo,
        data.shippingInfo
      );

      // Submit to backend
      const response = await fetch(&#039;/api/orders&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify(order)
      });

      if (!response.ok) {
        throw new Error(&#039;Order submission failed&#039;);
      }

      const result = await response.json();

      // Success
      pan.publish(&#039;checkout.success&#039;, {
        orderId: result.orderId,
        order: result
      });

      // Clear cart
      pan.publish(&#039;cart.clear&#039;);

    } catch (error) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;SUBMISSION_FAILED&#039;,
        message: &#039;Unable to process order. Please try again.&#039;,
        error
      });
    }
  }

  async checkInventory(productId) {
    const response = await fetch(`/api/inventory/${productId}`);
    const data = await response.json();
    return data.available;
  }
}

export default new CheckoutBusinessRules();</code></pre>
<p>The checkout component stays simple:</p>
<pre><code class="language-javascript">// components/checkout-form.js
class CheckoutForm extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });
    this.render();
    this.attachEventListeners();
    this.subscribeToEvents();
  }

  subscribeToEvents() {
    this._unsubscribers = [
      pan.subscribe(&#039;checkout.validated&#039;, () =&gt; {
        this.showCheckoutForm();
      }),

      pan.subscribe(&#039;checkout.error&#039;, (error) =&gt; {
        this.showError(error.message);
      }),

      pan.subscribe(&#039;checkout.success&#039;, (data) =&gt; {
        this.showSuccess(data.orderId);
      })
    ];
  }

  handleSubmit(e) {
    e.preventDefault();

    // Just collect data and publish - business logic handles the rest
    pan.publish(&#039;checkout.submit&#039;, {
      cart: this.cart,
      paymentInfo: this.getPaymentInfo(),
      shippingInfo: this.getShippingInfo()
    });

    this.showProcessing();
  }

  // UI methods only - no business logic
  showCheckoutForm() { /* ... */ }
  showError(message) { /* ... */ }
  showSuccess(orderId) { /* ... */ }
  showProcessing() { /* ... */ }
}</code></pre>
<h2>Testing Business Logic</h2>
<p>One of the biggest advantages of separating business logic is testability. Here's how to test each pattern:</p>
<h3>Testing PAN Bus Listeners</h3>
<pre><code class="language-javascript">// __tests__/cart-rules.test.js
import { describe, it, expect, beforeEach, vi } from &#039;vitest&#039;;
import { pan } from &#039;@larcjs/core&#039;;
import cartRules from &#039;../business-logic/cart-rules.js&#039;;

describe(&#039;Cart Business Rules&#039;, () =&gt; {
  beforeEach(() =&gt; {
    // Reset PAN bus between tests
    pan.clear();
    cartRules.init();
  });

  it(&#039;should reject adding more than max items&#039;, async () =&gt; {
    // Mock cart with max items
    pan.respond(&#039;cart.get&#039;, () =&gt; ({
      items: new Array(50).fill({})
    }));

    const errorHandler = vi.fn();
    pan.subscribe(&#039;cart.error&#039;, errorHandler);

    // Try to add another item
    await pan.publish(&#039;cart.item.add&#039;, {
      product: { id: 1, name: &#039;Test&#039; },
      quantity: 1
    });

    expect(errorHandler).toHaveBeenCalledWith({
      code: &#039;MAX_ITEMS_EXCEEDED&#039;,
      message: expect.stringContaining(&#039;50 items&#039;)
    });
  });

  it(&#039;should apply bulk discount for 5+ items&#039;, async () =&gt; {
    const validated = vi.fn();
    pan.subscribe(&#039;cart.item.validated&#039;, validated);

    await pan.publish(&#039;cart.item.add&#039;, {
      product: { id: 1, name: &#039;Test&#039;, price: 100 },
      quantity: 5
    });

    expect(validated).toHaveBeenCalledWith(
      expect.objectContaining({
        pricing: expect.objectContaining({
          unitPrice: 90, // 10% discount
          discount: 50
        })
      })
    );
  });
});</code></pre>
<h3>Testing Services</h3>
<pre><code class="language-javascript">// __tests__/pricing-service.test.js
import { describe, it, expect } from &#039;vitest&#039;;
import pricingService from &#039;../services/pricing-service.js&#039;;

describe(&#039;Pricing Service&#039;, () =&gt; {
  it(&#039;should apply volume discount&#039;, async () =&gt; {
    const product = { basePrice: 100 };
    const pricing = await pricingService.calculatePrice(product, 10, null);

    expect(pricing.unitPrice).toBe(85); // 15% off for 10+
    expect(pricing.subtotal).toBe(850);
  });

  it(&#039;should stack member and volume discounts&#039;, async () =&gt; {
    const product = { basePrice: 100 };
    const user = { tier: &#039;premium&#039; };

    const pricing = await pricingService.calculatePrice(product, 10, user);

    // 15% volume + 15% premium = 72.25
    expect(pricing.unitPrice).toBe(72.25);
  });
});</code></pre>
<h2>Best Practices</h2>
<h3>1. Keep Components Dumb</h3>
<p>Components should focus on UI and user interaction. They publish events but don't implement business rules.</p>
<strong>Good:</strong>
<pre><code class="language-javascript">handleAddToCart() {
  pan.publish(&#039;cart.item.add&#039;, { product: this.product });
}</code></pre>
<strong>Bad:</strong>
<pre><code class="language-javascript">async handleAddToCart() {
  // Business logic in component - hard to test and reuse
  const inventory = await fetch(&#039;/api/inventory&#039;);
  if (inventory &lt; this.quantity) {
    alert(&#039;Out of stock&#039;);
    return;
  }

  const user = await fetch(&#039;/api/user&#039;);
  if (user.age &lt; 21 &amp;&amp; this.product.ageRestricted) {
    alert(&#039;Age restricted&#039;);
    return;
  }

  // ... more business logic
}</code></pre>
<h3>2. Use Services for Complex Logic</h3>
<p>If business logic involves multiple steps, calculations, or external APIs, put it in a service:</p>
<pre><code class="language-javascript">// Good: Service handles complexity
const pricing = await pricingService.calculatePrice(product, quantity, user);

// Bad: Business logic scattered across components and PAN listeners
const basePrice = product.price;
const volumeDiscount = quantity &gt;= 10 ? 0.15 : 0;
const memberDiscount = user?.tier === &#039;premium&#039; ? 0.15 : 0;
// ... etc</code></pre>
<h3>3. Make Business Logic Observable</h3>
<p>Use PAN bus to make business logic transparent:</p>
<pre><code class="language-javascript">class OrderProcessor {
  async processOrder(order) {
    pan.publish(&#039;order.processing.start&#039;, { orderId: order.id });

    try {
      await this.validateOrder(order);
      pan.publish(&#039;order.validated&#039;, { orderId: order.id });

      await this.chargePayment(order);
      pan.publish(&#039;order.charged&#039;, { orderId: order.id });

      await this.createShipment(order);
      pan.publish(&#039;order.shipped&#039;, { orderId: order.id });

      pan.publish(&#039;order.complete&#039;, { orderId: order.id });
    } catch (error) {
      pan.publish(&#039;order.failed&#039;, { orderId: order.id, error });
    }
  }
}</code></pre>
<p>Now other parts of your app can react to these events (analytics, notifications, UI updates, etc.).</p>
<h3>4. Document Business Rules</h3>
<p>Make business rules explicit and documented:</p>
<pre><code class="language-javascript">/**
 * Shopping Cart Business Rules
 *
 * 1. Maximum 50 items per order
 * 2. Maximum 10 quantity per item
 * 3. Free shipping over $50
 * 4. Volume discounts:
 *    - 5-9 items: 10% off
 *    - 10+ items: 15% off
 * 5. Member discounts:
 *    - Premium: 15% off
 *    - Gold: 10% off
 * 6. Minimum order value: $10
 */
class CartBusinessRules {
  // Implementation
}</code></pre>
<h3>5. Use Feature Flags</h3>
<p>Make business logic toggleable:</p>
<pre><code class="language-javascript">class CheckoutRules {
  constructor() {
    this.features = {
      guestCheckout: true,
      expressCheckout: false,
      digitalWallet: true
    };
  }

  async handleCheckout(data) {
    if (!this.features.guestCheckout &amp;&amp; !data.user) {
      pan.publish(&#039;checkout.error&#039;, {
        message: &#039;Account required for checkout&#039;
      });
      return;
    }

    // ... rest of logic
  }
}</code></pre>
<h2>Summary</h2>
<p>When integrating business logic into LARC applications:</p>
<li><strong>Default to PAN Bus listeners</strong> for most business logic - it's decoupled, testable, and flexible</li>
<li><strong>Use services</strong> for complex calculations and workflows</li>
<li><strong>Extend components</strong> only when logic is tightly coupled to UI</li>
<li><strong>Use mixins</strong> for cross-cutting concerns like analytics</li>
<li><strong>Wrap components</strong> when adding behavior to third-party code</li>
<li><strong>Keep components dumb</strong> - they publish events, business logic handles the rest</li>
<p>This separation of concerns makes your application:</p>
<ul><li><strong>Easier to test</strong> - business logic without rendering components</li>
<li><strong>More maintainable</strong> - business rules in one place</li>
<li><strong>More flexible</strong> - easy to change rules without touching UI</li>
<li><strong>More reusable</strong> - logic can be shared across components</li>
</ul>
In the next chapter, we'll explore routing and navigation, building on these patterns to create complete single-page applications.
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/learning-larc/chapters/08-business-logic-patterns.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
</body>
</html>