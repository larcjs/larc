<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- CRITICAL: Load theme BEFORE CSS to prevent flash -->
  <script src="../../../../../../playground/theme-init.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Creating Web Components · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Creating Web Components">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">learning-larc</a> / <a href="#">chapters</a> / <span>04-creating-web-components</span>
      </div>
      <article class="docs-content">
        <h1>Creating Web Components</h1>
<p>Now that you've built your first LARC application, it's time to master the art of creating robust, reusable Web Components. This chapter covers everything from basic component anatomy to advanced patterns like composition, slots, and performance optimization.</p>
<p>By the end of this chapter, you'll be able to build production-quality components that are maintainable, testable, and performant.</p>
<h2>Anatomy of a LARC Component</h2>
<p>!<a href="../images/02-component-structure-3.png"><strong>Figure 4.1:</strong> Component Lifecycle Flow</a></p>
<strong><em>Figure 4.1:</strong> Component Lifecycle Flow</em>
<p>Let's dissect a well-structured LARC component to understand its parts:</p>
<pre><code class="language-javascript">// Import dependencies
import { pan } from &#039;@larcjs/core&#039;;
import { formatDate } from &#039;../lib/utils.js&#039;;

/**
 * A card component for displaying user information.
 *
 * @element user-card
 *
 * @attr {string} user-id - The ID of the user to display
 * @attr {boolean} compact - Display in compact mode
 *
 * @fires user-selected - Dispatched when card is clicked
 *
 * @slot - Default slot for additional content
 * @slot actions - Slot for action buttons
 */
class UserCard extends HTMLElement {
  // 1. Define observed attributes
  static get observedAttributes() {
    return [&#039;user-id&#039;, &#039;compact&#039;];
  }

  // 2. Constructor - initialize instance
  constructor() {
    super();

    // Attach shadow DOM
    this.attachShadow({ mode: &#039;open&#039; });

    // Initialize private state
    this._user = null;
    this._loading = false;
    this._error = null;

    // Bind event handlers
    this.handleClick = this.handleClick.bind(this);
  }

  // 3. Lifecycle: connected to DOM
  connectedCallback() {
    this.render();

    // Load user data if ID is provided
    const userId = this.getAttribute(&#039;user-id&#039;);
    if (userId) {
      this.loadUser(userId);
    }

    // Subscribe to PAN events
    this.unsubscribe = pan.subscribe(&#039;user.updated&#039;, this.handleUserUpdate);

    // Add event listeners
    this.shadowRoot.addEventListener(&#039;click&#039;, this.handleClick);
  }

  // 4. Lifecycle: disconnected from DOM
  disconnectedCallback() {
    // Clean up subscriptions
    if (this.unsubscribe) {
      this.unsubscribe();
    }

    // Remove event listeners
    this.shadowRoot.removeEventListener(&#039;click&#039;, this.handleClick);
  }

  // 5. Lifecycle: attributes changed
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    if (name === &#039;user-id&#039; &amp;&amp; newValue) {
      this.loadUser(newValue);
    } else if (name === &#039;compact&#039;) {
      this.render();
    }
  }

  // 6. Public properties with getters/setters
  get user() {
    return this._user;
  }

  set user(value) {
    this._user = value;
    this.render();
  }

  get loading() {
    return this._loading;
  }

  // 7. Public methods
  async loadUser(userId) {
    this._loading = true;
    this._error = null;
    this.render();

    try {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error(&#039;Failed to load user&#039;);

      this._user = await response.json();
      this._loading = false;
      this.render();
    } catch (error) {
      this._error = error.message;
      this._loading = false;
      this.render();
    }
  }

  refresh() {
    const userId = this.getAttribute(&#039;user-id&#039;);
    if (userId) {
      this.loadUser(userId);
    }
  }

  // 8. Private methods
  handleClick(event) {
    if (!this._user) return;

    this.dispatchEvent(new CustomEvent(&#039;user-selected&#039;, {
      detail: { user: this._user },
      bubbles: true,
      composed: true
    }));
  }

  handleUserUpdate = (data) =&gt; {
    if (data.userId === this.getAttribute(&#039;user-id&#039;)) {
      this._user = data.user;
      this.render();
    }
  }

  // 9. Render method
  render() {
    const compact = this.hasAttribute(&#039;compact&#039;);

    if (this._loading) {
      this.shadowRoot.innerHTML = this.renderLoading();
      return;
    }

    if (this._error) {
      this.shadowRoot.innerHTML = this.renderError();
      return;
    }

    if (!this._user) {
      this.shadowRoot.innerHTML = this.renderEmpty();
      return;
    }

    this.shadowRoot.innerHTML = compact
      ? this.renderCompact()
      : this.renderFull();
  }

  renderLoading() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card loading&quot;&gt;
        &lt;div class=&quot;spinner&quot;&gt;&lt;/div&gt;
        &lt;p&gt;Loading...&lt;/p&gt;
      &lt;/div&gt;
    `;
  }

  renderError() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card error&quot;&gt;
        &lt;p class=&quot;error-message&quot;&gt;${this._error}&lt;/p&gt;
        &lt;button class=&quot;retry&quot;&gt;Retry&lt;/button&gt;
      &lt;/div&gt;
    `;
  }

  renderEmpty() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card empty&quot;&gt;
        &lt;p&gt;No user data&lt;/p&gt;
      &lt;/div&gt;
    `;
  }

  renderCompact() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card compact&quot;&gt;
        &lt;img src=&quot;${this._user.avatar}&quot; alt=&quot;${this._user.name}&quot;&gt;
        &lt;div class=&quot;info&quot;&gt;
          &lt;h3&gt;${this._user.name}&lt;/h3&gt;
          &lt;slot name=&quot;actions&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }

  renderFull() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card&quot;&gt;
        &lt;div class=&quot;header&quot;&gt;
          &lt;img src=&quot;${this._user.avatar}&quot; alt=&quot;${this._user.name}&quot; class=&quot;avatar&quot;&gt;
          &lt;div class=&quot;header-content&quot;&gt;
            &lt;h2&gt;${this._user.name}&lt;/h2&gt;
            &lt;p class=&quot;email&quot;&gt;${this._user.email}&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;body&quot;&gt;
          &lt;p class=&quot;bio&quot;&gt;${this._user.bio || &#039;No bio available&#039;}&lt;/p&gt;
          &lt;div class=&quot;meta&quot;&gt;
            &lt;span&gt;Joined ${formatDate(this._user.createdAt)}&lt;/span&gt;
          &lt;/div&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;footer&quot;&gt;
          &lt;slot name=&quot;actions&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }

  // 10. Styles
  styles() {
    return `
      :host {
        display: block;
        cursor: pointer;
      }

      .card {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        padding: 16px;
        transition: box-shadow 0.2s;
      }

      .card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      }

      .header {
        display: flex;
        gap: 12px;
        margin-bottom: 16px;
      }

      .avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        object-fit: cover;
      }

      h2 {
        margin: 0;
        font-size: 18px;
        color: #333;
      }

      .email {
        margin: 4px 0 0 0;
        font-size: 14px;
        color: #666;
      }

      .bio {
        color: #444;
        line-height: 1.5;
      }

      .meta {
        font-size: 12px;
        color: #999;
        margin-top: 12px;
      }

      .loading, .error, .empty {
        text-align: center;
        padding: 40px 20px;
        color: #666;
      }

      .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 16px;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .error-message {
        color: #e53e3e;
      }

      .compact {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
      }

      .compact img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
      }

      .compact h3 {
        margin: 0;
        font-size: 14px;
      }
    `;
  }
}

// 11. Register the custom element
customElements.define(&#039;user-card&#039;, UserCard);

// 12. Export for use in other modules
export default UserCard;</code></pre>
<h3>Component Structure Breakdown</h3>
<strong>1. Documentation:</strong>
<ul><li>JSDoc comments explain usage</li>
<li>Attribute, property, event, and slot documentation</li>
<li>Helps other developers understand the component</li>
</ul>
<strong>2. Static Properties:</strong>
<ul><li><code>observedAttributes</code> defines which attributes trigger <code>attributeChangedCallback</code></li>
<li>Keep this list minimal for performance</li>
</ul>
<strong>3. Constructor:</strong>
<ul><li>Initialize instance variables</li>
<li>Attach shadow DOM</li>
<li>Bind methods (for event handlers)</li>
<li>Don't access attributes or DOM here</li>
</ul>
<strong>4. Lifecycle Methods:</strong>
<ul><li><code>connectedCallback</code>: Setup when added to DOM</li>
<li><code>disconnectedCallback</code>: Cleanup when removed</li>
<li><code>attributeChangedCallback</code>: Respond to attribute changes</li>
</ul>
<strong>5. Properties:</strong>
<ul><li>Use private fields (<code>_user</code>) for internal state</li>
<li>Provide getters/setters for public API</li>
<li>Setters can trigger re-renders</li>
</ul>
<strong>6. Methods:</strong>
<ul><li>Public methods for external use</li>
<li>Private methods (conventionally start with <code>_</code> or use <code>#</code> private fields)</li>
<li>Keep methods focused and single-purpose</li>
</ul>
<strong>7. Rendering:</strong>
<ul><li>Separate render logic from state management</li>
<li>Multiple render methods for different states</li>
<li>Extract styles to a separate method</li>
</ul>
<h2>Shadow DOM Deep Dive</h2>
<p>!<a href="../images/02-component-structure-6.png"><strong>Figure 4.2:</strong> Slots and Content Projection</a></p>
<strong><em>Figure 4.2:</strong> Slots and Content Projection</em>
<p>Shadow DOM is one of the most powerful features of Web Components. It provides true encapsulation for both markup and styles.</p>
<h3>Creating Shadow DOM</h3>
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  constructor() {
    super();

    // Create shadow root
    this.attachShadow({ mode: &#039;open&#039; });

    // mode: &#039;open&#039; - shadow root accessible via element.shadowRoot
    // mode: &#039;closed&#039; - shadow root not accessible (rarely used)
  }
}</code></pre>
<h3>Shadow DOM vs Light DOM</h3>
<pre><code class="language-html">&lt;my-component&gt;
  &lt;!-- This is Light DOM (regular DOM) --&gt;
  &lt;p&gt;Visible content&lt;/p&gt;
&lt;/my-component&gt;

&lt;script&gt;
  class MyComponent extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: &#039;open&#039; });

      // This is Shadow DOM
      this.shadowRoot.innerHTML = `
        &lt;div class=&quot;shadow-content&quot;&gt;
          &lt;h2&gt;Shadow DOM Content&lt;/h2&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
      `;
    }
  }

  customElements.define(&#039;my-component&#039;, MyComponent);
&lt;/script&gt;</code></pre>
<strong>Result:</strong>
<ul><li>Light DOM (<code><p>Visible content</p></code>) is projected into the <code><slot></code></li>
<li>Shadow DOM provides the structure and styling</li>
<li>Styles in shadow DOM don't leak out</li>
<li>Styles from light DOM don't leak in</li>
</ul>
<h3>Style Encapsulation</h3>
<pre><code class="language-javascript">class StyledButton extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        /* These styles only affect this component */
        button {
          background: blue;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
        }

        button:hover {
          background: darkblue;
        }
      &lt;/style&gt;
      &lt;button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;
    `;
  }
}</code></pre>
<strong>Key Points:</strong>
<ul><li>Styles inside shadow DOM are scoped</li>
<li>No conflicts with global styles</li>
<li>No CSS class name collisions</li>
<li>True component encapsulation</li>
</ul>
<h3>The :host Selector</h3>
<p>Style the component itself:</p>
<pre><code class="language-css">:host {
  display: block;
  margin: 16px 0;
}

/* Style host when it has a class */
:host(.highlighted) {
  border: 2px solid gold;
}

/* Style host when it has an attribute */
:host([disabled]) {
  opacity: 0.5;
  pointer-events: none;
}

/* Style host in specific contexts */
:host-context(.dark-theme) {
  background: #333;
  color: white;
}</code></pre>
<h3>CSS Custom Properties (Variables)</h3>
<p>CSS variables pierce the shadow DOM boundary:</p>
<pre><code class="language-javascript">// Component defines and uses variables
class ThemedCard extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          background: var(--card-bg, white);
          color: var(--card-text, black);
          border: 1px solid var(--card-border, #ddd);
          border-radius: var(--card-radius, 8px);
          padding: var(--card-padding, 16px);
        }
      &lt;/style&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;
  }
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;style&gt;
  /* Override component variables from outside */
  themed-card {
    --card-bg: #f0f0f0;
    --card-text: #333;
    --card-border: #ccc;
    --card-radius: 12px;
  }

  themed-card.dark {
    --card-bg: #333;
    --card-text: #fff;
    --card-border: #555;
  }
&lt;/style&gt;

&lt;themed-card&gt;Normal theme&lt;/themed-card&gt;
&lt;themed-card class=&quot;dark&quot;&gt;Dark theme&lt;/themed-card&gt;</code></pre>
<p>This pattern allows theming while maintaining encapsulation.</p>
<h3>Parts and ::part()</h3>
<p>Expose specific shadow DOM elements for styling:</p>
<pre><code class="language-javascript">class FancyButton extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button { /* default styles */ }
        .icon { /* icon styles */ }
      &lt;/style&gt;
      &lt;button part=&quot;button&quot;&gt;
        &lt;span part=&quot;icon&quot; class=&quot;icon&quot;&gt;→&lt;/span&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/button&gt;
    `;
  }
}</code></pre>
<strong>Style from outside:</strong>
<pre><code class="language-css">fancy-button::part(button) {
  background: linear-gradient(135deg, #667eea, #764ba2);
}

fancy-button::part(icon) {
  color: gold;
}</code></pre>
<p>This gives consumers more control while maintaining encapsulation.</p>
<h2>Attributes and Properties</h2>
<p>Understanding the difference between attributes and properties is crucial for component design.</p>
<h3>Attributes vs Properties</h3>
<strong>Attributes:</strong>
<ul><li>HTML attributes (<code><my-el foo="bar"></code>)</li>
<li>Always strings</li>
<li>Visible in HTML</li>
<li>Trigger <code>attributeChangedCallback</code></li>
</ul>
<strong>Properties:</strong>
<ul><li>JavaScript properties (<code>element.foo = 123</code>)</li>
<li>Any type (string, number, object, etc.)</li>
<li>Not visible in HTML</li>
<li>Direct access, no callback</li>
</ul>
<h3>Reflecting Properties to Attributes</h3>
<pre><code class="language-javascript">class ToggleButton extends HTMLElement {
  static get observedAttributes() {
    return [&#039;checked&#039;];
  }

  constructor() {
    super();
    this._checked = false;
  }

  // Property getter
  get checked() {
    return this._checked;
  }

  // Property setter - reflects to attribute
  set checked(value) {
    const isChecked = Boolean(value);

    if (isChecked) {
      this.setAttribute(&#039;checked&#039;, &#039;&#039;);
    } else {
      this.removeAttribute(&#039;checked&#039;);
    }
  }

  // Attribute changed - updates property
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === &#039;checked&#039;) {
      this._checked = newValue !== null;
      this.render();
    }
  }

  render() {
    this.innerHTML = `
      &lt;button class=&quot;${this._checked ? &#039;checked&#039; : &#039;&#039;}&quot;&gt;
        ${this._checked ? &#039;✓&#039; : &#039;○&#039;}
      &lt;/button&gt;
    `;
  }
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;!-- Set via attribute --&gt;
&lt;toggle-button checked&gt;&lt;/toggle-button&gt;

&lt;script&gt;
  const toggle = document.querySelector(&#039;toggle-button&#039;);

  // Set via property
  toggle.checked = true;

  // Get property
  console.log(toggle.checked); // true

  // Check attribute
  console.log(toggle.hasAttribute(&#039;checked&#039;)); // true
&lt;/script&gt;</code></pre>
<h3>When to Use Each</h3>
<strong>Use Attributes for:</strong>
<ul><li>Simple configuration (strings, numbers, booleans)</li>
<li>Values that should be visible in HTML</li>
<li>Initial configuration from HTML</li>
<li>Values that need to work with CSS selectors</li>
</ul>
<strong>Use Properties for:</strong>
<ul><li>Complex data (objects, arrays, functions)</li>
<li>Data that changes frequently</li>
<li>Large data that shouldn't serialize to HTML</li>
<li>Callback functions</li>
</ul>
<h3>Type Conversion</h3>
<p>Attributes are always strings, so convert appropriately:</p>
<pre><code class="language-javascript">attributeChangedCallback(name, oldValue, newValue) {
  if (name === &#039;count&#039;) {
    this._count = Number(newValue) || 0;
  } else if (name === &#039;enabled&#039;) {
    this._enabled = newValue !== null; // Boolean attribute
  } else if (name === &#039;options&#039;) {
    try {
      this._options = JSON.parse(newValue);
    } catch {
      this._options = {};
    }
  }
}</code></pre>
<h3>Boolean Attributes</h3>
<p>Follow HTML conventions:</p>
<pre><code class="language-javascript">// Boolean attribute: presence = true, absence = false
if (this.hasAttribute(&#039;disabled&#039;)) {
  // Is disabled
}

// Set boolean attribute
this.setAttribute(&#039;disabled&#039;, &#039;&#039;); // value doesn&#039;t matter

// Remove boolean attribute
this.removeAttribute(&#039;disabled&#039;);</code></pre>
<h2>Component Styling</h2>
<p>!<a href="../images/02-component-structure-7.png"><strong>Figure 4.3:</strong> CSS Encapsulation with Shadow DOM</a></p>
<strong><em>Figure 4.3:</strong> CSS Encapsulation with Shadow DOM</em>
<h3>Internal Styles</h3>
<p>Most styles should be in shadow DOM:</p>
<pre><code class="language-javascript">styles() {
  return `
    :host {
      display: block;
    }

    .container {
      padding: 16px;
    }

    /* All your component styles */
  `;
}</code></pre>
<h3>External Stylesheets</h3>
<p>For larger components, link external styles:</p>
<pre><code class="language-javascript">connectedCallback() {
  this.attachShadow({ mode: &#039;open&#039; });

  this.shadowRoot.innerHTML = `
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/styles/components/user-card.css&quot;&gt;
    &lt;div class=&quot;user-card&quot;&gt;
      &lt;!-- content --&gt;
    &lt;/div&gt;
  `;
}</code></pre>
<h3>Adoptable Stylesheets</h3>
<p>Share styles between component instances:</p>
<pre><code class="language-javascript">// Create shared stylesheet once
const sheet = new CSSStyleSheet();
sheet.replaceSync(`
  .card {
    padding: 16px;
    border-radius: 8px;
    background: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
`);

class CardComponent extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    // Adopt shared stylesheet (very fast)
    this.shadowRoot.adoptedStyleSheets = [sheet];

    this.shadowRoot.innerHTML = `
      &lt;div class=&quot;card&quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<strong>Benefits:</strong>
<ul><li>Styles parsed once, shared across instances</li>
<li>Better performance with many components</li>
<li>Modify shared styles dynamically</li>
</ul>
<h3>Theming Strategies</h3>
<strong>Strategy 1: CSS Custom Properties</strong>
<pre><code class="language-javascript">class ThemedComponent extends HTMLElement {
  styles() {
    return `
      :host {
        --primary-color: var(--app-primary, #667eea);
        --background: var(--app-bg, white);
        --text: var(--app-text, #333);
      }

      .content {
        background: var(--background);
        color: var(--text);
      }

      button {
        background: var(--primary-color);
      }
    `;
  }
}</code></pre>
<strong>Strategy 2: Class-Based Themes</strong>
<pre><code class="language-javascript">class ThemeAwareComponent extends HTMLElement {
  connectedCallback() {
    // Observe theme changes on documentElement
    const observer = new MutationObserver(() =&gt; {
      this.updateTheme();
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: [&#039;data-theme&#039;]
    });

    this.updateTheme();
  }

  updateTheme() {
    const theme = document.documentElement.dataset.theme || &#039;light&#039;;
    this.setAttribute(&#039;theme&#039;, theme);
  }

  styles() {
    return `
      :host([theme=&quot;light&quot;]) {
        background: white;
        color: black;
      }

      :host([theme=&quot;dark&quot;]) {
        background: #333;
        color: white;
      }
    `;
  }
}</code></pre>
<strong>Strategy 3: PAN-Based Themes</strong>
<pre><code class="language-javascript">import { pan } from &#039;@larcjs/core&#039;;

class PanThemedComponent extends HTMLElement {
  connectedCallback() {
    this.unsubscribe = pan.subscribe(&#039;app.theme.changed&#039;, ({ theme }) =&gt; {
      this.applyTheme(theme);
    });

    // Request current theme
    pan.request(&#039;app.theme.get&#039;).then(theme =&gt; {
      this.applyTheme(theme);
    });
  }

  applyTheme(theme) {
    this.setAttribute(&#039;data-theme&#039;, theme);
  }
}</code></pre>
<h2>Lifecycle Methods (Advanced Patterns)</h2>
<h3>Deferred Rendering</h3>
<p>Wait for dependencies before rendering:</p>
<pre><code class="language-javascript">class DataDisplay extends HTMLElement {
  async connectedCallback() {
    // Wait for dependencies to load
    await customElements.whenDefined(&#039;loading-spinner&#039;);
    await customElements.whenDefined(&#039;error-message&#039;);

    // Now render
    this.render();
  }
}</code></pre>
<h3>Preventing Memory Leaks</h3>
<pre><code class="language-javascript">class WebSocketComponent extends HTMLElement {
  connectedCallback() {
    this.ws = new WebSocket(&#039;wss://api.example.com&#039;);

    this.ws.onmessage = (event) =&gt; {
      this.handleMessage(event.data);
    };

    this.ws.onerror = (error) =&gt; {
      console.error(&#039;WebSocket error:&#039;, error);
    };
  }

  disconnectedCallback() {
    // Clean up WebSocket connection
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}</code></pre>
<h3>Handling Rapid Reconnection</h3>
<p>Components can be disconnected and reconnected quickly:</p>
<pre><code class="language-javascript">class RobustComponent extends HTMLElement {
  connectedCallback() {
    // Might be called multiple times
    // Use a guard to prevent duplicate setup
    if (this._initialized) {
      return;
    }

    this._initialized = true;
    this.setup();
  }

  disconnectedCallback() {
    // Use setTimeout to debounce
    this._cleanupTimer = setTimeout(() =&gt; {
      this.cleanup();
      this._initialized = false;
    }, 100);
  }

  connectedCallback() {
    // Cancel cleanup if reconnected quickly
    if (this._cleanupTimer) {
      clearTimeout(this._cleanupTimer);
      this._cleanupTimer = null;
    }

    if (this._initialized) {
      return;
    }

    this._initialized = true;
    this.setup();
  }
}</code></pre>
<h2>Testing Components</h2>
<h3>Unit Testing</h3>
<p>Test components in isolation:</p>
<pre><code class="language-javascript">// tests/user-card.test.js
import { expect } from &#039;@open-wc/testing&#039;;
import &#039;../user-card.js&#039;;

describe(&#039;UserCard&#039;, () =&gt; {
  let element;

  beforeEach(() =&gt; {
    element = document.createElement(&#039;user-card&#039;);
    document.body.appendChild(element);
  });

  afterEach(() =&gt; {
    element.remove();
  });

  it(&#039;renders empty state by default&#039;, () =&gt; {
    const emptyText = element.shadowRoot.querySelector(&#039;.empty&#039;);
    expect(emptyText).to.exist;
  });

  it(&#039;loads user when user-id attribute is set&#039;, async () =&gt; {
    // Mock fetch
    global.fetch = async () =&gt; ({
      ok: true,
      json: async () =&gt; ({ id: 1, name: &#039;John Doe&#039;, email: &#039;john@example.com&#039; })
    });

    element.setAttribute(&#039;user-id&#039;, &#039;1&#039;);

    // Wait for async operations
    await new Promise(resolve =&gt; setTimeout(resolve, 100));

    const name = element.shadowRoot.querySelector(&#039;h2&#039;);
    expect(name.textContent).to.equal(&#039;John Doe&#039;);
  });

  it(&#039;handles loading state&#039;, async () =&gt; {
    element.setAttribute(&#039;user-id&#039;, &#039;1&#039;);

    const spinner = element.shadowRoot.querySelector(&#039;.spinner&#039;);
    expect(spinner).to.exist;
  });

  it(&#039;dispatches user-selected event on click&#039;, async () =&gt; {
    element._user = { id: 1, name: &#039;John&#039; };
    element.render();

    let eventData = null;
    element.addEventListener(&#039;user-selected&#039;, (e) =&gt; {
      eventData = e.detail;
    });

    element.shadowRoot.querySelector(&#039;.card&#039;).click();

    expect(eventData).to.deep.equal({ user: { id: 1, name: &#039;John&#039; } });
  });
});</code></pre>
<h3>Integration Testing</h3>
<p>Test components working together:</p>
<pre><code class="language-javascript">// tests/counter-integration.test.js
describe(&#039;Counter Integration&#039;, () =&gt; {
  beforeEach(() =&gt; {
    document.body.innerHTML = `
      &lt;counter-display&gt;&lt;/counter-display&gt;
      &lt;counter-controls&gt;&lt;/counter-controls&gt;
    `;
  });

  it(&#039;updates display when controls are clicked&#039;, async () =&gt; {
    const display = document.querySelector(&#039;counter-display&#039;);
    const controls = document.querySelector(&#039;counter-controls&#039;);

    const incrementBtn = controls.shadowRoot.querySelector(&#039;#increment&#039;);
    incrementBtn.click();

    await new Promise(resolve =&gt; setTimeout(resolve, 50));

    const displayValue = display.shadowRoot.querySelector(&#039;.display&#039;).textContent;
    expect(displayValue).to.equal(&#039;1&#039;);
  });
});</code></pre>
<h3>Visual Regression Testing</h3>
<p>Catch visual bugs:</p>
<pre><code class="language-javascript">// tests/visual.test.js
import puppeteer from &#039;puppeteer&#039;;
import pixelmatch from &#039;pixelmatch&#039;;

describe(&#039;Visual Regression&#039;, () =&gt; {
  let browser, page;

  beforeAll(async () =&gt; {
    browser = await puppeteer.launch();
    page = await browser.newPage();
  });

  afterAll(async () =&gt; {
    await browser.close();
  });

  it(&#039;user-card matches snapshot&#039;, async () =&gt; {
    await page.goto(&#039;http://localhost:3000/tests/user-card.html&#039;);

    const screenshot = await page.screenshot({ fullPage: true });
    const baseline = fs.readFileSync(&#039;tests/snapshots/user-card.png&#039;);

    const diff = pixelmatch(screenshot, baseline, null, 800, 600, {
      threshold: 0.1
    });

    expect(diff).to.be.lessThan(100); // Allow small differences
  });
});</code></pre>
<h2>Summary</h2>
<p>This chapter covered:</p>
<ul><li><strong>Component Anatomy</strong>: Structure, lifecycle, and organization</li>
<li><strong>Shadow DOM</strong>: Encapsulation, slots, and styling</li>
<li><strong>Attributes vs Properties</strong>: When to use each and how to reflect them</li>
<li><strong>Component Styling</strong>: Internal styles, theming, and CSS custom properties</li>
<li><strong>Lifecycle Patterns</strong>: Memory management and robust connection handling</li>
<li><strong>Testing</strong>: Unit, integration, and visual regression testing</li>
</ul>
You now know how to build production-quality Web Components. The next chapter explores the PAN bus in depth, showing you how to orchestrate component communication at scale.
<hr>
<h2>Best Practices</h2>
<li><strong>Always clean up in <code>disconnectedCallback</code></strong></li>
   - Remove event listeners
   - Cancel pending operations
   - Unsubscribe from events
<li><strong>Use Shadow DOM for encapsulation</strong></li>
   - Keep styles scoped
   - Avoid global style pollution
   - Use <code>:host</code> and CSS custom properties for theming
<li><strong>Reflect important properties to attributes</strong></li>
   - Makes state visible in HTML
   - Enables CSS selectors
   - Improves debugging
<li><strong>Keep components focused</strong></li>
   - Single responsibility principle
   - Compose larger components from smaller ones
   - Extract shared logic to utilities
<li><strong>Test early and often</strong></li>
   - Write tests as you build components
   - Test both happy paths and error cases
   - Use integration tests for component interaction
<hr>
<h2>Further Reading</h2>
<strong>For complete Web Components reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 2: Core Concepts - Web Components architecture and lifecycle</li>
<li><em>Building with LARC</em> Chapters 17-21: Component Reference - Complete API documentation</li>
<li><em>Building with LARC</em> Chapter 13: Testing Strategies - Component testing patterns</li>
</ul>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/learning-larc/chapters/04-creating-web-components.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
  <pan-bus debug="false"></pan-bus>
  <pan-theme-provider></pan-theme-provider>
</body>
</html>