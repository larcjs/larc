<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Foreword {.unnumbered} · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Foreword {.unnumbered}">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">learning-larc</a> / <a href="#">build</a> / <a href="#">temp</a> / <span>learning-larc-complete</span>
      </div>
      <article class="docs-content">
        <div class="pagebreak"></div>
<hr>
<h2>Praise for Learning LARC {.unnumbered}</h2>
<em>"LARC represents a return to web fundamentals while embracing modern capabilities. This book beautifully explains why that matters."</em>
— <strong>David B. - Software Engineer</strong>
<em>"Finally, a framework that respects the browser. Learning LARC shows you how to build without fighting the platform."</em>
— <strong>Jon W. - App Developer</strong>
<em>"The PAN bus architecture is elegant and powerful. This book makes it accessible to everyone."</em>
— <strong>Mary S. - Designer / Artist</strong>
<div class="pagebreak"></div>
<hr>
<h2>Copyright {.unnumbered}</h2>
<p>Copyright © 2025 LARC Team. All rights reserved.</p>
<p>Printed in the United States of America.</p>
<p>Published by LARC Press.</p>
<p>The LARC logo and name are trademarks of the LARC Project.</p>
<p>While the publisher and authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work.</p>
<p>Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.</p>
<div class="pagebreak"></div>
<hr>
<h2>Table of Contents {.unnumbered}</h2>
<h3>Preface {.unnumbered}</h3>
<ul><li>Who This Book Is For</li>
<li>What You'll Learn</li>
<li>Conventions Used in This Book</li>
<li>Using Code Examples</li>
<li>How to Contact Us</li>
<li>Acknowledgments</li>
</ul>
<h3>Part I: Foundations {.unnumbered}</h3>
<strong>Chapter 1: Philosophy and Background</strong>
<ul><li>The Problem with Modern Web Development</li>
<li>A Return to Fundamentals</li>
<li>The LARC Philosophy</li>
<li>Why "No Build" Matters</li>
<li>When to Use LARC</li>
<li>What You'll Build</li>
</ul>
<strong>Chapter 2: Core Concepts</strong>
<ul><li>Web Components Refresher</li>
<li>The Page Area Network (PAN)</li>
<li>Event-Driven Architecture</li>
<li>State Management Philosophy</li>
<li>Module System</li>
<li>The Component Lifecycle</li>
</ul>
<strong>Chapter 3: Getting Started</strong>
<ul><li>Setting Up Your Development Environment</li>
<li>Your First LARC Application</li>
<li>Project Structure</li>
<li>Import Maps Explained</li>
<li>Development Workflow</li>
<li>Common Patterns</li>
</ul>
<h3>Part II: Building Components {.unnumbered}</h3>
<strong>Chapter 4: Creating Web Components</strong>
<ul><li>Anatomy of a LARC Component</li>
<li>Shadow DOM Deep Dive</li>
<li>Attributes and Properties</li>
<li>Component Styling</li>
<li>Lifecycle Methods</li>
<li>Testing Components</li>
</ul>
<strong>Chapter 5: The PAN Bus</strong>
<ul><li>Understanding Pub/Sub Architecture</li>
<li>Topics and Namespaces</li>
<li>Publishing Messages</li>
<li>Subscribing to Events</li>
<li>Message Patterns</li>
<li>Debugging PAN Communication</li>
</ul>
<strong>Chapter 6: State Management</strong>
<ul><li>Component-Local State</li>
<li>Shared State Patterns</li>
<li>The pan-store Component</li>
<li>IndexedDB Integration</li>
<li>Persistence Strategies</li>
<li>Offline-First Applications</li>
</ul>
<strong>Chapter 7: Advanced Component Patterns</strong>
<ul><li>Compound Components</li>
<li>Higher-Order Components</li>
<li>Component Composition</li>
<li>Slots and Content Projection</li>
<li>Dynamic Component Loading</li>
<li>Performance Optimization</li>
</ul>
<h3>Part III: Building Applications {.unnumbered}</h3>
<strong>Chapter 8: Routing and Navigation</strong>
<ul><li>Client-Side Routing</li>
<li>The pan-router Component</li>
<li>Route Parameters</li>
<li>Nested Routes</li>
<li>Route Guards</li>
<li>History Management</li>
</ul>
<strong>Chapter 9: Forms and Validation</strong>
<ul><li>Form Components</li>
<li>Two-Way Data Binding</li>
<li>Validation Strategies</li>
<li>Error Handling</li>
<li>File Uploads</li>
<li>Form Submission</li>
</ul>
<strong>Chapter 10: Data Fetching and APIs</strong>
<ul><li>The pan-fetch Component</li>
<li>REST API Integration</li>
<li>GraphQL Support</li>
<li>WebSocket Communication</li>
<li>Server-Sent Events</li>
<li>Error Handling and Retry Logic</li>
</ul>
<strong>Chapter 11: Authentication and Security</strong>
<ul><li>Authentication Patterns</li>
<li>The pan-auth Component</li>
<li>JWT Token Management</li>
<li>Protected Routes</li>
<li>CORS Considerations</li>
<li>Security Best Practices</li>
</ul>
<h3>Part IV: Advanced Topics {.unnumbered}</h3>
<strong>Chapter 12: Server Integration</strong>
<ul><li>Backend Architecture</li>
<li>Node.js Integration</li>
<li>PHP Connector</li>
<li>Python/Django Integration</li>
<li>Database Patterns</li>
<li>Real-Time Communication</li>
</ul>
<strong>Chapter 13: Testing</strong>
<ul><li>Unit Testing Components</li>
<li>Integration Testing</li>
<li>End-to-End Testing</li>
<li>Visual Regression Testing</li>
<li>Performance Testing</li>
<li>Continuous Integration</li>
</ul>
<strong>Chapter 14: Performance and Optimization</strong>
<ul><li>Loading Strategies</li>
<li>Code Splitting</li>
<li>Lazy Loading Components</li>
<li>Caching Strategies</li>
<li>Bundle Size Optimization</li>
<li>Performance Monitoring</li>
</ul>
<strong>Chapter 15: Deployment</strong>
<ul><li>Static Hosting</li>
<li>CDN Configuration</li>
<li>Environment Variables</li>
<li>CI/CD Pipelines</li>
<li>Monitoring and Analytics</li>
<li>Production Best Practices</li>
</ul>
<h3>Part V: Ecosystem {.unnumbered}</h3>
<strong>Chapter 16: Component Library</strong>
<ul><li>Using the Component Registry</li>
<li>Contributing Components</li>
<li>Creating a Component Library</li>
<li>Documentation Strategies</li>
<li>Versioning and Releases</li>
</ul>
<strong>Chapter 17: Tooling</strong>
<ul><li>Development Tools</li>
<li>CLI Tools</li>
<li>VS Code Integration</li>
<li>Browser DevTools</li>
<li>Debugging Techniques</li>
</ul>
<strong>Chapter 18: Real-World Applications</strong>
<ul><li>Case Study: E-Commerce Platform</li>
<li>Case Study: Dashboard Application</li>
<li>Case Study: Blog/CMS</li>
<li>Lessons Learned</li>
<li>Best Practices</li>
</ul>
<h3>Appendices {.unnumbered}</h3>
<strong>Appendix A: Web Components API Reference</strong>
<ul><li>Custom Elements</li>
<li>Shadow DOM</li>
<li>HTML Templates</li>
<li>ES Modules</li>
</ul>
<strong>Appendix B: PAN Bus API Reference</strong>
<ul><li>Core Methods</li>
<li>Message Formats</li>
<li>Topic Patterns</li>
<li>Configuration Options</li>
</ul>
<strong>Appendix C: Component API Reference</strong>
<ul><li>Built-in Components</li>
<li>Component Properties</li>
<li>Events and Methods</li>
</ul>
<strong>Appendix D: Migration Guides</strong>
<ul><li>From React</li>
<li>From Vue</li>
<li>From Angular</li>
<li>From jQuery</li>
</ul>
<strong>Appendix E: Resources</strong>
<ul><li>Official Documentation</li>
<li>Community Resources</li>
<li>Video Tutorials</li>
<li>Example Projects</li>
</ul>
<h3>Index {.unnumbered}</h3>
<div class="pagebreak"></div>
<hr>
<h2>About the Author {.unnumbered}</h2>
<p>Christopher Robison is a veteran software engineer and architect with nearly three decades of experience building systems that range from biotech and online trading platforms to complex web applications and AI-driven tools. A lifelong maker with a deep appreciation for open standards, he has spent his career exploring the boundaries of what the web can do when you stop fighting the platform and start embracing it.</p>
<p>He is the creator of LARC.js and the PAN message bus, a browser-native architecture inspired by the elegant simplicity of the automotive CAN bus. His work blends engineering pragmatism with a playful curiosity that has led him to design everything from 3D printers and robotics to interactive music systems and decentralized applications.</p>
<p>Christopher currently lives in San Francisco, where he continues to build things that bridge the digital and physical worlds — and occasionally sneaks off to play punk rock shows with his band.</p>
<strong>Website:</strong> <a href="https://larcjs.com">https://larcjs.com</a>
<hr>
<div class="pagebreak"></div>
<h1>Foreword {.unnumbered}</h1>
<em>by Christopher Robison</em>
<p>I didn't set out to build a framework. I set out to escape one — or at least escape the gravitational pull of the endless build pipeline.</p>
<p>After decades of building things for the web, my machine had become a storage exhibit of Node versions, Python versions, shims, wrappers, and dependency folders with the mass of small moons. Not because any of it was bad. Build tools are fine. For big projects, they're downright amazing. But somewhere along the way, we normalized the idea that even the simplest experiment needed a pipeline, a bundler, a transpiler, and a twelve-step hydration ritual before it could say "Hello, World."</p>
<p>That friction bothered me.</p>
<p>I wanted the feeling I had back in the early days: the joy of dropping a <code><script></code> tag into an HTML file and instantly seeing something come alive. No ceremony. No yak shaving. Just a browser, a file, and an idea.</p>
<p>Web Components felt close to that spirit — native modules, shadow DOM, real encapsulation — but they were oddly isolated. Each component was a self-contained island. Reusable, yes. Architecturally composable? Not really. Nothing tied them together except whatever glue code you wrote yourself. It felt like someone had shipped LEGO bricks without the ability to click them together.</p>
<p>That's when I remembered the CAN bus in cars.</p>
<p>The CAN bus is this beautifully simple ecosystem: dozens of systems — sensors, motors, controllers — all sharing a single communication line. Anybody can broadcast. Anybody can listen. Nobody needs to know who else exists. A message goes out, and the parts that care respond. It's loosely coupled machinery at its finest.</p>
<p>I wanted that for the web.</p>
<p>So I built the PAN bus — the Page Area Network — and started experimenting. Not with the intention of making A Real Framework™, but out of curiosity. How far could I push this idea? What could I build if every component on the page could talk over a shared bus, using nothing but browser-native APIs and one tiny script include?</p>
<p>That little experiment got out of hand in the best way.</p>
<p>I kept pushing it, partly out of stubbornness, partly out of sheer delight. I wanted to see if I could build real, full-blown applications with no build process at all — just a single script tag pointing to LARC and a page full of components chatting over the bus. And it turned out to be… fun. Refreshing. Capable. Liberating, even. A loose, elegant architecture emerged almost on its own.</p>
<p>Along the way, I realized something important: I'm not anti-build-tool. They solve real problems, especially at scale. But they shouldn't be mandatory for everything. And they shouldn't overshadow the fact that the browser today is powerful enough to build serious applications with a simple HTML page, a few components, and a shared message bus.</p>
<p>React, Angular, Vue — they solved problems that absolutely needed solving at the time. The web platform in 2015 was missing big pieces: templating, reactivity, routing, structured components, coherence. These frameworks carried the industry through that era. But the web has evolved since then. Many of those features now exist natively — standardized, built-in, fast, and universally available.</p>
<p>LARC isn't here to replace those frameworks. It complements them. It fills in the 20% Web Components never standardized — the shared communication fabric. The glue that lets components coexist instead of siloing themselves off. It also makes bundle sizes smaller and architectures cleaner, whether you're going framework-free or integrating with your existing stack.</p>
<p>If this book succeeds, you'll see what I saw: the thrill of rediscovering the browser as a first-class app platform. The joy of building big things out of small, decoupled pieces. And the surprising power of an architecture that starts with a simple HTML file and one script include.</p>
<p>The web grew up. Now we get to build like it.</p>
<p>— <em>Christopher Robison</em></p>
<div class="pagebreak"></div>
<h1>Philosophy and Background</h1>
<h2>The Problem with Modern Web Development</h2>
<p>If you've been building web applications for the past decade, you've likely experienced what many developers call "JavaScript fatigue." The modern web development landscape has become increasingly complex, with countless tools, frameworks, and build processes standing between you and shipping working code.</p>
<p>Consider a typical modern web project setup:</p>
<li>Initialize your project with a framework CLI (<code>create-react-app</code>, <code>vue create</code>, etc.)</li>
<li>Install hundreds or thousands of npm dependencies</li>
<li>Configure webpack, Babel, TypeScript, ESLint, Prettier</li>
<li>Set up build scripts for development, production, testing</li>
<li>Wait for builds to complete (sometimes minutes)</li>
<li>Debug build configuration issues when something breaks</li>
<li>Update dependencies regularly to patch security vulnerabilities</li>
<li>Repeat the cycle when frameworks release breaking changes</li>
<p>This complexity wasn't always necessary. In the early days of the web, you could create an HTML file, add some CSS and JavaScript, and open it directly in a browser. No build step. No toolchain. No configuration. Just code that runs.</p>
<p>What happened?</p>
<h3>The Rise of Complexity</h3>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/12-traditional-vs-larc-1.png"><strong>Figure 1.1:</strong> Development Workflow - Traditional vs LARC</a></p>
<p>The web platform evolved, but it didn't evolve fast enough for ambitious developers. We wanted:</p>
<ul><li><strong>Component-based architecture</strong> — but HTML didn't have custom elements yet</li>
<li><strong>Module systems</strong> — but JavaScript didn't have native imports</li>
<li><strong>Reactive data binding</strong> — but the DOM wasn't designed for it</li>
<li><strong>Advanced syntax</strong> — like JSX, TypeScript, or class properties</li>
</ul>
Frameworks filled these gaps by building abstractions on top of the web platform. But these abstractions came with costs:
<ul><li><strong>Build toolchains</strong> became mandatory to transpile code</li>
<li><strong>Bundle sizes</strong> grew as framework code was shipped to browsers</li>
<li><strong>Learning curves</strong> steepened as developers had to learn both the framework and the tools</li>
<li><strong>Debugging</strong> became harder with source maps and transpiled code</li>
<li><strong>Performance</strong> suffered from unnecessary abstraction layers</li>
</ul>
The irony? While we were busy building these elaborate toolchains, the web platform itself was evolving to support many of the features we wanted natively.
<h3>The Platform Has Caught Up</h3>
<p>::: {.side-by-side}
!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/01-architecture-overview-3.png"><strong>Figure 1.2:</strong> LARC No-Build Architecture</a>{width=48%}
!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/12-traditional-vs-larc-3.png"><strong>Figure 1.3:</strong> Bundle Size Comparison</a>{width=48%}
:::</p>
<p>Today's web platform is remarkably capable. Modern browsers support:</p>
<ul><li><strong>Custom Elements</strong> — native component definition</li>
<li><strong>Shadow DOM</strong> — true style encapsulation</li>
<li><strong>ES Modules</strong> — native JavaScript modules with imports</li>
<li><strong>Import Maps</strong> — dependency management without bundlers</li>
<li><strong>Template Literals</strong> — dynamic HTML without JSX</li>
<li><strong>Proxy and Reflect</strong> — reactive data patterns</li>
<li><strong>CSS Custom Properties</strong> — themeable components</li>
<li><strong>Web Components</strong> — standards-based component architecture</li>
</ul>
These aren't polyfills or experimental features. They're stable, well-supported standards that work across all modern browsers. Yet most web frameworks continue to build elaborate abstractions on top of the platform, ignoring these native capabilities.
<h3>A Common Scenario</h3>
<p>Let's look at a real-world example. Imagine you're building a simple dashboard with a few interactive components: a card, a button, and a data table. Here's what this might look like in a typical React project:</p>
<strong>The Setup:</strong>
<pre><code class="language-bash">npx create-react-app my-dashboard
cd my-dashboard
npm install styled-components react-router axios redux
# Wait 5-10 minutes for installation
# Project size: ~300MB, ~1000+ dependencies</code></pre>
<strong>The Code:</strong>
<pre><code class="language-jsx">// Card.jsx
import React from &#039;react&#039;;
import styled from &#039;styled-components&#039;;

const StyledCard = styled.div`
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
`;

export default function Card({ title, children }) {
  return (
    &lt;StyledCard&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      {children}
    &lt;/StyledCard&gt;
  );
}</code></pre>
<strong>The Build:</strong>
<pre><code class="language-bash">npm run build
# Wait 30-60 seconds
# Output: Minified, bundled, transpiled code
# Bundle size: 200-500KB (before your actual code)</code></pre>
<p>Now, here's the same thing with native Web Components and LARC:</p>
<strong>The Setup:</strong>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;script type=&quot;module&quot;&gt;
  {
    &quot;imports&quot;: {
      &quot;@larcjs/ui&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/components@2.0.0/pan-card.mjs&quot;
    }
  }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;pan-card title=&quot;Dashboard&quot;&gt;
    &lt;p&gt;Your content here&lt;/p&gt;
  &lt;/pan-card&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<strong>The Build:</strong>
<pre><code class="language-bash"># There is no build step. Open the HTML file. It works.</code></pre>
<p>Same functionality. Zero dependencies. No build process. No toolchain. Just HTML, CSS, and JavaScript working together as the platform intended.</p>
<h2>A Return to Fundamentals</h2>
<p>LARC (Lightweight Autonomous Reactive Components) represents a philosophical shift back to web fundamentals. But this isn't about going backward—it's about recognizing that the platform has evolved to the point where many of our abstractions are no longer necessary.</p>
<h3>What LARC Is</h3>
<p>LARC is a set of conventions, patterns, and utilities for building modern web applications using native web standards:</p>
<ul><li><strong>Web Components</strong> for encapsulated, reusable UI elements</li>
<li><strong>ES Modules</strong> for code organization and imports</li>
<li><strong>Import Maps</strong> for dependency management</li>
<li><strong>The PAN Bus</strong> for component communication</li>
<li><strong>Native APIs</strong> for state, routing, and data fetching</li>
</ul>
LARC provides guidance and utilities, but it doesn't abstract away the platform. When you write LARC code, you're writing standard JavaScript, HTML, and CSS that runs directly in the browser.
<h3>What LARC Is Not</h3>
<p>LARC is deliberately minimal. It is <strong>not</strong>:</p>
<ul><li>A framework with proprietary APIs you must learn</li>
<li>A template language that requires compilation</li>
<li>A state management system with complex rules</li>
<li>A build tool that transforms your code</li>
<li>A runtime that interprets your components</li>
</ul>
If you know HTML, CSS, and JavaScript, you already know most of LARC.
<h3>Core Principles</h3>
<p>LARC is built on several core principles:</p>
<p>#### 1. Standards First</p>
<p>LARC embraces web standards rather than fighting them. Every LARC component is a valid Web Component. Every LARC module is a valid ES Module. If you understand the standards, you understand LARC.</p>
<p>#### 2. Zero Build for Development</p>
<p>During development, you should be able to edit a file and refresh the browser. No build step. No waiting. No configuration. The browser is your development environment.</p>
<p>This doesn't mean builds are forbidden—you can still optimize for production if needed. But they should be optional enhancements, not requirements.</p>
<p>#### 3. Progressive Enhancement</p>
<p>Start simple and add complexity only when needed. A basic component can be a few lines of JavaScript. As requirements grow, add features incrementally: state management, routing, server integration, etc.</p>
<p>You're never locked into architectural decisions made at project initialization. LARC applications evolve naturally.</p>
<p>#### 4. Local First, Network Aware</p>
<p>Components should work independently with local state. Network communication happens through explicit, observable patterns (the PAN bus). This makes components:</p>
<ul><li>Easier to test (no mocking required)</li>
<li>More reusable (fewer dependencies)</li>
<li>More resilient (graceful degradation)</li>
</ul>
#### 5. Developer Experience Through Simplicity
<p>Good DX doesn't require complex tooling. It comes from:</p>
<ul><li>Clear, predictable patterns</li>
<li>Minimal abstractions</li>
<li>Fast feedback loops</li>
<li>Easy debugging</li>
<li>Comprehensive documentation</li>
</ul>
When something breaks in LARC, you can open browser DevTools and debug standard JavaScript. No source maps. No transpiled code. No framework internals.
<h2>The LARC Philosophy</h2>
<p>At its heart, LARC is about <strong>respecting the platform</strong>. The web is incredibly powerful, yet we've spent years building layers of abstraction that hide its capabilities. LARC removes those layers.</p>
<h3>Composition Over Configuration</h3>
<p>Rather than configuring a framework through JSON or CLI flags, LARC applications are composed from standard parts:</p>
<pre><code class="language-html">&lt;!-- Composition: Combine standard elements --&gt;
&lt;pan-router&gt;
  &lt;pan-route path=&quot;/&quot; component=&quot;home-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/dashboard&quot; component=&quot;dashboard-page&quot;&gt;&lt;/pan-route&gt;
&lt;/pan-router&gt;</code></pre>
<p>Each element is understandable in isolation. There's no magic configuration file that controls behavior across your entire application.</p>
<h3>Convention Over Prescription</h3>
<p>LARC suggests patterns but doesn't enforce them. There's no "one true way" to structure a LARC application. The conventions exist to make common tasks easier, but you can always drop down to standard APIs when needed.</p>
<p>For example, LARC recommends the PAN bus for component communication, but you can also use:</p>
<ul><li>Custom events</li>
<li>Direct property access</li>
<li>Shared state objects</li>
<li>URL parameters</li>
<li>LocalStorage</li>
<li>Any other standard browser API</li>
</ul>
Choose the right tool for your specific use case.
<h3>Explicit Over Implicit</h3>
<p>LARC favors explicitness. When a component fetches data, you see the fetch call. When state changes, you see the assignment. When events are dispatched, you see the dispatch.</p>
<p>Compare these two approaches:</p>
<strong>Implicit (typical framework):</strong>
<pre><code class="language-jsx">function UserProfile() {
  const [user, loading, error] = useUser(userId);

  if (loading) return &lt;Spinner /&gt;;
  if (error) return &lt;Error message={error} /&gt;;

  return &lt;ProfileCard user={user} /&gt;;
}</code></pre>
<p>Magic happens in <code>useUser</code>. Where does the data come from? When does it refetch? What triggers updates? You need to understand the framework's mental model.</p>
<strong>Explicit (LARC):</strong>
<pre><code class="language-javascript">class UserProfile extends HTMLElement {
  async connectedCallback() {
    this.render({ loading: true });

    try {
      const response = await fetch(`/api/users/${this.userId}`);
      const user = await response.json();
      this.render({ user });
    } catch (error) {
      this.render({ error: error.message });
    }
  }

  render(state) {
    if (state.loading) {
      this.innerHTML = &#039;&lt;loading-spinner&gt;&lt;/loading-spinner&gt;&#039;;
    } else if (state.error) {
      this.innerHTML = `&lt;error-message text=&quot;${state.error}&quot;&gt;&lt;/error-message&gt;`;
    } else {
      this.innerHTML = `&lt;profile-card .user=&quot;${state.user}&quot;&gt;&lt;/profile-card&gt;`;
    }
  }
}</code></pre>
<p>Every step is visible. You can trace exactly what happens and when. Debugging is straightforward because you're working with standard JavaScript.</p>
<h2>Why "No Build" Matters</h2>
<p>The "no build" philosophy isn't about being purist or rejecting tools. It's about removing unnecessary complexity and its associated costs.</p>
<h3>Development Speed</h3>
<p>Without a build step, your development cycle is:</p>
<li>Edit code</li>
<li>Refresh browser</li>
<li>See changes</li>
<p>That's it. No waiting for webpack to rebuild. No watching file watchers fail. No debugging build configurations.</p>
<p>This might seem like a small thing, but it compounds. Over a day of development, those 10-30 second build times add up to significant lost productivity. More importantly, they break flow state.</p>
<h3>Debugging Simplicity</h3>
<p>When you open browser DevTools in a LARC application, you see your actual code. No source maps needed. No transpiled output. No minified framework internals.</p>
<p>Set a breakpoint in your component's <code>connectedCallback</code>. It stops exactly where you expect. The call stack is readable. Variables are named as you wrote them.</p>
<p>This makes debugging accessible to junior developers and reduces time spent fighting tools.</p>
<h3>Deployment Simplicity</h3>
<p>A LARC application can be deployed to any static host:</p>
<ul><li>GitHub Pages</li>
<li>Netlify</li>
<li>Vercel</li>
<li>Amazon S3</li>
<li>Any web server</li>
</ul>
No server-side rendering. No Node.js runtime. No build artifacts to manage. Just upload HTML, CSS, and JavaScript files.
<p>Want to deploy to a CDN? Your entire application is already CDN-friendly because it's just static files.</p>
<h3>Lower Barrier to Entry</h3>
<p>New developers can learn web development by:</p>
<li>Creating an HTML file</li>
<li>Adding some CSS and JavaScript</li>
<li>Opening it in a browser</li>
<p>No installation. No environment setup. No project configuration. This is how the web should work.</p>
<p>With build tools, new developers face:</p>
<li>Install Node.js</li>
<li>Learn npm/yarn</li>
<li>Understand package.json</li>
<li>Configure webpack/Babel</li>
<li>Troubleshoot build errors</li>
<li>Learn framework-specific tooling</li>
<p>Before writing a single line of application code, they've already encountered dozens of concepts unrelated to actual web development.</p>
<h3>Sustainability</h3>
<p>Build tools and frameworks change rapidly. A React application from 2015 likely needs significant updates to run today. Build configurations break. Dependencies become unmaintained. Migration guides are incomplete.</p>
<p>LARC applications use web standards. A LARC application from 2025 will still run in 2035 because it's built on stable browser APIs, not framework-specific abstractions.</p>
<p>This doesn't mean LARC applications never need updates—APIs evolve, best practices change. But the core architecture is built on a foundation that changes slowly and deliberately through standards processes.</p>
<h2>When to Use LARC</h2>
<p>LARC isn't the right choice for every project. Understanding when to use it (and when not to) helps you make informed decisions.</p>
<h3>LARC Excels At</h3>
<strong>Small to Medium Applications</strong>
Projects with 10-100 components where simplicity and maintainability matter more than framework ecosystem size.
<strong>Dashboard and Admin Panels</strong>
Internal tools where the development team controls the environment and values fast iteration.
<strong>Progressive Web Apps</strong>
Applications that benefit from offline-first architecture and minimal JavaScript overhead.
<strong>Learning Projects</strong>
Teaching web development without the complexity of modern toolchains.
<strong>Embedded Widgets</strong>
Reusable components that need to work in any environment without framework dependencies.
<strong>Prototypes and MVPs</strong>
Quickly validating ideas without upfront tooling investment.
<h3>Consider Alternatives When</h3>
<strong>Very Large Teams</strong>
If you have 50+ developers working on a single codebase, framework opinions and tooling might provide valuable guardrails.
<strong>Heavy Framework Ecosystem Dependencies</strong>
If your project critically relies on a specific framework's ecosystem (e.g., React Native integration, specific UI libraries), switching costs may be prohibitive.
<strong>Server-Side Rendering is Critical</strong>
While LARC supports SSR, frameworks like Next.js have more mature SSR/SSG ecosystems.
<strong>Team Expertise</strong>
If your entire team is deeply experienced in React/Vue/Angular and inexperienced with Web Components, the learning curve might slow initial development.
<p>That said, LARC's simplicity often means the learning curve is shorter than expected. Most experienced developers can become productive with LARC in days, not weeks.</p>
<h3>Hybrid Approaches</h3>
<p>You don't have to go all-in on LARC. Consider hybrid approaches:</p>
<strong>Progressive Migration</strong>
Build new features in LARC while maintaining existing framework code. Web Components can coexist with React, Vue, or Angular.
<strong>Micro-frontends</strong>
Use LARC for some micro-frontends and other frameworks for others. Web Components provide clean boundaries.
<strong>Component Libraries</strong>
Build a LARC component library that can be consumed by any framework or vanilla JavaScript.
<h2>What You'll Build</h2>
<p>Throughout this book, you'll build several progressively complex applications:</p>
<h3>Chapter Examples</h3>
<p>Each chapter includes focused examples demonstrating specific concepts:</p>
<ul><li>A <strong>counter component</strong> (Chapter 4) to understand component basics</li>
<li>A <strong>todo list</strong> (Chapter 5) to learn PAN bus communication</li>
<li>A <strong>user profile form</strong> (Chapter 9) to master form handling</li>
<li>A <strong>data table</strong> (Chapter 10) to work with APIs and data</li>
</ul>
<h3>Capstone Project: TaskFlow</h3>
<p>In the final chapters, you'll build <strong>TaskFlow</strong>, a complete project management application featuring:</p>
<ul><li>User authentication and authorization</li>
<li>Real-time collaboration via WebSockets</li>
<li>Offline-first architecture with IndexedDB</li>
<li>Drag-and-drop task boards</li>
<li>File attachments and comments</li>
<li>Search and filtering</li>
<li>Data visualization</li>
<li>Mobile-responsive design</li>
</ul>
TaskFlow will demonstrate how LARC patterns scale to production applications while remaining maintainable and performant.
<h3>What You'll Learn</h3>
<p>By the end of this book, you'll be able to:</p>
<ul><li>Build complex, maintainable applications using Web Components</li>
<li>Design effective component communication patterns with the PAN bus</li>
<li>Manage application state without external frameworks</li>
<li>Integrate with backend APIs and real-time services</li>
<li>Handle routing, forms, and authentication</li>
<li>Write testable, reusable components</li>
<li>Optimize performance and bundle size</li>
<li>Deploy LARC applications to production</li>
<li>Make informed decisions about when to use LARC vs. other approaches</li>
</ul>
<h2>Looking Ahead</h2>
<p>The next chapter dives into LARC's core concepts: Web Components, the PAN bus, and event-driven architecture. You'll learn the fundamental patterns that make LARC applications work.</p>
<p>But before we get technical, take a moment to consider what drew you to this book. Perhaps you're tired of build tool complexity. Perhaps you want to understand how the web really works. Perhaps you're curious about a different approach.</p>
<p>Whatever your motivation, LARC offers something increasingly rare in modern web development: simplicity without sacrificing capability. You're about to learn how to build serious web applications using the platform itself, not abstractions on top of it.</p>
<p>Let's begin.</p>
<hr>
<h2>Summary</h2>
<ul><li>Modern web development has become unnecessarily complex with build tools, frameworks, and abstractions</li>
<li>The web platform has evolved to support features natively that once required frameworks</li>
<li>LARC uses web standards (Web Components, ES Modules, Import Maps) to build applications without build steps</li>
<li>Core principles: standards first, zero build for development, progressive enhancement, local first</li>
<li>"No build" matters for development speed, debugging simplicity, deployment, and sustainability</li>
<li>LARC works best for small-to-medium applications, dashboards, PWAs, and prototypes</li>
<li>You'll build real applications throughout this book, culminating in a production-ready project management app</li>
</ul>
<hr>
<h2>Further Reading</h2>
<strong>For comprehensive reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 1: Introduction - Reference manual overview and conventions</li>
<li><em>Building with LARC</em> Chapter 2: Core Concepts - Deep dive into LARC architecture</li>
<li><em>Building with LARC</em> Appendix D: Migration Guide - Migrating from React, Vue, Angular</li>
</ul>
<div class="pagebreak"></div>
<h1>Core Concepts</h1>
<p>Now that you understand LARC's philosophy, let's explore the technical foundation that makes it work. This chapter introduces the core concepts you'll use throughout the book: Web Components, the PAN bus, event-driven architecture, and the component lifecycle.</p>
<p>Don't worry if some of these concepts are new to you. We'll build understanding progressively, starting with the basics and working toward more sophisticated patterns.</p>
<h2>Web Components Refresher</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/01-architecture-overview-1.png"><strong>Figure 2.1:</strong> LARC High-Level Architecture</a></p>
<p>Web Components are a suite of browser APIs that let you create custom, reusable HTML elements. Unlike framework components, Web Components are browser standards supported natively across all modern browsers.</p>
<h3>The Three Pillars</h3>
<p>Web Components rest on three main technologies:</p>
<p>#### 1. Custom Elements</p>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/02-component-structure-2.png"><strong>Figure 2.2:</strong> Web Component Anatomy</a></p>
<p>Custom Elements let you define new HTML tags with custom behavior:</p>
<pre><code class="language-javascript">// Define a custom element
class HelloWorld extends HTMLElement {
  connectedCallback() {
    this.textContent = &#039;Hello, World!&#039;;
  }
}

// Register it
customElements.define(&#039;hello-world&#039;, HelloWorld);</code></pre>
<p>Now you can use <code><hello-world></hello-world></code> in your HTML, and it works like any built-in element.</p>
<strong>Key Points:</strong>
<ul><li>Element names must contain a hyphen (e.g., <code>my-component</code>, not <code>mycomponent</code>)</li>
<li>Custom elements inherit from <code>HTMLElement</code> or another HTML element</li>
<li>They have lifecycle callbacks for creation, connection, and removal</li>
</ul>
#### 2. Shadow DOM
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/02-component-structure-4.png"><strong>Figure 2.3:</strong> Shadow DOM Tree Structure</a></p>
<p>Shadow DOM provides style and markup encapsulation:</p>
<pre><code class="language-javascript">class FancyButton extends HTMLElement {
  constructor() {
    super();
    // Create shadow root
    this.attachShadow({ mode: &#039;open&#039; });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button {
          background: blue;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
        }
      &lt;/style&gt;
      &lt;button&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/button&gt;
    `;
  }
}

customElements.define(&#039;fancy-button&#039;, FancyButton);</code></pre>
<p>The styles inside Shadow DOM don't leak out, and external styles don't leak in:</p>
<pre><code class="language-html">&lt;!-- This button is blue (from shadow DOM) --&gt;
&lt;fancy-button&gt;Click Me&lt;/fancy-button&gt;

&lt;!-- This button is not affected by fancy-button&#039;s styles --&gt;
&lt;button&gt;Regular Button&lt;/button&gt;

&lt;style&gt;
  /* This won&#039;t affect fancy-button&#039;s internal button */
  button { background: red; }
&lt;/style&gt;</code></pre>
<strong>Key Points:</strong>
<ul><li>Shadow DOM creates an isolated scope for styles and DOM</li>
<li>Use <code><slot></code> elements to project content from light DOM into shadow DOM</li>
<li><code>mode: 'open'</code> makes shadow root accessible via <code>element.shadowRoot</code></li>
</ul>
#### 3. HTML Templates
<p>Templates define reusable chunks of markup that aren't rendered until activated:</p>
<pre><code class="language-html">&lt;template id=&quot;card-template&quot;&gt;
  &lt;style&gt;
    .card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 16px;
    }
  &lt;/style&gt;
  &lt;div class=&quot;card&quot;&gt;
    &lt;h2 class=&quot;title&quot;&gt;&lt;/h2&gt;
    &lt;p class=&quot;content&quot;&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  class SimpleCard extends HTMLElement {
    connectedCallback() {
      const template = document.getElementById(&#039;card-template&#039;);
      const clone = template.content.cloneNode(true);

      clone.querySelector(&#039;.title&#039;).textContent = this.getAttribute(&#039;title&#039;);
      clone.querySelector(&#039;.content&#039;).textContent = this.getAttribute(&#039;content&#039;);

      this.attachShadow({ mode: &#039;open&#039; });
      this.shadowRoot.appendChild(clone);
    }
  }

  customElements.define(&#039;simple-card&#039;, SimpleCard);
&lt;/script&gt;</code></pre>
<strong>Key Points:</strong>
<ul><li>Template content is inert (scripts don't run, images don't load)</li>
<li>Templates can be defined in HTML or created programmatically</li>
<li>Clone template content before using it</li>
</ul>
<h3>Web Components vs Framework Components</h3>
<p>It's worth understanding how Web Components differ from framework components:</p>
<p>| Aspect | Web Components | React Components |
|--------|---------------|------------------|
| <strong>Definition</strong> | Browser standard | Library-specific |
| <strong>Syntax</strong> | JavaScript classes | JSX or functions |
| <strong>Lifecycle</strong> | Native callbacks | Virtual DOM lifecycle |
| <strong>Reusability</strong> | Works everywhere | Requires React |
| <strong>Build step</strong> | Optional | Required (for JSX) |
| <strong>Encapsulation</strong> | Shadow DOM | CSS Modules/CSS-in-JS |</p>
<p>Both approaches have their place. Web Components excel at true reusability and standards-based development. Framework components often provide better ergonomics within their specific ecosystem.</p>
<p>LARC chooses Web Components because they align with the "standards first" principle.</p>
<h2>The Page Area Network (PAN)</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/01-architecture-overview-2.png"><strong>Figure 2.4:</strong> Component Communication Flow</a></p>
<p>The Page Area Network, or PAN bus, is LARC's event-driven communication system. It's inspired by microservices architecture but designed for browser components.</p>
<h3>The Problem It Solves</h3>
<p>In a traditional component tree, communication flows up and down:</p>
<pre><code class="language-plaintext">App
├── Header
│   └── UserMenu
│       └── LogoutButton
└── Content
    └── UserProfile</code></pre>
<p>If <code>LogoutButton</code> needs to notify <code>UserProfile</code> that the user logged out, you have several options:</p>
<li><strong>Pass callbacks down</strong> through props (prop drilling)</li>
<li><strong>Lift state up</strong> to a common ancestor</li>
<li><strong>Use context</strong> or global state</li>
<li><strong>Dispatch custom events</strong> that bubble up</li>
<p>Each approach has tradeoffs. Prop drilling creates tight coupling. Global state makes testing harder. Event bubbling is limited by DOM structure.</p>
<h3>The PAN Bus Approach</h3>
<p>The PAN bus provides a <strong>decoupled pub/sub system</strong>:</p>
<pre><code class="language-javascript">// LogoutButton publishes an event
pan.publish(&#039;user.logout&#039;, { userId: 123 });

// UserProfile subscribes to events (anywhere in the app)
pan.subscribe(&#039;user.logout&#039;, (data) =&gt; {
  console.log(&#039;User logged out:&#039;, data.userId);
  this.clearUserData();
});</code></pre>
<p>Components don't need to know about each other. They communicate through topics (like <code>'user.logout'</code>) with no direct coupling.</p>
<h3>Topic Namespaces</h3>
<p>Topics use dot notation for organization:</p>
<pre><code class="language-javascript">&#039;user.login&#039;          // User logged in
&#039;user.logout&#039;         // User logged out
&#039;user.profile.update&#039; // Profile was updated

&#039;cart.item.add&#039;       // Item added to cart
&#039;cart.item.remove&#039;    // Item removed
&#039;cart.checkout&#039;       // Checkout initiated

&#039;app.theme.change&#039;    // Theme changed
&#039;app.error&#039;           // Application error</code></pre>
<p>You can subscribe to specific topics or use wildcards:</p>
<pre><code class="language-javascript">// Specific topic
pan.subscribe(&#039;user.login&#039;, handler);

// Wildcard (all user events)
pan.subscribe(&#039;user.*&#039;, handler);

// All events (useful for debugging)
pan.subscribe(&#039;*&#039;, handler);</code></pre>
<h3>Message Patterns</h3>
<p>The PAN bus supports several messaging patterns:</p>
<p>#### 1. Fire and Forget</p>
<p>Most common pattern. Publish a message and continue:</p>
<pre><code class="language-javascript">pan.publish(&#039;notification.show&#039;, {
  type: &#039;success&#039;,
  message: &#039;Saved successfully&#039;
});</code></pre>
<p>#### 2. Request/Response</p>
<p>Publish a message and wait for a response:</p>
<pre><code class="language-javascript">const result = await pan.request(&#039;api.fetch&#039;, {
  url: &#039;/api/users&#039;,
  method: &#039;GET&#039;
});</code></pre>
<p>A subscriber handles the request and returns data:</p>
<pre><code class="language-javascript">pan.respond(&#039;api.fetch&#039;, async (data) =&gt; {
  const response = await fetch(data.url, { method: data.method });
  return response.json();
});</code></pre>
<p>#### 3. State Broadcast</p>
<p>Publish state changes that multiple components need:</p>
<pre><code class="language-javascript">// Theme switcher publishes
pan.publish(&#039;app.theme.change&#039;, { theme: &#039;dark&#039; });

// Multiple components subscribe
class Header extends HTMLElement {
  connectedCallback() {
    pan.subscribe(&#039;app.theme.change&#039;, ({ theme }) =&gt; {
      this.applyTheme(theme);
    });
  }
}

class Sidebar extends HTMLElement {
  connectedCallback() {
    pan.subscribe(&#039;app.theme.change&#039;, ({ theme }) =&gt; {
      this.applyTheme(theme);
    });
  }
}</code></pre>
<h3>Why PAN Bus?</h3>
<p>The PAN bus provides several advantages:</p>
<strong>Loose Coupling</strong>
Components don't need references to each other. Add or remove components without changing others.
<strong>Testability</strong>
Test components in isolation. Mock the bus or test actual pub/sub behavior.
<strong>Debuggability</strong>
Subscribe to <code>'*'</code> to log all messages. Visualize message flow easily.
<strong>Scalability</strong>
Add new features by subscribing to existing topics. No need to modify existing code.
<strong>Flexibility</strong>
Mix different communication patterns (events, requests, broadcasts) as needed.
<h2>Event-Driven Architecture</h2>
<p>LARC applications use event-driven architecture (EDA) at multiple levels:</p>
<h3>Browser Events</h3>
<p>Standard DOM events for user interaction:</p>
<pre><code class="language-javascript">class ClickCounter extends HTMLElement {
  constructor() {
    super();
    this.count = 0;
  }

  connectedCallback() {
    this.innerHTML = `
      &lt;button id=&quot;btn&quot;&gt;Clicked ${this.count} times&lt;/button&gt;
    `;

    this.querySelector(&#039;#btn&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.count++;
      this.querySelector(&#039;#btn&#039;).textContent = `Clicked ${this.count} times`;
    });
  }
}</code></pre>
<h3>Custom Events</h3>
<p>Components can dispatch custom events for parent components:</p>
<pre><code class="language-javascript">class ColorPicker extends HTMLElement {
  selectColor(color) {
    // Dispatch custom event
    this.dispatchEvent(new CustomEvent(&#039;colorchange&#039;, {
      detail: { color },
      bubbles: true,
      composed: true  // Cross shadow DOM boundary
    }));
  }
}

// Parent can listen
document.querySelector(&#039;color-picker&#039;).addEventListener(&#039;colorchange&#039;, (e) =&gt; {
  console.log(&#039;Selected color:&#039;, e.detail.color);
});</code></pre>
<h3>PAN Bus Events</h3>
<p>For cross-component communication:</p>
<pre><code class="language-javascript">class SearchBox extends HTMLElement {
  handleInput(value) {
    pan.publish(&#039;search.query&#039;, { query: value });
  }
}

class SearchResults extends HTMLElement {
  connectedCallback() {
    pan.subscribe(&#039;search.query&#039;, ({ query }) =&gt; {
      this.search(query);
    });
  }
}</code></pre>
<h3>When to Use Each</h3>
<strong>Use DOM Events when:</strong>
<ul><li>Handling user interactions (click, input, focus, etc.)</li>
<li>Communication is parent-child relationship</li>
<li>Following HTML semantics matters</li>
</ul>
<strong>Use Custom Events when:</strong>
<ul><li>Component needs to notify parent/ancestors</li>
<li>Event should bubble up the DOM tree</li>
<li>Mimicking native element behavior</li>
</ul>
<strong>Use PAN Bus when:</strong>
<ul><li>Components are not in parent-child relationship</li>
<li>Multiple unrelated components need the same data</li>
<li>Decoupling is more important than DOM semantics</li>
<li>Building cross-cutting concerns (logging, analytics, etc.)</li>
</ul>
<h2>State Management Philosophy</h2>
<p>LARC takes a pragmatic approach to state management: use the simplest solution that works, then scale up if needed.</p>
<h3>State Hierarchy</h3>
<p>State can exist at different levels:</p>
<p>#### 1. Component-Local State</p>
<p>State that only matters to one component:</p>
<pre><code class="language-javascript">class TodoItem extends HTMLElement {
  constructor() {
    super();
    this.completed = false;  // Local state
  }

  toggle() {
    this.completed = !this.completed;
    this.render();
  }

  render() {
    this.classList.toggle(&#039;completed&#039;, this.completed);
  }
}</code></pre>
<strong>When to use:</strong> UI state, temporary values, component-specific configuration.
<p>#### 2. Shared State</p>
<p>State that multiple components need:</p>
<pre><code class="language-javascript">// Simple shared state object
const appState = {
  user: null,
  theme: &#039;light&#039;,
  notifications: []
};

// Components read from it
class UserMenu extends HTMLElement {
  connectedCallback() {
    this.render(appState.user);
  }
}

// Components write to it and notify via PAN
function updateTheme(theme) {
  appState.theme = theme;
  pan.publish(&#039;app.theme.change&#039;, { theme });
}</code></pre>
<strong>When to use:</strong> Application-wide settings, user data, feature flags.
<p>#### 3. Persistent State</p>
<p>State that survives page reloads:</p>
<pre><code class="language-javascript">class TodoList extends HTMLElement {
  loadTodos() {
    const saved = localStorage.getItem(&#039;todos&#039;);
    return saved ? JSON.parse(saved) : [];
  }

  saveTodos(todos) {
    localStorage.setItem(&#039;todos&#039;, JSON.stringify(todos));
  }
}</code></pre>
<strong>When to use:</strong> User preferences, draft content, offline data.
<p>#### 4. Server State</p>
<p>State that comes from and syncs with a server:</p>
<pre><code class="language-javascript">class UserProfile extends HTMLElement {
  async loadProfile() {
    const response = await fetch(&#039;/api/profile&#039;);
    this.profile = await response.json();
    this.render();
  }

  async saveProfile(updates) {
    await fetch(&#039;/api/profile&#039;, {
      method: &#039;PUT&#039;,
      body: JSON.stringify(updates)
    });
  }
}</code></pre>
<strong>When to use:</strong> Database records, API data, real-time updates.
<h3>Reactive State (Optional)</h3>
<p>For more complex state needs, LARC provides reactive patterns using JavaScript Proxies:</p>
<pre><code class="language-javascript">function createStore(initialState) {
  const listeners = new Set();

  const state = new Proxy(initialState, {
    set(target, property, value) {
      target[property] = value;
      listeners.forEach(fn =&gt; fn(property, value));
      return true;
    }
  });

  return {
    state,
    subscribe(fn) {
      listeners.add(fn);
      return () =&gt; listeners.delete(fn);
    }
  };
}

// Usage
const store = createStore({ count: 0 });

class Counter extends HTMLElement {
  connectedCallback() {
    // Subscribe to changes
    this.unsubscribe = store.subscribe((prop, value) =&gt; {
      if (prop === &#039;count&#039;) this.render();
    });

    this.render();
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  render() {
    this.textContent = `Count: ${store.state.count}`;
  }
}

// Update state (automatically notifies subscribers)
store.state.count++;</code></pre>
<p>This is similar to MobX or Vue's reactivity, but built with standard JavaScript.</p>
<h2>Module System</h2>
<p>LARC uses ES Modules, the native JavaScript module system.</p>
<h3>Import/Export Basics</h3>
<p>Export from a module:</p>
<pre><code class="language-javascript">// components/button.js
export class PanButton extends HTMLElement {
  // ...
}

export const BUTTON_TYPES = [&#039;primary&#039;, &#039;secondary&#039;, &#039;danger&#039;];

export default PanButton;</code></pre>
<p>Import into another module:</p>
<pre><code class="language-javascript">// app.js
import PanButton, { BUTTON_TYPES } from &#039;./components/button.js&#039;;

// Or import everything
import * as Button from &#039;./components/button.js&#039;;</code></pre>
<h3>Import Maps</h3>
<p>Import Maps let you define aliases for module paths:</p>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@3.0.1/pan.mjs&quot;,
    &quot;@larcjs/ui&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/components@2.0.0/pan-card.mjs&quot;,
    &quot;app/&quot;: &quot;/src/&quot;,
    &quot;components/&quot;: &quot;/&quot;
  }
}
&lt;/script&gt;

&lt;script type=&quot;module&quot;&gt;
  // Use aliases
  import { pan } from &#039;@larcjs/core&#039;;
  import { PanButton } from &#039;@larcjs/ui&#039;;
  import { Header } from &#039;components/header.js&#039;;
&lt;/script&gt;</code></pre>
<p>This is similar to webpack's resolve aliases, but it's a browser standard.</p>
<h3>Module Organization</h3>
<p>A typical LARC project structure:</p>
<pre><code class="language-plaintext">src/
├── components/
│   ├── header.js
│   ├── footer.js
│   └── sidebar.js
├── lib/
│   ├── api.js
│   ├── auth.js
│   └── utils.js
├── pages/
│   ├── home.js
│   ├── dashboard.js
│   └── profile.js
└── app.js</code></pre>
<p>Each file is a module with clear responsibilities:</p>
<pre><code class="language-javascript">// src/lib/api.js
export async function fetchJSON(url, options = {}) {
  const response = await fetch(url, {
    ...options,
    headers: {
      &#039;Content-Type&#039;: &#039;application/json&#039;,
      ...options.headers
    }
  });

  if (!response.ok) {
    throw new Error(`API error: ${response.status}`);
  }

  return response.json();
}

// src/components/user-list.js
import { fetchJSON } from &#039;../lib/api.js&#039;;

export class UserList extends HTMLElement {
  async connectedCallback() {
    const users = await fetchJSON(&#039;/api/users&#039;);
    this.render(users);
  }
}

customElements.define(&#039;user-list&#039;, UserList);</code></pre>
<h2>The Component Lifecycle</h2>
<p>Understanding the component lifecycle is essential for building robust LARC applications.</p>
<h3>Lifecycle Callbacks</h3>
<p>Web Components provide several lifecycle callbacks:</p>
<p>#### constructor()</p>
<p>Called when an instance is created:</p>
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  constructor() {
    // MUST call super() first
    super();

    // Initialize instance properties
    this.count = 0;
    this.data = null;

    // Attach shadow DOM if needed
    this.attachShadow({ mode: &#039;open&#039; });

    // DON&#039;T access attributes or children here
    // They might not be set yet
  }
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Always call <code>super()</code> first</li>
<li>Initialize instance properties</li>
<li>Attach shadow DOM</li>
<li>Don't access attributes, children, or parent elements</li>
<li>Don't render here (use <code>connectedCallback</code> instead)</li>
</ul>
#### connectedCallback()
<p>Called when the element is inserted into the DOM:</p>
<pre><code class="language-javascript">connectedCallback() {
  // Now it&#039;s safe to access attributes, children, parent
  const title = this.getAttribute(&#039;title&#039;);

  // Render initial content
  this.render();

  // Add event listeners
  this.addEventListener(&#039;click&#039;, this.handleClick);

  // Fetch data
  this.loadData();

  // Subscribe to PAN events
  this.unsubscribe = pan.subscribe(&#039;data.update&#039;, this.handleUpdate);
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Render initial content</li>
<li>Add event listeners</li>
<li>Subscribe to events</li>
<li>Fetch initial data</li>
<li>Can be called multiple times if element is moved</li>
</ul>
#### disconnectedCallback()
<p>Called when the element is removed from the DOM:</p>
<pre><code class="language-javascript">disconnectedCallback() {
  // Clean up event listeners
  this.removeEventListener(&#039;click&#039;, this.handleClick);

  // Unsubscribe from PAN events
  if (this.unsubscribe) {
    this.unsubscribe();
  }

  // Cancel pending operations
  if (this.fetchController) {
    this.fetchController.abort();
  }

  // Clear timers
  if (this.timer) {
    clearInterval(this.timer);
  }
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Remove event listeners to prevent memory leaks</li>
<li>Unsubscribe from PAN events</li>
<li>Cancel pending async operations</li>
<li>Clear timers and intervals</li>
</ul>
#### attributeChangedCallback(name, oldValue, newValue)
<p>Called when observed attributes change:</p>
<pre><code class="language-javascript">static get observedAttributes() {
  return [&#039;title&#039;, &#039;count&#039;, &#039;active&#039;];
}

attributeChangedCallback(name, oldValue, newValue) {
  // Called for each observed attribute that changes
  if (name === &#039;title&#039;) {
    this.updateTitle(newValue);
  } else if (name === &#039;count&#039;) {
    this.updateCount(Number(newValue));
  } else if (name === &#039;active&#039;) {
    this.updateActive(newValue !== null);
  }
}</code></pre>
<strong>Best practices:</strong>
<ul><li>Only observe attributes you actually use</li>
<li>Convert string values to appropriate types</li>
<li>Handle null/undefined values</li>
<li>Update only what changed (don't re-render everything)</li>
</ul>
#### adoptedCallback()
<p>Called when the element is moved to a new document (rare):</p>
<pre><code class="language-javascript">adoptedCallback() {
  // Usually not needed
  // Called when element is moved between documents
  // (e.g., iframe scenarios)
}</code></pre>
<h3>Complete Lifecycle Example</h3>
<p>Here's a full component showing proper lifecycle management:</p>
<pre><code class="language-javascript">class DataTable extends HTMLElement {
  // Define which attributes to observe
  static get observedAttributes() {
    return [&#039;url&#039;, &#039;page-size&#039;];
  }

  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });

    // Initialize state
    this.data = [];
    this.pageSize = 10;
    this.currentPage = 1;
  }

  async connectedCallback() {
    // Initial render
    this.render();

    // Load data if URL is set
    const url = this.getAttribute(&#039;url&#039;);
    if (url) {
      await this.loadData(url);
    }

    // Subscribe to events
    this.unsubscribePan = pan.subscribe(&#039;table.refresh&#039;, () =&gt; {
      this.refresh();
    });

    // Set up event listeners
    this.addEventListener(&#039;page-change&#039;, this.handlePageChange);
  }

  disconnectedCallback() {
    // Clean up subscriptions
    if (this.unsubscribePan) {
      this.unsubscribePan();
    }

    // Remove event listeners
    this.removeEventListener(&#039;page-change&#039;, this.handlePageChange);

    // Cancel pending fetch
    if (this.fetchController) {
      this.fetchController.abort();
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    if (name === &#039;url&#039; &amp;&amp; newValue) {
      this.loadData(newValue);
    } else if (name === &#039;page-size&#039;) {
      this.pageSize = Number(newValue) || 10;
      this.render();
    }
  }

  async loadData(url) {
    // Cancel previous fetch if any
    if (this.fetchController) {
      this.fetchController.abort();
    }

    this.fetchController = new AbortController();

    try {
      const response = await fetch(url, {
        signal: this.fetchController.signal
      });
      this.data = await response.json();
      this.render();
    } catch (error) {
      if (error.name !== &#039;AbortError&#039;) {
        console.error(&#039;Failed to load data:&#039;, error);
      }
    }
  }

  render() {
    // Render logic here
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
      &lt;/style&gt;
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Status&lt;/th&gt;&lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          ${this.data.map(row =&gt; `
            &lt;tr&gt;
              &lt;td&gt;${row.id}&lt;/td&gt;
              &lt;td&gt;${row.name}&lt;/td&gt;
              &lt;td&gt;${row.status}&lt;/td&gt;
            &lt;/tr&gt;
          `).join(&#039;&#039;)}
        &lt;/tbody&gt;
      &lt;/table&gt;
    `;
  }

  handlePageChange = (event) =&gt; {
    this.currentPage = event.detail.page;
    this.render();
  }

  async refresh() {
    const url = this.getAttribute(&#039;url&#039;);
    if (url) {
      await this.loadData(url);
    }
  }
}

customElements.define(&#039;data-table&#039;, DataTable);</code></pre>
<h2>Summary</h2>
<p>This chapter introduced LARC's core concepts:</p>
<ul><li><strong>Web Components</strong> provide standard, reusable elements with Custom Elements, Shadow DOM, and Templates</li>
<li><strong>The PAN Bus</strong> enables decoupled pub/sub communication between components</li>
<li><strong>Event-Driven Architecture</strong> uses DOM events, custom events, and PAN messages for different scenarios</li>
<li><strong>State Management</strong> starts simple (local state) and scales to shared, persistent, and server state</li>
<li><strong>ES Modules</strong> organize code with standard imports/exports and import maps</li>
<li><strong>Component Lifecycle</strong> provides callbacks for creation, connection, attribute changes, and cleanup</li>
</ul>
In the next chapter, we'll put these concepts into practice by setting up a development environment and building your first LARC application.
<hr>
<h2>Key Takeaways</h2>
<ul><li>Web Components are browser standards, not framework abstractions</li>
<li>Shadow DOM provides true style encapsulation</li>
<li>The PAN bus decouples components through pub/sub messaging</li>
<li>Use the simplest state management that works, then scale up</li>
<li>ES Modules and Import Maps replace build-time bundling</li>
<li>Proper lifecycle management prevents bugs and memory leaks</li>
<li>Components should be self-contained but composable</li>
</ul>
<hr>
<h2>Further Reading</h2>
<strong>For detailed technical reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 2: Core Concepts - Architecture patterns and message flow reference</li>
<li><em>Building with LARC</em> Appendix A: Message Topics Reference - Standard topic conventions</li>
<li><em>Building with LARC</em> Appendix B: Event Envelope Specification - Message format details</li>
<li><em>Building with LARC</em> Appendix F: Glossary - Technical terminology reference</li>
</ul>
<div class="pagebreak"></div>
<h1>Getting Started</h1>
<p>Theory is important, but there's no substitute for hands-on experience. In this chapter, you'll set up your development environment and build your first LARC application. By the end, you'll have a working project and understand the basic development workflow.</p>
<h2>Setting Up Your Development Environment</h2>
<p>One of LARC's strengths is minimal setup requirements. You don't need complex tooling or configuration—just a browser, a text editor, and a way to serve files.</p>
<h3>Requirements</h3>
<strong>Essential:</strong>
<ul><li><strong>Modern browser</strong> — Chrome, Firefox, Safari, or Edge (latest version)</li>
<li><strong>Text editor</strong> — VS Code, Sublime Text, Atom, or any editor you prefer</li>
<li><strong>Local web server</strong> — Python's SimpleHTTPServer, Node's <code>http-server</code>, or VS Code's Live Server extension</li>
</ul>
<strong>Optional but Recommended:</strong>
<ul><li><strong>VS Code</strong> with the LARC extension for snippets and IntelliSense</li>
<li><strong>Browser DevTools</strong> familiarity for debugging</li>
<li><strong>Git</strong> for version control</li>
</ul>
<h3>Quick Start with create-larc-app</h3>
<p>The fastest way to start is using the LARC CLI:</p>
<pre><code class="language-bash"># Install globally
npm install -g create-larc-app

# Create a new project
create-larc-app my-first-app

# Start development server
cd my-first-app
larc dev</code></pre>
<p>Open <code>http://localhost:3000</code> and you'll see your new LARC application running.</p>
<h3>Manual Setup (No CLI)</h3>
<p>Don't want to install Node.js? You can set up a LARC project manually:</p>
<strong>1. Create project structure:</strong>
<pre><code class="language-bash">mkdir my-first-app
cd my-first-app
mkdir src
mkdir src/components
mkdir public</code></pre>
<strong>2. Create <code>index.html</code>:</strong>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;My First LARC App&lt;/title&gt;

  &lt;!-- Import Map for dependencies --&gt;
  &lt;script type=&quot;importmap&quot;&gt;
  {
    &quot;imports&quot;: {
      &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@3.0.1/pan.mjs&quot;
    }
  }
  &lt;/script&gt;

  &lt;style&gt;
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

  &lt;script type=&quot;module&quot; src=&quot;src/app.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<strong>3. Create <code>src/app.js</code>:</strong>
<pre><code class="language-javascript">import { pan } from &#039;@larcjs/core&#039;;

// Import your components
import &#039;./components/hello-world.js&#039;;

// Initialize app
console.log(&#039;LARC app initialized&#039;);
pan.publish(&#039;app.ready&#039;);

// Add component to page
document.getElementById(&#039;app&#039;).innerHTML = &#039;&lt;hello-world&gt;&lt;/hello-world&gt;&#039;;</code></pre>
<strong>4. Create <code>src/components/hello-world.js</code>:</strong>
<pre><code class="language-javascript">class HelloWorld extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;div style=&quot;
        background: white;
        padding: 40px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        text-align: center;
      &quot;&gt;
        &lt;h1&gt;Hello, LARC!&lt;/h1&gt;
        &lt;p&gt;Welcome to your first LARC application.&lt;/p&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;hello-world&#039;, HelloWorld);</code></pre>
<strong>5. Serve the files:</strong>
<pre><code class="language-bash"># Python 3
python3 -m http.server 3000

# Or Python 2
python -m SimpleHTTPServer 3000

# Or with Node.js
npx http-server -p 3000

# Or use VS Code Live Server extension
# (right-click index.html → &quot;Open with Live Server&quot;)</code></pre>
<p>Open <code>http://localhost:3000</code> and you should see "Hello, LARC!" displayed.</p>
<strong>That's it.</strong> No build step. No transpilation. No bundling. Just HTML, CSS, and JavaScript.
<h3>Development Tools</h3>
<p>#### VS Code Extensions</p>
<p>Install these extensions for the best experience:</p>
<strong>LARC Extension:</strong>
<ul><li>Snippets for components and PAN patterns</li>
<li>IntelliSense for LARC APIs</li>
<li>Commands for creating components</li>
</ul>
Install: Search "LARC" in VS Code extensions marketplace
<strong>Live Server:</strong>
<ul><li>Auto-reload when files change</li>
<li>Simple local web server</li>
<li>Right-click HTML file to start</li>
</ul>
Install: Search "Live Server" by Ritwick Dey
<strong>ES6 String HTML:</strong>
<ul><li>Syntax highlighting for template literals</li>
<li>Makes component templates more readable</li>
</ul>
Install: Search "ES6 String HTML"
<p>#### Browser DevTools</p>
<p>Learn these DevTools features for LARC development:</p>
<strong>Elements Panel:</strong>
<p>- Inspect shadow DOM (enable "Show user agent shadow DOM" in settings)
    - View Custom Elements with their properties
    - Debug CSS in shadow roots</p>
<strong>Console:</strong>
<p>- Subscribe to all PAN messages: <code>pan.subscribe('*', console.log)</code>
    - Test components directly: <code>document.querySelector('my-component')</code>
    - Check Custom Elements registry: <code>customElements.get('my-component')</code></p>
<strong>Network Panel:</strong>
<p>- Verify ES modules load correctly
    - Check import map resolution
    - Monitor API calls</p>
<strong>Sources Panel:</strong>
<p>- Set breakpoints in your source code (no source maps needed!)
    - Step through component lifecycle
    - Watch variables and state</p>
<h2>Your First LARC Application</h2>
<p>Let's build something more interesting than "Hello World"—a simple counter application with multiple components communicating via the PAN bus.</p>
<h3>Project Goal</h3>
<p>We'll create:</p>
<p>- A counter display component
    - Increment and decrement buttons
    - A reset button
    - Communication via PAN bus (no prop drilling!)</p>
<h3>Step 1: Update index.html</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Counter App - LARC&lt;/title&gt;

  &lt;script type=&quot;importmap&quot;&gt;
  {
    &quot;imports&quot;: {
      &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@3.0.1/pan.mjs&quot;
    }
  }
  &lt;/script&gt;

  &lt;style&gt;
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, &#039;Segoe UI&#039;, Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #app {
      background: white;
      padding: 40px;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      min-width: 400px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;counter-display&gt;&lt;/counter-display&gt;
    &lt;counter-controls&gt;&lt;/counter-controls&gt;
  &lt;/div&gt;

  &lt;script type=&quot;module&quot; src=&quot;src/app.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3>Step 2: Create app.js</h3>
<pre><code class="language-javascript">// src/app.js
import { pan } from &#039;@larcjs/core&#039;;

// Import components
import &#039;./components/counter-display.js&#039;;
import &#039;./components/counter-controls.js&#039;;

// Initialize application state
let count = 0;

// Listen for increment requests
pan.subscribe(&#039;counter.increment&#039;, () =&gt; {
  count++;
  pan.publish(&#039;counter.updated&#039;, { count });
});

// Listen for decrement requests
pan.subscribe(&#039;counter.decrement&#039;, () =&gt; {
  count--;
  pan.publish(&#039;counter.updated&#039;, { count });
});

// Listen for reset requests
pan.subscribe(&#039;counter.reset&#039;, () =&gt; {
  count = 0;
  pan.publish(&#039;counter.updated&#039;, { count });
});

// Publish initial state
pan.publish(&#039;counter.updated&#039;, { count });

console.log(&#039;Counter app initialized&#039;);</code></pre>
<h3>Step 3: Create counter-display.js</h3>
<pre><code class="language-javascript">// src/components/counter-display.js
import { pan } from &#039;@larcjs/core&#039;;

class CounterDisplay extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.count = 0;
  }

  connectedCallback() {
    // Subscribe to count updates
    this.unsubscribe = pan.subscribe(&#039;counter.updated&#039;, ({ count }) =&gt; {
      this.count = count;
      this.render();
    });

    this.render();
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          text-align: center;
          margin-bottom: 30px;
        }

        .display {
          font-size: 72px;
          font-weight: bold;
          color: #667eea;
          margin-bottom: 10px;
          font-variant-numeric: tabular-nums;
        }

        .label {
          font-size: 18px;
          color: #666;
          text-transform: uppercase;
          letter-spacing: 2px;
        }
      &lt;/style&gt;

      &lt;div class=&quot;display&quot;&gt;${this.count}&lt;/div&gt;
      &lt;div class=&quot;label&quot;&gt;Current Count&lt;/div&gt;
    `;
  }
}

customElements.define(&#039;counter-display&#039;, CounterDisplay);</code></pre>
<h3>Step 4: Create counter-controls.js</h3>
<pre><code class="language-javascript">// src/components/counter-controls.js
import { pan } from &#039;@larcjs/core&#039;;

class CounterControls extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  connectedCallback() {
    this.render();
    this.attachEventListeners();
  }

  attachEventListeners() {
    this.shadowRoot.querySelector(&#039;#increment&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      pan.publish(&#039;counter.increment&#039;);
    });

    this.shadowRoot.querySelector(&#039;#decrement&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      pan.publish(&#039;counter.decrement&#039;);
    });

    this.shadowRoot.querySelector(&#039;#reset&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      pan.publish(&#039;counter.reset&#039;);
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
        }

        .controls {
          display: flex;
          gap: 10px;
          margin-bottom: 15px;
        }

        button {
          flex: 1;
          padding: 15px;
          font-size: 16px;
          font-weight: 600;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.2s;
        }

        button:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        button:active {
          transform: translateY(0);
        }

        #increment {
          background: #48bb78;
          color: white;
        }

        #increment:hover {
          background: #38a169;
        }

        #decrement {
          background: #f56565;
          color: white;
        }

        #decrement:hover {
          background: #e53e3e;
        }

        #reset {
          background: #4a5568;
          color: white;
          width: 100%;
        }

        #reset:hover {
          background: #2d3748;
        }
      &lt;/style&gt;

      &lt;div class=&quot;controls&quot;&gt;
        &lt;button id=&quot;decrement&quot;&gt;− Decrement&lt;/button&gt;
        &lt;button id=&quot;increment&quot;&gt;+ Increment&lt;/button&gt;
      &lt;/div&gt;
      &lt;button id=&quot;reset&quot;&gt;Reset&lt;/button&gt;
    `;
  }
}

customElements.define(&#039;counter-controls&#039;, CounterControls);</code></pre>
<h3>Step 5: Test Your App</h3>
<p>Start your local server and open the page. You should see:</p>
<p>- A large counter display showing "0"
    - Increment and decrement buttons
    - A reset button</p>
<p>Click the buttons. Notice how:</p>
<p>- Components update immediately
    - State is managed centrally in <code>app.js</code>
    - Components don't reference each other directly
    - Adding new components is trivial (just subscribe to <code>counter.updated</code>)</p>
<h3>What Just Happened?</h3>
<p>Let's examine the architecture:</p>
<strong>Data Flow:</strong>
<pre><code class="language-plaintext">User clicks button
     ↓
Controls component publishes event
     ↓
App.js receives event and updates state
     ↓
App.js publishes updated state
     ↓
Display component receives update and re-renders</code></pre>
<strong>Key Points:</strong>
<li><strong>Decoupled Components:</strong> Display and controls don't know about each other</li>
<li><strong>Central State:</strong> State lives in <code>app.js</code>, not in components</li>
<li><strong>Pub/Sub Communication:</strong> All communication via PAN bus topics</li>
<li><strong>No Props:</strong> No prop drilling or lifting state up</li>
<li><strong>Easy Testing:</strong> Each component can be tested in isolation</li>
<h2>Project Structure</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/01-architecture-overview-5.png"><strong>Figure 3.1:</strong> LARC Deployment Architecture</a></p>
<p>As your application grows, organization becomes important. Here's a recommended structure:</p>
<pre><code class="language-plaintext">my-app/
├── index.html              # Entry point
├── larc.config.json        # Optional config
├── src/
│   ├── app.js              # Main application logic
│   ├── components/         # Reusable components
│   │   ├── ui/             # Generic UI components
│   │   │   ├── button.js
│   │   │   ├── card.js
│   │   │   └── modal.js
│   │   ├── features/       # Feature-specific components
│   │   │   ├── user-profile.js
│   │   │   ├── todo-list.js
│   │   │   └── dashboard.js
│   │   └── layout/         # Layout components
│   │       ├── header.js
│   │       ├── sidebar.js
│   │       └── footer.js
│   ├── lib/                # Utilities and helpers
│   │   ├── api.js          # API client
│   │   ├── auth.js         # Authentication
│   │   ├── router.js       # Routing logic
│   │   └── utils.js        # General utilities
│   ├── pages/              # Page-level components
│   │   ├── home.js
│   │   ├── dashboard.js
│   │   └── settings.js
│   └── styles/             # Global styles
│       ├── reset.css
│       ├── variables.css
│       └── utilities.css
├── public/                 # Static assets
│   ├── images/
│   ├── fonts/
│   └── icons/
└── tests/                  # Test files
    ├── components/
    └── integration/</code></pre>
<h3>File Organization Principles</h3>
<strong>Components:</strong>
<p>- One component per file
    - File name matches component name: <code>user-profile.js</code> defines <code><user-profile></code>
    - Keep related components together in subdirectories</p>
<strong>Lib:</strong>
<p>- Utilities that don't render UI
    - API clients, helpers, formatters
    - Pure functions when possible</p>
<strong>Pages:</strong>
<p>- Top-level route components
    - Compose smaller components
    - Handle page-specific logic</p>
<strong>Styles:</strong>
<p>- Global styles in <code>styles/</code>
    - Component-specific styles in Shadow DOM
    - CSS custom properties for theming</p>
<h2>Import Maps Explained</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/01-architecture-overview-4.png"><strong>Figure 3.2:</strong> Module Loading with Import Maps</a></p>
<p>Import Maps are a browser standard that replaces the need for bundlers to resolve module paths.</p>
<h3>Basic Import Map</h3>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;lodash&quot;: &quot;https://cdn.jsdelivr.net/npm/lodash-es@4/lodash.js&quot;,
    &quot;dayjs&quot;: &quot;https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js&quot;
  }
}
&lt;/script&gt;

&lt;script type=&quot;module&quot;&gt;
  // Use package names instead of URLs
  import _ from &#039;lodash&#039;;
  import dayjs from &#039;dayjs&#039;;

  console.log(dayjs().format(&#039;YYYY-MM-DD&#039;));
&lt;/script&gt;</code></pre>
<h3>Path Aliases</h3>
<p>Create shortcuts for your own modules:</p>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;@/&quot;: &quot;/src/&quot;,
    &quot;components/&quot;: &quot;/&quot;,
    &quot;lib/&quot;: &quot;/src/lib/&quot;,
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@3.0.1/pan.mjs&quot;
  }
}
&lt;/script&gt;

&lt;script type=&quot;module&quot;&gt;
  // Instead of: import { api } from &#039;../../../lib/api.js&#039;;
  import { api } from &#039;lib/api.js&#039;;

  // Instead of: import Button from &#039;../components/ui/button.js&#039;;
  import Button from &#039;components/ui/button.js&#039;;

  // Instead of: import something from &#039;../../../src/utils.js&#039;;
  import something from &#039;@/utils.js&#039;;
&lt;/script&gt;</code></pre>
<h3>Version Management</h3>
<p>Pin dependencies to specific versions:</p>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@3.0.1/dist/index.js&quot;,
    &quot;@larcjs/ui&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/ui@3.0.1/dist/index.js&quot;
  }
}</code></pre>
<p>Or use version ranges for automatic updates:</p>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@3.0.1/pan.mjs&quot;,
    &quot;@larcjs/ui&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/ui@3.0.1/dist/index.js&quot;
  }
}</code></pre>
<h3>Multiple CDNs</h3>
<p>Add fallbacks for reliability:</p>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;react&quot;: &quot;https://esm.sh/react@18&quot;,
    &quot;react-fallback&quot;: &quot;https://cdn.skypack.dev/react@18&quot;
  }
}</code></pre>
<p>Then in code:</p>
<pre><code class="language-javascript">let React;
try {
  React = await import(&#039;react&#039;);
} catch {
  React = await import(&#039;react-fallback&#039;);
}</code></pre>
<h3>Development vs Production</h3>
<p>Use different import maps for different environments:</p>
<strong>development.importmap.json:</strong>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;/node_modules/@larcjs/core/dist/index.js&quot;,
    &quot;app/&quot;: &quot;/src/&quot;
  }
}</code></pre>
<strong>production.importmap.json:</strong>
<pre><code class="language-json">{
  &quot;imports&quot;: {
    &quot;@larcjs/core&quot;: &quot;https://cdn.jsdelivr.net/npm/@larcjs/core@3.0.1/dist/index.js&quot;,
    &quot;app/&quot;: &quot;/assets/js/&quot;
  }
}</code></pre>
<p>Load the appropriate map:</p>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot; src=&quot;/config/production.importmap.json&quot;&gt;&lt;/script&gt;</code></pre>
<h2>Development Workflow</h2>
<h3>Daily Development</h3>
<p>A typical development session:</p>
<strong>1. Start dev server:</strong>
<pre><code class="language-bash">larc dev</code></pre>
<p>This starts a local server with hot reload.</p>
<strong>2. Edit files:</strong>
Open your editor and make changes. The browser automatically reloads when you save.
<strong>3. Check the console:</strong>
Open browser DevTools and check for errors or warnings.
<strong>4. Test in browser:</strong>
Interact with your app, verify behavior, check responsive design.
<strong>5. Debug as needed:</strong>
Set breakpoints, inspect elements, monitor network requests.
<strong>6. Repeat:</strong>
The edit-refresh cycle is instant with no build step.
<h3>Debugging Tips</h3>
<strong>Log all PAN messages:</strong>
<pre><code class="language-javascript">pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
  console.log(`[PAN] ${topic}:`, data);
});</code></pre>
<strong>Inspect custom elements:</strong>
<pre><code class="language-javascript">// Get element
const el = document.querySelector(&#039;my-component&#039;);

// Check if defined
console.log(customElements.get(&#039;my-component&#039;));

// Access shadow root
console.log(el.shadowRoot);

// Call methods directly
el.someMethod();</code></pre>
<strong>Monitor attribute changes:</strong>
<pre><code class="language-javascript">// Create observer
const observer = new MutationObserver((mutations) =&gt; {
  mutations.forEach(mutation =&gt; {
    console.log(&#039;Attribute changed:&#039;, mutation.attributeName);
  });
});

// Watch element
observer.observe(element, { attributes: true });</code></pre>
<h3>Testing</h3>
<p>Run tests without a build step:</p>
<pre><code class="language-html">&lt;!-- tests/counter.test.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Counter Tests&lt;/title&gt;
  &lt;script type=&quot;importmap&quot;&gt;
  {
    &quot;imports&quot;: {
      &quot;@larcjs/core&quot;: &quot;../node_modules/@larcjs/core/dist/index.js&quot;
    }
  }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;test-container&quot;&gt;&lt;/div&gt;

  &lt;script type=&quot;module&quot;&gt;
    import { pan } from &#039;@larcjs/core&#039;;
    import &#039;../counter-display.js&#039;;

    // Simple test framework
    function test(name, fn) {
      try {
        fn();
        console.log(`✓ ${name}`);
      } catch (error) {
        console.error(`✗ ${name}:`, error);
      }
    }

    function assert(condition, message) {
      if (!condition) throw new Error(message || &#039;Assertion failed&#039;);
    }

    // Tests
    test(&#039;counter-display renders initial count&#039;, () =&gt; {
      const el = document.createElement(&#039;counter-display&#039;);
      document.getElementById(&#039;test-container&#039;).appendChild(el);

      const display = el.shadowRoot.querySelector(&#039;.display&#039;);
      assert(display.textContent === &#039;0&#039;, &#039;Initial count should be 0&#039;);

      el.remove();
    });

    test(&#039;counter-display updates on PAN message&#039;, async () =&gt; {
      const el = document.createElement(&#039;counter-display&#039;);
      document.getElementById(&#039;test-container&#039;).appendChild(el);

      // Wait for component to connect
      await new Promise(resolve =&gt; setTimeout(resolve, 10));

      // Publish update
      pan.publish(&#039;counter.updated&#039;, { count: 42 });

      // Wait for render
      await new Promise(resolve =&gt; setTimeout(resolve, 10));

      const display = el.shadowRoot.querySelector(&#039;.display&#039;);
      assert(display.textContent === &#039;42&#039;, &#039;Count should update to 42&#039;);

      el.remove();
    });

    console.log(&#039;All tests complete&#039;);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Open <code>tests/counter.test.html</code> in your browser to run tests.</p>
<h2>Common Patterns</h2>
<h3>Pattern 1: Loading States</h3>
<pre><code class="language-javascript">class DataComponent extends HTMLElement {
  async connectedCallback() {
    this.render({ loading: true });

    try {
      const data = await this.fetchData();
      this.render({ data });
    } catch (error) {
      this.render({ error: error.message });
    }
  }

  render(state) {
    if (state.loading) {
      this.innerHTML = &#039;&lt;loading-spinner&gt;&lt;/loading-spinner&gt;&#039;;
    } else if (state.error) {
      this.innerHTML = `&lt;error-message&gt;${state.error}&lt;/error-message&gt;`;
    } else {
      this.innerHTML = `&lt;data-display .data=&quot;${state.data}&quot;&gt;&lt;/data-display&gt;`;
    }
  }
}</code></pre>
<h3>Pattern 2: Form Handling</h3>
<pre><code class="language-javascript">class LoginForm extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;form&gt;
        &lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt;
        &lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt;
        &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;
      &lt;/form&gt;
    `;

    this.querySelector(&#039;form&#039;).addEventListener(&#039;submit&#039;, async (e) =&gt; {
      e.preventDefault();

      const formData = new FormData(e.target);
      const data = Object.fromEntries(formData);

      pan.publish(&#039;auth.login&#039;, data);
    });
  }
}</code></pre>
<h3>Pattern 3: Conditional Rendering</h3>
<pre><code class="language-javascript">class UserMenu extends HTMLElement {
  constructor() {
    super();
    this.user = null;
  }

  connectedCallback() {
    pan.subscribe(&#039;auth.user.changed&#039;, ({ user }) =&gt; {
      this.user = user;
      this.render();
    });

    this.render();
  }

  render() {
    if (this.user) {
      this.innerHTML = `
        &lt;div class=&quot;logged-in&quot;&gt;
          &lt;span&gt;Hello, ${this.user.name}&lt;/span&gt;
          &lt;button id=&quot;logout&quot;&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
      `;

      this.querySelector(&#039;#logout&#039;).addEventListener(&#039;click&#039;, () =&gt; {
        pan.publish(&#039;auth.logout&#039;);
      });
    } else {
      this.innerHTML = `
        &lt;button id=&quot;login&quot;&gt;Login&lt;/button&gt;
      `;

      this.querySelector(&#039;#login&#039;).addEventListener(&#039;click&#039;, () =&gt; {
        pan.publish(&#039;app.navigate&#039;, { path: &#039;/login&#039; });
      });
    }
  }
}</code></pre>
<h3>Pattern 4: Lists and Iteration</h3>
<pre><code class="language-javascript">class TodoList extends HTMLElement {
  constructor() {
    super();
    this.todos = [];
  }

  connectedCallback() {
    pan.subscribe(&#039;todos.updated&#039;, ({ todos }) =&gt; {
      this.todos = todos;
      this.render();
    });

    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;ul&gt;
        ${this.todos.map(todo =&gt; `
          &lt;li&gt;
            &lt;input type=&quot;checkbox&quot;
                   ${todo.completed ? &#039;checked&#039; : &#039;&#039;}
                   data-id=&quot;${todo.id}&quot;&gt;
            &lt;span class=&quot;${todo.completed ? &#039;completed&#039; : &#039;&#039;}&quot;&gt;
              ${todo.text}
            &lt;/span&gt;
          &lt;/li&gt;
        `).join(&#039;&#039;)}
      &lt;/ul&gt;
    `;

    // Attach event listeners after rendering
    this.querySelectorAll(&#039;input[type=&quot;checkbox&quot;]&#039;).forEach(checkbox =&gt; {
      checkbox.addEventListener(&#039;change&#039;, (e) =&gt; {
        const id = e.target.dataset.id;
        pan.publish(&#039;todos.toggle&#039;, { id });
      });
    });
  }
}</code></pre>
<h2>Summary</h2>
<p>In this chapter, you:</p>
<p>- Set up a LARC development environment (CLI or manual)
    - Built your first multi-component application
    - Learned project structure best practices
    - Mastered Import Maps for dependency management
    - Established an efficient development workflow
    - Explored common component patterns</p>
<p>You now have a solid foundation for building LARC applications. The next chapter dives deeper into creating sophisticated Web Components with proper lifecycle management, styling, and interactivity.</p>
<hr>
<h2>Exercises</h2>
<strong>1. Enhance the Counter App:</strong>
<p>- Add a history component that shows past values
    - Add increment/decrement by custom amounts
    - Persist count to localStorage</p>
<strong>2. Build a Todo List:</strong>
<p>- Add/remove todos
    - Mark as complete/incomplete
    - Filter by status (all/active/completed)
    - Use PAN bus for state management</p>
<strong>3. Create a Theme Switcher:</strong>
<p>- Light/dark theme toggle
    - Publish theme changes via PAN
    - Multiple components respond to theme changes
    - Persist theme preference</p>
<strong>4. Experiment with Import Maps:</strong>
<p>- Try different CDNs (jsDelivr, unpkg, esm.sh)
    - Add path aliases for your components
    - Import an external library (lodash, dayjs, etc.)</p>
<p>Take your time with these exercises. Understanding these patterns now will make the rest of the book much easier.</p>
<hr>
<h2>Further Reading</h2>
<strong>For detailed API reference and configuration options:</strong>
<ul><li><em>Building with LARC</em> Chapter 3: Getting Started - Complete installation options and troubleshooting</li>
<li><em>Building with LARC</em> Chapter 2: Core Concepts - Architecture and messaging patterns reference</li>
<li><em>Building with LARC</em> Appendix C: Configuration Options - All configuration parameters</li>
</ul>
<div class="pagebreak"></div>
<h1>Creating Web Components</h1>
<p>Now that you've built your first LARC application, it's time to master the art of creating robust, reusable Web Components. This chapter covers everything from basic component anatomy to advanced patterns like composition, slots, and performance optimization.</p>
<p>By the end of this chapter, you'll be able to build production-quality components that are maintainable, testable, and performant.</p>
<h2>Anatomy of a LARC Component</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/02-component-structure-3.png"><strong>Figure 4.1:</strong> Component Lifecycle Flow</a></p>
<p>Let's dissect a well-structured LARC component to understand its parts:</p>
<pre><code class="language-javascript">// Import dependencies
import { pan } from &#039;@larcjs/core&#039;;
import { formatDate } from &#039;../lib/utils.js&#039;;

/**
 * A card component for displaying user information.
 *
 * @element user-card
 *
 * @attr {string} user-id - The ID of the user to display
 * @attr {boolean} compact - Display in compact mode
 *
 * @fires user-selected - Dispatched when card is clicked
 *
 * @slot - Default slot for additional content
 * @slot actions - Slot for action buttons
 */
class UserCard extends HTMLElement {
  // 1. Define observed attributes
  static get observedAttributes() {
    return [&#039;user-id&#039;, &#039;compact&#039;];
  }

  // 2. Constructor - initialize instance
  constructor() {
    super();

    // Attach shadow DOM
    this.attachShadow({ mode: &#039;open&#039; });

    // Initialize private state
    this._user = null;
    this._loading = false;
    this._error = null;

    // Bind event handlers
    this.handleClick = this.handleClick.bind(this);
  }

  // 3. Lifecycle: connected to DOM
  connectedCallback() {
    this.render();

    // Load user data if ID is provided
    const userId = this.getAttribute(&#039;user-id&#039;);
    if (userId) {
      this.loadUser(userId);
    }

    // Subscribe to PAN events
    this.unsubscribe = pan.subscribe(&#039;user.updated&#039;, this.handleUserUpdate);

    // Add event listeners
    this.shadowRoot.addEventListener(&#039;click&#039;, this.handleClick);
  }

  // 4. Lifecycle: disconnected from DOM
  disconnectedCallback() {
    // Clean up subscriptions
    if (this.unsubscribe) {
      this.unsubscribe();
    }

    // Remove event listeners
    this.shadowRoot.removeEventListener(&#039;click&#039;, this.handleClick);
  }

  // 5. Lifecycle: attributes changed
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    if (name === &#039;user-id&#039; &amp;&amp; newValue) {
      this.loadUser(newValue);
    } else if (name === &#039;compact&#039;) {
      this.render();
    }
  }

  // 6. Public properties with getters/setters
  get user() {
    return this._user;
  }

  set user(value) {
    this._user = value;
    this.render();
  }

  get loading() {
    return this._loading;
  }

  // 7. Public methods
  async loadUser(userId) {
    this._loading = true;
    this._error = null;
    this.render();

    try {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error(&#039;Failed to load user&#039;);

      this._user = await response.json();
      this._loading = false;
      this.render();
    } catch (error) {
      this._error = error.message;
      this._loading = false;
      this.render();
    }
  }

  refresh() {
    const userId = this.getAttribute(&#039;user-id&#039;);
    if (userId) {
      this.loadUser(userId);
    }
  }

  // 8. Private methods
  handleClick(event) {
    if (!this._user) return;

    this.dispatchEvent(new CustomEvent(&#039;user-selected&#039;, {
      detail: { user: this._user },
      bubbles: true,
      composed: true
    }));
  }

  handleUserUpdate = (data) =&gt; {
    if (data.userId === this.getAttribute(&#039;user-id&#039;)) {
      this._user = data.user;
      this.render();
    }
  }

  // 9. Render method
  render() {
    const compact = this.hasAttribute(&#039;compact&#039;);

    if (this._loading) {
      this.shadowRoot.innerHTML = this.renderLoading();
      return;
    }

    if (this._error) {
      this.shadowRoot.innerHTML = this.renderError();
      return;
    }

    if (!this._user) {
      this.shadowRoot.innerHTML = this.renderEmpty();
      return;
    }

    this.shadowRoot.innerHTML = compact
      ? this.renderCompact()
      : this.renderFull();
  }

  renderLoading() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card loading&quot;&gt;
        &lt;div class=&quot;spinner&quot;&gt;&lt;/div&gt;
        &lt;p&gt;Loading...&lt;/p&gt;
      &lt;/div&gt;
    `;
  }

  renderError() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card error&quot;&gt;
        &lt;p class=&quot;error-message&quot;&gt;${this._error}&lt;/p&gt;
        &lt;button class=&quot;retry&quot;&gt;Retry&lt;/button&gt;
      &lt;/div&gt;
    `;
  }

  renderEmpty() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card empty&quot;&gt;
        &lt;p&gt;No user data&lt;/p&gt;
      &lt;/div&gt;
    `;
  }

  renderCompact() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card compact&quot;&gt;
        &lt;img src=&quot;${this._user.avatar}&quot; alt=&quot;${this._user.name}&quot;&gt;
        &lt;div class=&quot;info&quot;&gt;
          &lt;h3&gt;${this._user.name}&lt;/h3&gt;
          &lt;slot name=&quot;actions&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }

  renderFull() {
    return `
      &lt;style&gt;${this.styles()}&lt;/style&gt;
      &lt;div class=&quot;card&quot;&gt;
        &lt;div class=&quot;header&quot;&gt;
          &lt;img src=&quot;${this._user.avatar}&quot; alt=&quot;${this._user.name}&quot; class=&quot;avatar&quot;&gt;
          &lt;div class=&quot;header-content&quot;&gt;
            &lt;h2&gt;${this._user.name}&lt;/h2&gt;
            &lt;p class=&quot;email&quot;&gt;${this._user.email}&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;body&quot;&gt;
          &lt;p class=&quot;bio&quot;&gt;${this._user.bio || &#039;No bio available&#039;}&lt;/p&gt;
          &lt;div class=&quot;meta&quot;&gt;
            &lt;span&gt;Joined ${formatDate(this._user.createdAt)}&lt;/span&gt;
          &lt;/div&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;footer&quot;&gt;
          &lt;slot name=&quot;actions&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }

  // 10. Styles
  styles() {
    return `
      :host {
        display: block;
        cursor: pointer;
      }

      .card {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        padding: 16px;
        transition: box-shadow 0.2s;
      }

      .card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      }

      .header {
        display: flex;
        gap: 12px;
        margin-bottom: 16px;
      }

      .avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        object-fit: cover;
      }

      h2 {
        margin: 0;
        font-size: 18px;
        color: #333;
      }

      .email {
        margin: 4px 0 0 0;
        font-size: 14px;
        color: #666;
      }

      .bio {
        color: #444;
        line-height: 1.5;
      }

      .meta {
        font-size: 12px;
        color: #999;
        margin-top: 12px;
      }

      .loading, .error, .empty {
        text-align: center;
        padding: 40px 20px;
        color: #666;
      }

      .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 16px;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .error-message {
        color: #e53e3e;
      }

      .compact {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
      }

      .compact img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
      }

      .compact h3 {
        margin: 0;
        font-size: 14px;
      }
    `;
  }
}

// 11. Register the custom element
customElements.define(&#039;user-card&#039;, UserCard);

// 12. Export for use in other modules
export default UserCard;</code></pre>
<h3>Component Structure Breakdown</h3>
<strong>1. Documentation:</strong>
<ul><li>JSDoc comments explain usage</li>
<li>Attribute, property, event, and slot documentation</li>
<li>Helps other developers understand the component</li>
</ul>
<strong>2. Static Properties:</strong>
<ul><li><code>observedAttributes</code> defines which attributes trigger <code>attributeChangedCallback</code></li>
<li>Keep this list minimal for performance</li>
</ul>
<strong>3. Constructor:</strong>
<ul><li>Initialize instance variables</li>
<li>Attach shadow DOM</li>
<li>Bind methods (for event handlers)</li>
<li>Don't access attributes or DOM here</li>
</ul>
<strong>4. Lifecycle Methods:</strong>
<ul><li><code>connectedCallback</code>: Setup when added to DOM</li>
<li><code>disconnectedCallback</code>: Cleanup when removed</li>
<li><code>attributeChangedCallback</code>: Respond to attribute changes</li>
</ul>
<strong>5. Properties:</strong>
<ul><li>Use private fields (<code>_user</code>) for internal state</li>
<li>Provide getters/setters for public API</li>
<li>Setters can trigger re-renders</li>
</ul>
<strong>6. Methods:</strong>
<ul><li>Public methods for external use</li>
<li>Private methods (conventionally start with <code>_</code> or use <code>#</code> private fields)</li>
<li>Keep methods focused and single-purpose</li>
</ul>
<strong>7. Rendering:</strong>
<ul><li>Separate render logic from state management</li>
<li>Multiple render methods for different states</li>
<li>Extract styles to a separate method</li>
</ul>
<h2>Shadow DOM Deep Dive</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/02-component-structure-6.png"><strong>Figure 4.2:</strong> Slots and Content Projection</a></p>
<p>Shadow DOM is one of the most powerful features of Web Components. It provides true encapsulation for both markup and styles.</p>
<h3>Creating Shadow DOM</h3>
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  constructor() {
    super();

    // Create shadow root
    this.attachShadow({ mode: &#039;open&#039; });

    // mode: &#039;open&#039; - shadow root accessible via element.shadowRoot
    // mode: &#039;closed&#039; - shadow root not accessible (rarely used)
  }
}</code></pre>
<h3>Shadow DOM vs Light DOM</h3>
<pre><code class="language-html">&lt;my-component&gt;
  &lt;!-- This is Light DOM (regular DOM) --&gt;
  &lt;p&gt;Visible content&lt;/p&gt;
&lt;/my-component&gt;

&lt;script&gt;
  class MyComponent extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: &#039;open&#039; });

      // This is Shadow DOM
      this.shadowRoot.innerHTML = `
        &lt;div class=&quot;shadow-content&quot;&gt;
          &lt;h2&gt;Shadow DOM Content&lt;/h2&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
      `;
    }
  }

  customElements.define(&#039;my-component&#039;, MyComponent);
&lt;/script&gt;</code></pre>
<strong>Result:</strong>
<ul><li>Light DOM (<code><p>Visible content</p></code>) is projected into the <code><slot></code></li>
<li>Shadow DOM provides the structure and styling</li>
<li>Styles in shadow DOM don't leak out</li>
<li>Styles from light DOM don't leak in</li>
</ul>
<h3>Style Encapsulation</h3>
<pre><code class="language-javascript">class StyledButton extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        /* These styles only affect this component */
        button {
          background: blue;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
        }

        button:hover {
          background: darkblue;
        }
      &lt;/style&gt;
      &lt;button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;
    `;
  }
}</code></pre>
<strong>Key Points:</strong>
<ul><li>Styles inside shadow DOM are scoped</li>
<li>No conflicts with global styles</li>
<li>No CSS class name collisions</li>
<li>True component encapsulation</li>
</ul>
<h3>The :host Selector</h3>
<p>Style the component itself:</p>
<pre><code class="language-css">:host {
  display: block;
  margin: 16px 0;
}

/* Style host when it has a class */
:host(.highlighted) {
  border: 2px solid gold;
}

/* Style host when it has an attribute */
:host([disabled]) {
  opacity: 0.5;
  pointer-events: none;
}

/* Style host in specific contexts */
:host-context(.dark-theme) {
  background: #333;
  color: white;
}</code></pre>
<h3>CSS Custom Properties (Variables)</h3>
<p>CSS variables pierce the shadow DOM boundary:</p>
<pre><code class="language-javascript">// Component defines and uses variables
class ThemedCard extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          background: var(--card-bg, white);
          color: var(--card-text, black);
          border: 1px solid var(--card-border, #ddd);
          border-radius: var(--card-radius, 8px);
          padding: var(--card-padding, 16px);
        }
      &lt;/style&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;
  }
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;style&gt;
  /* Override component variables from outside */
  themed-card {
    --card-bg: #f0f0f0;
    --card-text: #333;
    --card-border: #ccc;
    --card-radius: 12px;
  }

  themed-card.dark {
    --card-bg: #333;
    --card-text: #fff;
    --card-border: #555;
  }
&lt;/style&gt;

&lt;themed-card&gt;Normal theme&lt;/themed-card&gt;
&lt;themed-card class=&quot;dark&quot;&gt;Dark theme&lt;/themed-card&gt;</code></pre>
<p>This pattern allows theming while maintaining encapsulation.</p>
<h3>Parts and ::part()</h3>
<p>Expose specific shadow DOM elements for styling:</p>
<pre><code class="language-javascript">class FancyButton extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button { /* default styles */ }
        .icon { /* icon styles */ }
      &lt;/style&gt;
      &lt;button part=&quot;button&quot;&gt;
        &lt;span part=&quot;icon&quot; class=&quot;icon&quot;&gt;→&lt;/span&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/button&gt;
    `;
  }
}</code></pre>
<strong>Style from outside:</strong>
<pre><code class="language-css">fancy-button::part(button) {
  background: linear-gradient(135deg, #667eea, #764ba2);
}

fancy-button::part(icon) {
  color: gold;
}</code></pre>
<p>This gives consumers more control while maintaining encapsulation.</p>
<h2>Attributes and Properties</h2>
<p>Understanding the difference between attributes and properties is crucial for component design.</p>
<h3>Attributes vs Properties</h3>
<strong>Attributes:</strong>
<ul><li>HTML attributes (<code><my-el foo="bar"></code>)</li>
<li>Always strings</li>
<li>Visible in HTML</li>
<li>Trigger <code>attributeChangedCallback</code></li>
</ul>
<strong>Properties:</strong>
<ul><li>JavaScript properties (<code>element.foo = 123</code>)</li>
<li>Any type (string, number, object, etc.)</li>
<li>Not visible in HTML</li>
<li>Direct access, no callback</li>
</ul>
<h3>Reflecting Properties to Attributes</h3>
<pre><code class="language-javascript">class ToggleButton extends HTMLElement {
  static get observedAttributes() {
    return [&#039;checked&#039;];
  }

  constructor() {
    super();
    this._checked = false;
  }

  // Property getter
  get checked() {
    return this._checked;
  }

  // Property setter - reflects to attribute
  set checked(value) {
    const isChecked = Boolean(value);

    if (isChecked) {
      this.setAttribute(&#039;checked&#039;, &#039;&#039;);
    } else {
      this.removeAttribute(&#039;checked&#039;);
    }
  }

  // Attribute changed - updates property
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === &#039;checked&#039;) {
      this._checked = newValue !== null;
      this.render();
    }
  }

  render() {
    this.innerHTML = `
      &lt;button class=&quot;${this._checked ? &#039;checked&#039; : &#039;&#039;}&quot;&gt;
        ${this._checked ? &#039;✓&#039; : &#039;○&#039;}
      &lt;/button&gt;
    `;
  }
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;!-- Set via attribute --&gt;
&lt;toggle-button checked&gt;&lt;/toggle-button&gt;

&lt;script&gt;
  const toggle = document.querySelector(&#039;toggle-button&#039;);

  // Set via property
  toggle.checked = true;

  // Get property
  console.log(toggle.checked); // true

  // Check attribute
  console.log(toggle.hasAttribute(&#039;checked&#039;)); // true
&lt;/script&gt;</code></pre>
<h3>When to Use Each</h3>
<strong>Use Attributes for:</strong>
<ul><li>Simple configuration (strings, numbers, booleans)</li>
<li>Values that should be visible in HTML</li>
<li>Initial configuration from HTML</li>
<li>Values that need to work with CSS selectors</li>
</ul>
<strong>Use Properties for:</strong>
<ul><li>Complex data (objects, arrays, functions)</li>
<li>Data that changes frequently</li>
<li>Large data that shouldn't serialize to HTML</li>
<li>Callback functions</li>
</ul>
<h3>Type Conversion</h3>
<p>Attributes are always strings, so convert appropriately:</p>
<pre><code class="language-javascript">attributeChangedCallback(name, oldValue, newValue) {
  if (name === &#039;count&#039;) {
    this._count = Number(newValue) || 0;
  } else if (name === &#039;enabled&#039;) {
    this._enabled = newValue !== null; // Boolean attribute
  } else if (name === &#039;options&#039;) {
    try {
      this._options = JSON.parse(newValue);
    } catch {
      this._options = {};
    }
  }
}</code></pre>
<h3>Boolean Attributes</h3>
<p>Follow HTML conventions:</p>
<pre><code class="language-javascript">// Boolean attribute: presence = true, absence = false
if (this.hasAttribute(&#039;disabled&#039;)) {
  // Is disabled
}

// Set boolean attribute
this.setAttribute(&#039;disabled&#039;, &#039;&#039;); // value doesn&#039;t matter

// Remove boolean attribute
this.removeAttribute(&#039;disabled&#039;);</code></pre>
<h2>Component Styling</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/02-component-structure-7.png"><strong>Figure 4.3:</strong> CSS Encapsulation with Shadow DOM</a></p>
<h3>Internal Styles</h3>
<p>Most styles should be in shadow DOM:</p>
<pre><code class="language-javascript">styles() {
  return `
    :host {
      display: block;
    }

    .container {
      padding: 16px;
    }

    /* All your component styles */
  `;
}</code></pre>
<h3>External Stylesheets</h3>
<p>For larger components, link external styles:</p>
<pre><code class="language-javascript">connectedCallback() {
  this.attachShadow({ mode: &#039;open&#039; });

  this.shadowRoot.innerHTML = `
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/styles/components/user-card.css&quot;&gt;
    &lt;div class=&quot;user-card&quot;&gt;
      &lt;!-- content --&gt;
    &lt;/div&gt;
  `;
}</code></pre>
<h3>Adoptable Stylesheets</h3>
<p>Share styles between component instances:</p>
<pre><code class="language-javascript">// Create shared stylesheet once
const sheet = new CSSStyleSheet();
sheet.replaceSync(`
  .card {
    padding: 16px;
    border-radius: 8px;
    background: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
`);

class CardComponent extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    // Adopt shared stylesheet (very fast)
    this.shadowRoot.adoptedStyleSheets = [sheet];

    this.shadowRoot.innerHTML = `
      &lt;div class=&quot;card&quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<strong>Benefits:</strong>
<ul><li>Styles parsed once, shared across instances</li>
<li>Better performance with many components</li>
<li>Modify shared styles dynamically</li>
</ul>
<h3>Theming Strategies</h3>
<strong>Strategy 1: CSS Custom Properties</strong>
<pre><code class="language-javascript">class ThemedComponent extends HTMLElement {
  styles() {
    return `
      :host {
        --primary-color: var(--app-primary, #667eea);
        --background: var(--app-bg, white);
        --text: var(--app-text, #333);
      }

      .content {
        background: var(--background);
        color: var(--text);
      }

      button {
        background: var(--primary-color);
      }
    `;
  }
}</code></pre>
<strong>Strategy 2: Class-Based Themes</strong>
<pre><code class="language-javascript">class ThemeAwareComponent extends HTMLElement {
  connectedCallback() {
    // Observe theme changes on documentElement
    const observer = new MutationObserver(() =&gt; {
      this.updateTheme();
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: [&#039;data-theme&#039;]
    });

    this.updateTheme();
  }

  updateTheme() {
    const theme = document.documentElement.dataset.theme || &#039;light&#039;;
    this.setAttribute(&#039;theme&#039;, theme);
  }

  styles() {
    return `
      :host([theme=&quot;light&quot;]) {
        background: white;
        color: black;
      }

      :host([theme=&quot;dark&quot;]) {
        background: #333;
        color: white;
      }
    `;
  }
}</code></pre>
<strong>Strategy 3: PAN-Based Themes</strong>
<pre><code class="language-javascript">import { pan } from &#039;@larcjs/core&#039;;

class PanThemedComponent extends HTMLElement {
  connectedCallback() {
    this.unsubscribe = pan.subscribe(&#039;app.theme.changed&#039;, ({ theme }) =&gt; {
      this.applyTheme(theme);
    });

    // Request current theme
    pan.request(&#039;app.theme.get&#039;).then(theme =&gt; {
      this.applyTheme(theme);
    });
  }

  applyTheme(theme) {
    this.setAttribute(&#039;data-theme&#039;, theme);
  }
}</code></pre>
<h2>Lifecycle Methods (Advanced Patterns)</h2>
<h3>Deferred Rendering</h3>
<p>Wait for dependencies before rendering:</p>
<pre><code class="language-javascript">class DataDisplay extends HTMLElement {
  async connectedCallback() {
    // Wait for dependencies to load
    await customElements.whenDefined(&#039;loading-spinner&#039;);
    await customElements.whenDefined(&#039;error-message&#039;);

    // Now render
    this.render();
  }
}</code></pre>
<h3>Preventing Memory Leaks</h3>
<pre><code class="language-javascript">class WebSocketComponent extends HTMLElement {
  connectedCallback() {
    this.ws = new WebSocket(&#039;wss://api.example.com&#039;);

    this.ws.onmessage = (event) =&gt; {
      this.handleMessage(event.data);
    };

    this.ws.onerror = (error) =&gt; {
      console.error(&#039;WebSocket error:&#039;, error);
    };
  }

  disconnectedCallback() {
    // Clean up WebSocket connection
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}</code></pre>
<h3>Handling Rapid Reconnection</h3>
<p>Components can be disconnected and reconnected quickly:</p>
<pre><code class="language-javascript">class RobustComponent extends HTMLElement {
  connectedCallback() {
    // Might be called multiple times
    // Use a guard to prevent duplicate setup
    if (this._initialized) {
      return;
    }

    this._initialized = true;
    this.setup();
  }

  disconnectedCallback() {
    // Use setTimeout to debounce
    this._cleanupTimer = setTimeout(() =&gt; {
      this.cleanup();
      this._initialized = false;
    }, 100);
  }

  connectedCallback() {
    // Cancel cleanup if reconnected quickly
    if (this._cleanupTimer) {
      clearTimeout(this._cleanupTimer);
      this._cleanupTimer = null;
    }

    if (this._initialized) {
      return;
    }

    this._initialized = true;
    this.setup();
  }
}</code></pre>
<h2>Testing Components</h2>
<h3>Unit Testing</h3>
<p>Test components in isolation:</p>
<pre><code class="language-javascript">// tests/user-card.test.js
import { expect } from &#039;@open-wc/testing&#039;;
import &#039;../user-card.js&#039;;

describe(&#039;UserCard&#039;, () =&gt; {
  let element;

  beforeEach(() =&gt; {
    element = document.createElement(&#039;user-card&#039;);
    document.body.appendChild(element);
  });

  afterEach(() =&gt; {
    element.remove();
  });

  it(&#039;renders empty state by default&#039;, () =&gt; {
    const emptyText = element.shadowRoot.querySelector(&#039;.empty&#039;);
    expect(emptyText).to.exist;
  });

  it(&#039;loads user when user-id attribute is set&#039;, async () =&gt; {
    // Mock fetch
    global.fetch = async () =&gt; ({
      ok: true,
      json: async () =&gt; ({ id: 1, name: &#039;John Doe&#039;, email: &#039;john@example.com&#039; })
    });

    element.setAttribute(&#039;user-id&#039;, &#039;1&#039;);

    // Wait for async operations
    await new Promise(resolve =&gt; setTimeout(resolve, 100));

    const name = element.shadowRoot.querySelector(&#039;h2&#039;);
    expect(name.textContent).to.equal(&#039;John Doe&#039;);
  });

  it(&#039;handles loading state&#039;, async () =&gt; {
    element.setAttribute(&#039;user-id&#039;, &#039;1&#039;);

    const spinner = element.shadowRoot.querySelector(&#039;.spinner&#039;);
    expect(spinner).to.exist;
  });

  it(&#039;dispatches user-selected event on click&#039;, async () =&gt; {
    element._user = { id: 1, name: &#039;John&#039; };
    element.render();

    let eventData = null;
    element.addEventListener(&#039;user-selected&#039;, (e) =&gt; {
      eventData = e.detail;
    });

    element.shadowRoot.querySelector(&#039;.card&#039;).click();

    expect(eventData).to.deep.equal({ user: { id: 1, name: &#039;John&#039; } });
  });
});</code></pre>
<h3>Integration Testing</h3>
<p>Test components working together:</p>
<pre><code class="language-javascript">// tests/counter-integration.test.js
describe(&#039;Counter Integration&#039;, () =&gt; {
  beforeEach(() =&gt; {
    document.body.innerHTML = `
      &lt;counter-display&gt;&lt;/counter-display&gt;
      &lt;counter-controls&gt;&lt;/counter-controls&gt;
    `;
  });

  it(&#039;updates display when controls are clicked&#039;, async () =&gt; {
    const display = document.querySelector(&#039;counter-display&#039;);
    const controls = document.querySelector(&#039;counter-controls&#039;);

    const incrementBtn = controls.shadowRoot.querySelector(&#039;#increment&#039;);
    incrementBtn.click();

    await new Promise(resolve =&gt; setTimeout(resolve, 50));

    const displayValue = display.shadowRoot.querySelector(&#039;.display&#039;).textContent;
    expect(displayValue).to.equal(&#039;1&#039;);
  });
});</code></pre>
<h3>Visual Regression Testing</h3>
<p>Catch visual bugs:</p>
<pre><code class="language-javascript">// tests/visual.test.js
import puppeteer from &#039;puppeteer&#039;;
import pixelmatch from &#039;pixelmatch&#039;;

describe(&#039;Visual Regression&#039;, () =&gt; {
  let browser, page;

  beforeAll(async () =&gt; {
    browser = await puppeteer.launch();
    page = await browser.newPage();
  });

  afterAll(async () =&gt; {
    await browser.close();
  });

  it(&#039;user-card matches snapshot&#039;, async () =&gt; {
    await page.goto(&#039;http://localhost:3000/tests/user-card.html&#039;);

    const screenshot = await page.screenshot({ fullPage: true });
    const baseline = fs.readFileSync(&#039;tests/snapshots/user-card.png&#039;);

    const diff = pixelmatch(screenshot, baseline, null, 800, 600, {
      threshold: 0.1
    });

    expect(diff).to.be.lessThan(100); // Allow small differences
  });
});</code></pre>
<h2>Summary</h2>
<p>This chapter covered:</p>
<ul><li><strong>Component Anatomy</strong>: Structure, lifecycle, and organization</li>
<li><strong>Shadow DOM</strong>: Encapsulation, slots, and styling</li>
<li><strong>Attributes vs Properties</strong>: When to use each and how to reflect them</li>
<li><strong>Component Styling</strong>: Internal styles, theming, and CSS custom properties</li>
<li><strong>Lifecycle Patterns</strong>: Memory management and robust connection handling</li>
<li><strong>Testing</strong>: Unit, integration, and visual regression testing</li>
</ul>
You now know how to build production-quality Web Components. The next chapter explores the PAN bus in depth, showing you how to orchestrate component communication at scale.
<hr>
<h2>Best Practices</h2>
<li><strong>Always clean up in <code>disconnectedCallback</code></strong></li>
   - Remove event listeners
   - Cancel pending operations
   - Unsubscribe from events
<li><strong>Use Shadow DOM for encapsulation</strong></li>
   - Keep styles scoped
   - Avoid global style pollution
   - Use <code>:host</code> and CSS custom properties for theming
<li><strong>Reflect important properties to attributes</strong></li>
   - Makes state visible in HTML
   - Enables CSS selectors
   - Improves debugging
<li><strong>Keep components focused</strong></li>
   - Single responsibility principle
   - Compose larger components from smaller ones
   - Extract shared logic to utilities
<li><strong>Test early and often</strong></li>
   - Write tests as you build components
   - Test both happy paths and error cases
   - Use integration tests for component interaction
<hr>
<h2>Further Reading</h2>
<strong>For complete Web Components reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 2: Core Concepts - Web Components architecture and lifecycle</li>
<li><em>Building with LARC</em> Chapters 17-21: Component Reference - Complete API documentation</li>
<li><em>Building with LARC</em> Chapter 13: Testing Strategies - Component testing patterns</li>
</ul>
<div class="pagebreak"></div>
<h1>The PAN Bus</h1>
<p>The Page Area Network (PAN) bus is LARC's event-driven communication backbone. It enables decoupled, scalable component architectures by providing a pub/sub messaging system that works across your entire application.</p>
<p>In this chapter, you'll master the PAN bus: from basic publish/subscribe patterns to advanced message routing, error handling, and debugging techniques. By the end, you'll be able to build complex applications where components communicate seamlessly without tight coupling.</p>
<h2>Understanding Pub/Sub Architecture</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/05-pan-bus-1.png"><strong>Figure 5.1:</strong> PAN Bus Pub/Sub Architecture</a></p>
<p>Publish/Subscribe (pub/sub) is a messaging pattern where senders (publishers) don't directly target specific receivers (subscribers). Instead, messages are sent to topics, and any component interested in those topics receives them.</p>
<h3>Traditional Communication</h3>
<p>Without pub/sub, components need direct references:</p>
<pre><code class="language-javascript">// ❌ Tight coupling
class LoginButton {
  handleLogin() {
    const user = this.authenticate();

    // Direct reference to other components
    document.querySelector(&#039;user-menu&#039;).updateUser(user);
    document.querySelector(&#039;sidebar&#039;).showUserPanel();
    document.querySelector(&#039;notification&#039;).show(&#039;Welcome!&#039;);
  }
}</code></pre>
<strong>Problems:</strong>
<ul><li>LoginButton must know about all dependent components</li>
<li>Adding new components requires modifying LoginButton</li>
<li>Components can't work independently</li>
<li>Testing requires mocking all dependencies</li>
</ul>
<h3>Pub/Sub Communication</h3>
<p>With the PAN bus:</p>
<pre><code class="language-javascript">// ✓ Loose coupling
class LoginButton {
  handleLogin() {
    const user = this.authenticate();

    // Publish event - don&#039;t care who listens
    pan.publish(&#039;user.logged-in&#039;, { user });
  }
}

// Separate components subscribe independently
class UserMenu {
  connectedCallback() {
    pan.subscribe(&#039;user.logged-in&#039;, ({ user }) =&gt; {
      this.updateUser(user);
    });
  }
}

class Sidebar {
  connectedCallback() {
    pan.subscribe(&#039;user.logged-in&#039;, () =&gt; {
      this.showUserPanel();
    });
  }
}

class Notification {
  connectedCallback() {
    pan.subscribe(&#039;user.logged-in&#039;, () =&gt; {
      this.show(&#039;Welcome!&#039;);
    });
  }
}</code></pre>
<strong>Benefits:</strong>
<ul><li>LoginButton doesn't know about consumers</li>
<li>Add new subscribers without changing publishers</li>
<li>Components work independently</li>
<li>Easy to test in isolation</li>
</ul>
<h3>The PAN Bus API</h3>
<p>The PAN bus provides three core operations:</p>
<pre><code class="language-javascript">import { pan } from &#039;@larcjs/core&#039;;

// 1. Publish - send a message to a topic
pan.publish(&#039;topic.name&#039;, { data: &#039;value&#039; });

// 2. Subscribe - listen for messages on a topic
const unsubscribe = pan.subscribe(&#039;topic.name&#039;, (data) =&gt; {
  console.log(&#039;Received:&#039;, data);
});

// 3. Unsubscribe - stop listening
unsubscribe();</code></pre>
<p>That's the foundation. Everything else builds on these three operations.</p>
<h2>Topics and Namespaces</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/05-pan-bus-3.png"><strong>Figure 5.2:</strong> Topic Namespace Structure</a></p>
<p>Topics are the routing keys for messages. Well-designed topics make your application's data flow clear and maintainable.</p>
<h3>Topic Naming Conventions</h3>
<p>Use dot notation to create hierarchies:</p>
<pre><code class="language-plaintext">domain.entity.action</code></pre>
<strong>Examples:</strong>
<pre><code class="language-plaintext">user.profile.updated
user.auth.login
user.auth.logout
user.settings.changed

cart.item.added
cart.item.removed
cart.total.calculated
cart.checkout.started
cart.checkout.completed

notification.info.show
notification.warning.show
notification.error.show

app.theme.changed
app.language.changed
app.route.changed</code></pre>
<h3>Namespace Structure</h3>
<p>Organize topics by domain:</p>
<strong>User Domain:</strong>
<pre><code class="language-plaintext">user.auth.login
user.auth.logout
user.auth.refresh
user.profile.fetch
user.profile.update
user.settings.fetch
user.settings.update</code></pre>
<strong>Shopping Cart Domain:</strong>
<pre><code class="language-plaintext">cart.init
cart.item.add
cart.item.remove
cart.item.update
cart.clear
cart.checkout</code></pre>
<strong>Application Domain:</strong>
<pre><code class="language-plaintext">app.ready
app.error
app.navigate
app.theme.change
app.modal.open
app.modal.close</code></pre>
<h3>Wildcards</h3>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/05-pan-bus-4.png"><strong>Figure 5.3:</strong> Wildcard Subscription Matching</a></p>
<p>Subscribe to multiple topics using wildcards:</p>
<pre><code class="language-javascript">// Subscribe to all user events
pan.subscribe(&#039;user.*&#039;, (data) =&gt; {
  console.log(&#039;User event:&#039;, data);
});

// Subscribe to all auth events across domains
pan.subscribe(&#039;*.auth.*&#039;, (data) =&gt; {
  console.log(&#039;Auth event:&#039;, data);
});

// Subscribe to ALL events (debugging)
pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
  console.log(`[${topic}]`, data);
});</code></pre>
<strong>Wildcard Patterns:</strong>
<ul><li><code>user.*</code> - All user events (user.login, user.logout, etc.)</li>
<li><code>*.created</code> - All create events (user.created, post.created, etc.)</li>
<li><code>user.*.updated</code> - All user update events (user.profile.updated, user.settings.updated, etc.)</li>
<li><code>*</code> - All events</li>
</ul>
<h3>Topic Best Practices</h3>
<strong>1. Be Specific:</strong>
<pre><code class="language-javascript">// ✓ Good - clear intent
pan.publish(&#039;cart.item.added&#039;, { item, quantity });

// ❌ Bad - vague
pan.publish(&#039;cart.update&#039;, { type: &#039;add&#039;, item, quantity });</code></pre>
<strong>2. Use Consistent Tense:</strong>
<pre><code class="language-javascript">// ✓ Good - past tense for events that happened
pan.publish(&#039;user.logged-in&#039;, { user });
pan.publish(&#039;data.loaded&#039;, { data });

// ❌ Bad - mixed tense
pan.publish(&#039;user.login&#039;, { user });  // Is this a command or event?</code></pre>
<strong>3. Include Context:</strong>
<pre><code class="language-javascript">// ✓ Good - data includes context
pan.publish(&#039;task.completed&#039;, {
  taskId: 123,
  userId: 456,
  completedAt: new Date()
});

// ❌ Bad - missing context
pan.publish(&#039;task.done&#039;, { id: 123 });</code></pre>
<strong>4. Avoid Over-Nesting:</strong>
<pre><code class="language-javascript">// ✓ Good - clear and concise
pan.publish(&#039;user.profile.updated&#039;, { user });

// ❌ Bad - too nested
pan.publish(&#039;app.domain.user.entity.profile.action.updated&#039;, { user });</code></pre>
<h2>Publishing Messages</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/05-pan-bus-2.png"><strong>Figure 5.4:</strong> Message Flow Sequence</a></p>
<p>Publishing is straightforward, but there are patterns and options to understand.</p>
<h3>Basic Publishing</h3>
<pre><code class="language-javascript">pan.publish(&#039;event.name&#039;, { any: &#039;data&#039; });</code></pre>
<p>The data can be anything JSON-serializable:</p>
<pre><code class="language-javascript">// Simple value
pan.publish(&#039;counter.updated&#039;, 42);

// Object
pan.publish(&#039;user.logged-in&#039;, {
  userId: 123,
  username: &#039;john&#039;,
  email: &#039;john@example.com&#039;
});

// Array
pan.publish(&#039;items.loaded&#039;, [
  { id: 1, name: &#039;Item 1&#039; },
  { id: 2, name: &#039;Item 2&#039; }
]);

// Null/undefined
pan.publish(&#039;data.cleared&#039;, null);</code></pre>
<h3>Publishing from Components</h3>
<p>Publish in response to user actions or state changes:</p>
<pre><code class="language-javascript">class AddToCartButton extends HTMLElement {
  connectedCallback() {
    this.addEventListener(&#039;click&#039;, this.handleClick);
  }

  async handleClick() {
    const productId = this.getAttribute(&#039;product-id&#039;);
    const quantity = parseInt(this.getAttribute(&#039;quantity&#039;) || 1);

    // Publish intent
    pan.publish(&#039;cart.item.add-requested&#039;, { productId, quantity });

    try {
      // Perform action
      await this.addToCart(productId, quantity);

      // Publish success
      pan.publish(&#039;cart.item.added&#039;, {
        productId,
        quantity,
        timestamp: Date.now()
      });
    } catch (error) {
      // Publish failure
      pan.publish(&#039;cart.item.add-failed&#039;, {
        productId,
        quantity,
        error: error.message
      });
    }
  }

  async addToCart(productId, quantity) {
    const response = await fetch(&#039;/api/cart/items&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify({ productId, quantity })
    });

    if (!response.ok) {
      throw new Error(&#039;Failed to add item to cart&#039;);
    }

    return response.json();
  }
}</code></pre>
<h3>Event Metadata</h3>
<p>Include metadata for debugging and auditing:</p>
<pre><code class="language-javascript">function publishWithMetadata(topic, data) {
  pan.publish(topic, {
    ...data,
    _meta: {
      timestamp: Date.now(),
      source: &#039;UserComponent&#039;,
      userId: currentUser?.id,
      sessionId: sessionId
    }
  });
}

// Usage
publishWithMetadata(&#039;order.placed&#039;, {
  orderId: 12345,
  total: 99.99
});</code></pre>
<h3>Batch Publishing</h3>
<p>Publish multiple events efficiently:</p>
<pre><code class="language-javascript">function syncLocalChanges(changes) {
  changes.forEach(change =&gt; {
    switch (change.type) {
      case &#039;add&#039;:
        pan.publish(&#039;data.item.added&#039;, change.item);
        break;
      case &#039;update&#039;:
        pan.publish(&#039;data.item.updated&#039;, change.item);
        break;
      case &#039;delete&#039;:
        pan.publish(&#039;data.item.deleted&#039;, { id: change.id });
        break;
    }
  });

  // Publish batch complete
  pan.publish(&#039;data.sync.completed&#039;, {
    changesCount: changes.length,
    timestamp: Date.now()
  });
}</code></pre>
<h2>Subscribing to Events</h2>
<p>Subscriptions are how components react to events they care about.</p>
<h3>Basic Subscription</h3>
<pre><code class="language-javascript">const unsubscribe = pan.subscribe(&#039;event.name&#039;, (data) =&gt; {
  console.log(&#039;Received:&#039;, data);
});

// Later, when done
unsubscribe();</code></pre>
<h3>Component Lifecycle Integration</h3>
<p>Subscribe in <code>connectedCallback</code>, unsubscribe in <code>disconnectedCallback</code>:</p>
<pre><code class="language-javascript">class NotificationDisplay extends HTMLElement {
  connectedCallback() {
    // Subscribe to notification events
    this.unsubscribeInfo = pan.subscribe(&#039;notification.info&#039;, this.showInfo);
    this.unsubscribeWarning = pan.subscribe(&#039;notification.warning&#039;, this.showWarning);
    this.unsubscribeError = pan.subscribe(&#039;notification.error&#039;, this.showError);
  }

  disconnectedCallback() {
    // Clean up subscriptions
    this.unsubscribeInfo();
    this.unsubscribeWarning();
    this.unsubscribeError();
  }

  showInfo = (data) =&gt; {
    this.showNotification(&#039;info&#039;, data.message);
  }

  showWarning = (data) =&gt; {
    this.showNotification(&#039;warning&#039;, data.message);
  }

  showError = (data) =&gt; {
    this.showNotification(&#039;error&#039;, data.message);
  }

  showNotification(type, message) {
    // Render notification UI
  }
}</code></pre>
<h3>Multiple Subscriptions Helper</h3>
<p>Manage multiple subscriptions easily:</p>
<pre><code class="language-javascript">class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }

  subscribe(topic, handler) {
    const unsubscribe = pan.subscribe(topic, handler);
    this.subscriptions.push(unsubscribe);
    return unsubscribe;
  }

  unsubscribeAll() {
    this.subscriptions.forEach(unsubscribe =&gt; unsubscribe());
    this.subscriptions = [];
  }
}

// Usage in component
class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.subs = new SubscriptionManager();
  }

  connectedCallback() {
    this.subs.subscribe(&#039;user.login&#039;, this.handleLogin);
    this.subs.subscribe(&#039;user.logout&#039;, this.handleLogout);
    this.subs.subscribe(&#039;app.theme.changed&#039;, this.handleThemeChange);
  }

  disconnectedCallback() {
    this.subs.unsubscribeAll();
  }

  handleLogin = (data) =&gt; { /* ... */ }
  handleLogout = (data) =&gt; { /* ... */ }
  handleThemeChange = (data) =&gt; { /* ... */ }
}</code></pre>
<h3>Conditional Subscriptions</h3>
<p>Subscribe only when conditions are met:</p>
<pre><code class="language-javascript">class UserDashboard extends HTMLElement {
  connectedCallback() {
    // Subscribe to user-specific events only when user is logged in
    this.unsubscribeAuth = pan.subscribe(&#039;auth.state.changed&#039;, ({ isAuthenticated, user }) =&gt; {
      if (isAuthenticated) {
        this.subscribeToUserEvents(user.id);
      } else {
        this.unsubscribeFromUserEvents();
      }
    });
  }

  subscribeToUserEvents(userId) {
    this.unsubscribeUserActivity = pan.subscribe(&#039;user.activity&#039;, (data) =&gt; {
      if (data.userId === userId) {
        this.updateActivity(data);
      }
    });

    this.unsubscribeUserNotifications = pan.subscribe(&#039;user.notifications&#039;, (data) =&gt; {
      if (data.userId === userId) {
        this.showNotification(data);
      }
    });
  }

  unsubscribeFromUserEvents() {
    if (this.unsubscribeUserActivity) {
      this.unsubscribeUserActivity();
      this.unsubscribeUserActivity = null;
    }

    if (this.unsubscribeUserNotifications) {
      this.unsubscribeUserNotifications();
      this.unsubscribeUserNotifications = null;
    }
  }
}</code></pre>
<h3>Filtering Events</h3>
<p>Filter events in the subscriber:</p>
<pre><code class="language-javascript">pan.subscribe(&#039;task.updated&#039;, (task) =&gt; {
  // Only handle tasks assigned to current user
  if (task.assignedTo === currentUser.id) {
    this.updateTaskDisplay(task);
  }
});

pan.subscribe(&#039;notification.*&#039;, (notification) =&gt; {
  // Only show high-priority notifications
  if (notification.priority &gt;= 3) {
    this.showNotification(notification);
  }
});</code></pre>
<h2>Message Patterns</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/05-pan-bus-6.png"><strong>Figure 5.5:</strong> Event Pattern Comparison</a></p>
<p>The PAN bus supports several messaging patterns for different use cases.</p>
<h3>1. Fire and Forget</h3>
<p>Most common pattern. Publish and continue without waiting:</p>
<pre><code class="language-javascript">// Publisher
function saveSettings(settings) {
  localStorage.setItem(&#039;settings&#039;, JSON.stringify(settings));
  pan.publish(&#039;settings.saved&#039;, settings);
}

// Subscriber
pan.subscribe(&#039;settings.saved&#039;, (settings) =&gt; {
  console.log(&#039;Settings updated:&#039;, settings);
  updateUI(settings);
});</code></pre>
<strong>Use when:</strong>
<ul><li>Multiple components may react</li>
<li>You don't need confirmation</li>
<li>Action is non-critical</li>
</ul>
<h3>2. Request/Response</h3>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/05-pan-bus-5.png"><strong>Figure 5.6:</strong> Request/Response Pattern</a></p>
<p>Request data and wait for a response:</p>
<pre><code class="language-javascript">// Responder
pan.respond(&#039;auth.token.get&#039;, async () =&gt; {
  return localStorage.getItem(&#039;authToken&#039;);
});

// Requester
const token = await pan.request(&#039;auth.token.get&#039;);
console.log(&#039;Token:&#039;, token);</code></pre>
<strong>Implementation:</strong>
<pre><code class="language-javascript">// In PAN library
class PAN {
  request(topic, data, timeout = 5000) {
    return new Promise((resolve, reject) =&gt; {
      const responseId = `${topic}:${Date.now()}:${Math.random()}`;

      // Subscribe to response
      const unsubscribe = this.subscribe(`${topic}:response:${responseId}`, (response) =&gt; {
        unsubscribe();
        clearTimeout(timer);
        resolve(response);
      });

      // Set timeout
      const timer = setTimeout(() =&gt; {
        unsubscribe();
        reject(new Error(`Request timeout: ${topic}`));
      }, timeout);

      // Publish request
      this.publish(`${topic}:request`, {
        ...data,
        _responseId: responseId
      });
    });
  }

  respond(topic, handler) {
    return this.subscribe(`${topic}:request`, async (data) =&gt; {
      try {
        const result = await handler(data);
        this.publish(`${topic}:response:${data._responseId}`, result);
      } catch (error) {
        this.publish(`${topic}:response:${data._responseId}`, {
          error: error.message
        });
      }
    });
  }
}</code></pre>
<strong>Use when:</strong>
<ul><li>Need data from another component</li>
<li>Waiting for response is acceptable</li>
<li>Asynchronous operations</li>
</ul>
<h3>3. Command Pattern</h3>
<p>Issue commands that components execute:</p>
<pre><code class="language-javascript">// Command issuer
pan.publish(&#039;modal.open&#039;, {
  component: &#039;user-profile&#039;,
  props: { userId: 123 }
});

// Command handler
pan.subscribe(&#039;modal.open&#039;, ({ component, props }) =&gt; {
  const modal = document.createElement(&#039;app-modal&#039;);
  modal.component = component;
  modal.props = props;
  document.body.appendChild(modal);
});</code></pre>
<strong>Use when:</strong>
<ul><li>Triggering actions in other components</li>
<li>Implementing undo/redo</li>
<li>Building command palette UIs</li>
</ul>
<h3>4. Event Sourcing</h3>
<p>Store events for replay or auditing:</p>
<pre><code class="language-javascript">const eventStore = [];

// Store all events
pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
  eventStore.push({
    topic,
    data,
    timestamp: Date.now()
  });
});

// Replay events
function replayEvents(fromTimestamp) {
  eventStore
    .filter(event =&gt; event.timestamp &gt;= fromTimestamp)
    .forEach(event =&gt; {
      pan.publish(event.topic, event.data);
    });
}

// Get events for debugging
function getEventHistory(topic) {
  return eventStore.filter(event =&gt;
    event.topic === topic || event.topic.startsWith(topic + &#039;.&#039;)
  );
}</code></pre>
<strong>Use when:</strong>
<ul><li>Debugging complex interactions</li>
<li>Implementing undo/redo</li>
<li>Auditing user actions</li>
<li>Syncing state across sessions</li>
</ul>
<h3>5. Aggregation Pattern</h3>
<p>Collect multiple events before acting:</p>
<pre><code class="language-javascript">class DataAggregator extends HTMLElement {
  constructor() {
    super();
    this.pendingUpdates = new Set();
    this.debounceTimer = null;
  }

  connectedCallback() {
    pan.subscribe(&#039;data.item.updated&#039;, ({ id }) =&gt; {
      this.pendingUpdates.add(id);
      this.scheduleRefresh();
    });
  }

  scheduleRefresh() {
    clearTimeout(this.debounceTimer);

    this.debounceTimer = setTimeout(() =&gt; {
      this.refreshItems(Array.from(this.pendingUpdates));
      this.pendingUpdates.clear();
    }, 500);
  }

  async refreshItems(ids) {
    const items = await fetchItems(ids);
    this.render(items);
  }
}</code></pre>
<strong>Use when:</strong>
<ul><li>Avoiding excessive updates</li>
<li>Batching API requests</li>
<li>Debouncing rapid events</li>
</ul>
<h3>6. Saga Pattern</h3>
<p>Coordinate multi-step processes:</p>
<pre><code class="language-javascript">class CheckoutSaga {
  constructor() {
    this.setupListeners();
  }

  setupListeners() {
    pan.subscribe(&#039;checkout.started&#039;, this.handleCheckoutStart);
    pan.subscribe(&#039;payment.completed&#039;, this.handlePaymentComplete);
    pan.subscribe(&#039;order.created&#039;, this.handleOrderCreated);
  }

  handleCheckoutStart = async ({ cart }) =&gt; {
    try {
      // Step 1: Validate cart
      pan.publish(&#039;checkout.validating&#039;, { cart });
      await this.validateCart(cart);

      // Step 2: Calculate totals
      pan.publish(&#039;checkout.calculating&#039;, { cart });
      const totals = await this.calculateTotals(cart);

      // Step 3: Request payment
      pan.publish(&#039;payment.requested&#039;, { totals });
    } catch (error) {
      pan.publish(&#039;checkout.failed&#039;, { error: error.message });
    }
  }

  handlePaymentComplete = async ({ paymentId, totals }) =&gt; {
    try {
      // Step 4: Create order
      pan.publish(&#039;order.creating&#039;, { paymentId });
      const order = await this.createOrder(paymentId, totals);

      pan.publish(&#039;order.created&#039;, { order });
    } catch (error) {
      // Compensating transaction: refund payment
      pan.publish(&#039;payment.refund-requested&#039;, { paymentId });
      pan.publish(&#039;checkout.failed&#039;, { error: error.message });
    }
  }

  handleOrderCreated = async ({ order }) =&gt; {
    // Step 5: Send confirmation
    pan.publish(&#039;order.confirmation-sending&#039;, { order });
    await this.sendConfirmation(order);

    // Step 6: Complete checkout
    pan.publish(&#039;checkout.completed&#039;, { order });
  }
}</code></pre>
<strong>Use when:</strong>
<ul><li>Complex multi-step workflows</li>
<li>Need to handle failures and rollbacks</li>
<li>Coordinating multiple services</li>
</ul>
<h2>Debugging PAN Communication</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/05-pan-bus-10.png"><strong>Figure 5.7:</strong> PAN Bus Internal Architecture</a></p>
<p>Debugging event-driven systems requires different techniques than traditional debugging.</p>
<h3>Logging All Events</h3>
<pre><code class="language-javascript">// Enable debug mode
pan.debug(true);

// Or manually subscribe to all events
pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
  console.group(`[PAN] ${topic}`);
  console.log(&#039;Data:&#039;, data);
  console.log(&#039;Timestamp:&#039;, new Date().toISOString());
  console.trace(&#039;Stack trace&#039;);
  console.groupEnd();
});</code></pre>
<h3>Event Inspector</h3>
<p>Build a visual event inspector:</p>
<pre><code class="language-javascript">class PanInspector extends HTMLElement {
  constructor() {
    super();
    this.events = [];
    this.maxEvents = 100;
  }

  connectedCallback() {
    this.render();

    pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
      this.logEvent(topic, data);
    });
  }

  logEvent(topic, data) {
    this.events.unshift({
      topic,
      data,
      timestamp: Date.now()
    });

    if (this.events.length &gt; this.maxEvents) {
      this.events.pop();
    }

    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;style&gt;
        .pan-inspector {
          position: fixed;
          bottom: 0;
          right: 0;
          width: 400px;
          height: 300px;
          background: white;
          border: 1px solid #ccc;
          overflow: auto;
          font-family: monospace;
          font-size: 12px;
        }

        .event {
          padding: 8px;
          border-bottom: 1px solid #eee;
        }

        .event:hover {
          background: #f5f5f5;
        }

        .topic {
          font-weight: bold;
          color: #667eea;
        }

        .timestamp {
          color: #999;
          font-size: 10px;
        }

        .data {
          margin-top: 4px;
          color: #333;
        }
      &lt;/style&gt;

      &lt;div class=&quot;pan-inspector&quot;&gt;
        &lt;h3&gt;PAN Event Inspector&lt;/h3&gt;
        ${this.events.map(event =&gt; `
          &lt;div class=&quot;event&quot;&gt;
            &lt;div class=&quot;topic&quot;&gt;${event.topic}&lt;/div&gt;
            &lt;div class=&quot;timestamp&quot;&gt;${new Date(event.timestamp).toLocaleTimeString()}&lt;/div&gt;
            &lt;div class=&quot;data&quot;&gt;${JSON.stringify(event.data, null, 2)}&lt;/div&gt;
          &lt;/div&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;pan-inspector&#039;, PanInspector);</code></pre>
<h3>Event Filtering</h3>
<p>Filter events for specific topics:</p>
<pre><code class="language-javascript">function filterEvents(pattern) {
  const regex = new RegExp(pattern.replace(&#039;*&#039;, &#039;.*&#039;));

  pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
    if (regex.test(topic)) {
      console.log(`[FILTERED] ${topic}:`, data);
    }
  });
}

// Usage
filterEvents(&#039;user.*&#039;);     // Only user events
filterEvents(&#039;*.error&#039;);    // All error events
filterEvents(&#039;cart|order&#039;); // Cart or order events</code></pre>
<h3>Performance Monitoring</h3>
<p>Track event frequency and performance:</p>
<pre><code class="language-javascript">class PanMonitor {
  constructor() {
    this.stats = new Map();

    pan.subscribe(&#039;*&#039;, (topic) =&gt; {
      const stat = this.stats.get(topic) || { count: 0, timestamps: [] };

      stat.count++;
      stat.timestamps.push(Date.now());

      // Keep only last 100 timestamps
      if (stat.timestamps.length &gt; 100) {
        stat.timestamps.shift();
      }

      this.stats.set(topic, stat);
    });
  }

  getStats(topic) {
    const stat = this.stats.get(topic);
    if (!stat) return null;

    const timestamps = stat.timestamps;
    const duration = timestamps[timestamps.length - 1] - timestamps[0];
    const frequency = timestamps.length / (duration / 1000);

    return {
      topic,
      count: stat.count,
      frequency: frequency.toFixed(2) + &#039; events/sec&#039;,
      lastEvent: new Date(timestamps[timestamps.length - 1])
    };
  }

  getAllStats() {
    const results = [];

    this.stats.forEach((_, topic) =&gt; {
      results.push(this.getStats(topic));
    });

    return results.sort((a, b) =&gt; b.count - a.count);
  }

  reset() {
    this.stats.clear();
  }
}

// Usage
const monitor = new PanMonitor();

// Later, check stats
console.table(monitor.getAllStats());</code></pre>
<h3>Event Replay</h3>
<p>Capture and replay events for testing:</p>
<pre><code class="language-javascript">class EventRecorder {
  constructor() {
    this.recording = false;
    this.events = [];
  }

  start() {
    this.recording = true;
    this.events = [];

    this.unsubscribe = pan.subscribe(&#039;*&#039;, (topic, data) =&gt; {
      if (this.recording) {
        this.events.push({ topic, data, timestamp: Date.now() });
      }
    });
  }

  stop() {
    this.recording = false;
    if (this.unsubscribe) {
      this.unsubscribe();
    }

    return this.events;
  }

  replay(events, speed = 1) {
    if (!events || events.length === 0) return;

    const startTime = events[0].timestamp;

    events.forEach((event, index) =&gt; {
      const delay = (event.timestamp - startTime) / speed;

      setTimeout(() =&gt; {
        pan.publish(event.topic, event.data);
      }, delay);
    });
  }

  save(name) {
    localStorage.setItem(`pan-recording-${name}`, JSON.stringify(this.events));
  }

  load(name) {
    const data = localStorage.getItem(`pan-recording-${name}`);
    return data ? JSON.parse(data) : null;
  }
}

// Usage
const recorder = new EventRecorder();

// Start recording
recorder.start();

// ... perform actions ...

// Stop and save
const events = recorder.stop();
recorder.save(&#039;my-test-scenario&#039;);

// Later, replay
const events = recorder.load(&#039;my-test-scenario&#039;);
recorder.replay(events, 2); // 2x speed</code></pre>
<h2>Summary</h2>
<p>This chapter covered:</p>
<ul><li><strong>Pub/Sub Architecture</strong>: Decoupled communication via topics</li>
<li><strong>Topics and Namespaces</strong>: Organizing events with hierarchical naming</li>
<li><strong>Publishing</strong>: Sending messages and event patterns</li>
<li><strong>Subscribing</strong>: Receiving and filtering events</li>
<li><strong>Message Patterns</strong>: Fire-and-forget, request/response, commands, sagas</li>
<li><strong>Debugging</strong>: Logging, inspection, monitoring, and replay tools</li>
</ul>
The PAN bus is central to LARC applications. Mastering it enables you to build scalable, maintainable applications where components collaborate without tight coupling.
<hr>
<h2>Best Practices</h2>
<li><strong>Use descriptive topic names</strong></li>
   - <code>user.profile.updated</code> not <code>userUpdated</code>
   - Past tense for events that happened
   - Include context in message data
<li><strong>Clean up subscriptions</strong></li>
   - Always unsubscribe in <code>disconnectedCallback</code>
   - Use subscription managers for multiple subscriptions
   - Avoid memory leaks
<li><strong>Avoid infinite loops</strong></li>
   - Don't publish the same event you're subscribed to
   - Use different topics for input and output
   - Add loop detection in debug mode
<li><strong>Keep handlers fast</strong></li>
   - Don't block the event loop
   - Use async/await for long operations
   - Consider debouncing rapid events
<li><strong>Include metadata</strong></li>
   - Timestamp, source, user ID for debugging
   - Request IDs for tracing
   - Error details for failures
<li><strong>Test event flows</strong></li>
   - Use event recorders for integration tests
   - Mock pan.publish/subscribe in unit tests
   - Verify event contracts between components
<hr>
<h2>Further Reading</h2>
<strong>For complete PAN bus API reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 2: Core Concepts - Message bus architecture deep dive</li>
<li><em>Building with LARC</em> Appendix A: Message Topics Reference - Standard topic conventions</li>
<li><em>Building with LARC</em> Appendix B: Event Envelope Specification - Message format details</li>
</ul>
<div class="pagebreak"></div>
<h1>State Management</h1>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/06-state-management-3.png"><strong>Figure 6.1:</strong> State Management Hierarchy</a></p>
<p>State management is one of the most critical aspects of application development. Poor state management leads to bugs, performance issues, and maintenance nightmares. Good state management makes applications predictable, testable, and maintainable.</p>
<p>LARC takes a pragmatic approach: start simple and scale complexity only when needed. This chapter explores state management at every level, from component-local state to distributed, offline-first architectures.</p>
<h2>Component-Local State</h2>
<p>The simplest form of state lives entirely within a single component. This is your first choice for most scenarios.</p>
<h3>Instance Properties</h3>
<p>Use instance properties for component-specific state:</p>
<pre><code class="language-javascript">class ToggleSwitch extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });

    // Local state
    this.isOn = false;
  }

  connectedCallback() {
    this.render();

    this.shadowRoot.querySelector(&#039;button&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.isOn = !this.isOn;  // Update state
      this.render();            // Re-render

      // Notify others
      this.dispatchEvent(new CustomEvent(&#039;toggle&#039;, {
        detail: { isOn: this.isOn }
      }));
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button {
          background: ${this.isOn ? &#039;#48bb78&#039; : &#039;#cbd5e0&#039;};
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
        }
      &lt;/style&gt;
      &lt;button&gt;${this.isOn ? &#039;ON&#039; : &#039;OFF&#039;}&lt;/button&gt;
    `;
  }
}</code></pre>
<strong>When to use:</strong>
<ul><li>UI state (expanded/collapsed, selected, etc.)</li>
<li>Temporary values (search input, form drafts)</li>
<li>Component-specific configuration</li>
</ul>
<strong>Advantages:</strong>
<ul><li>Simple and straightforward</li>
<li>No dependencies on external state</li>
<li>Easy to reason about</li>
<li>Easy to test</li>
</ul>
<h3>Private Fields</h3>
<p>Use private fields (with <code>#</code>) for true encapsulation:</p>
<pre><code class="language-javascript">class Counter extends HTMLElement {
  // Private fields
  #count = 0;
  #max = 100;
  #min = 0;

  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  // Public getter
  get count() {
    return this.#count;
  }

  // Public setter with validation
  set count(value) {
    const newCount = Number(value);

    if (isNaN(newCount)) {
      throw new Error(&#039;Count must be a number&#039;);
    }

    if (newCount &lt; this.#min || newCount &gt; this.#max) {
      throw new Error(`Count must be between ${this.#min} and ${this.#max}`);
    }

    this.#count = newCount;
    this.render();
  }

  increment() {
    this.count = Math.min(this.#count + 1, this.#max);
  }

  decrement() {
    this.count = Math.max(this.#count - 1, this.#min);
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;div&gt;${this.#count}&lt;/div&gt;
    `;
  }
}</code></pre>
<strong>Benefits:</strong>
<ul><li>True privacy (can't access from outside)</li>
<li>Validation at setter boundaries</li>
<li>Clear public API</li>
</ul>
<h3>State Objects</h3>
<p>Organize related state in objects:</p>
<pre><code class="language-javascript">class UserProfile extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });

    // Group related state
    this.state = {
      user: null,
      loading: false,
      error: null,
      editMode: false
    };
  }

  setState(updates) {
    // Merge updates into state
    this.state = {
      ...this.state,
      ...updates
    };

    this.render();
  }

  async loadUser(userId) {
    this.setState({ loading: true, error: null });

    try {
      const response = await fetch(`/api/users/${userId}`);
      const user = await response.json();

      this.setState({ user, loading: false });
    } catch (error) {
      this.setState({ error: error.message, loading: false });
    }
  }

  render() {
    const { user, loading, error, editMode } = this.state;

    if (loading) {
      this.shadowRoot.innerHTML = &#039;&lt;div&gt;Loading...&lt;/div&gt;&#039;;
    } else if (error) {
      this.shadowRoot.innerHTML = `&lt;div class=&quot;error&quot;&gt;${error}&lt;/div&gt;`;
    } else if (user) {
      this.shadowRoot.innerHTML = `
        &lt;div&gt;
          &lt;h2&gt;${user.name}&lt;/h2&gt;
          ${editMode ? this.renderEditForm() : this.renderDisplay()}
        &lt;/div&gt;
      `;
    }
  }
}</code></pre>
<strong>Benefits:</strong>
<ul><li>Organized state structure</li>
<li>Single method to update state</li>
<li>Clear state shape</li>
<li>Easier debugging (log entire state)</li>
</ul>
<h2>Shared State Patterns</h2>
<p>When multiple components need access to the same data, you need shared state.</p>
<h3>Simple Global State</h3>
<p>Create a shared state object:</p>
<pre><code class="language-javascript">// lib/state.js
export const appState = {
  user: null,
  theme: &#039;light&#039;,
  language: &#039;en&#039;,
  notifications: []
};

// Update state
export function updateState(updates) {
  Object.assign(appState, updates);
  pan.publish(&#039;app.state.changed&#039;, appState);
}

// Get state
export function getState() {
  return { ...appState };
}</code></pre>
<strong>Usage in components:</strong>
<pre><code class="language-javascript">import { appState, updateState } from &#039;../lib/state.js&#039;;

class ThemeSwitcher extends HTMLElement {
  connectedCallback() {
    // Read initial state
    this.render(appState.theme);

    // Subscribe to changes
    this.unsubscribe = pan.subscribe(&#039;app.state.changed&#039;, (state) =&gt; {
      this.render(state.theme);
    });

    // Add event listener
    this.addEventListener(&#039;click&#039;, () =&gt; {
      const newTheme = appState.theme === &#039;light&#039; ? &#039;dark&#039; : &#039;light&#039;;
      updateState({ theme: newTheme });
    });
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  render(theme) {
    this.textContent = `Theme: ${theme}`;
  }
}</code></pre>
<h3>Reactive State with Proxy</h3>
<p>Make state changes automatically trigger updates:</p>
<pre><code class="language-javascript">// lib/reactive-state.js
export function createReactiveState(initialState) {
  const listeners = new Set();

  const state = new Proxy(initialState, {
    set(target, property, value) {
      const oldValue = target[property];
      target[property] = value;

      // Notify listeners
      listeners.forEach(listener =&gt; {
        listener(property, value, oldValue);
      });

      // Also publish via PAN
      pan.publish(&#039;state.changed&#039;, {
        property,
        value,
        oldValue
      });

      return true;
    },

    get(target, property) {
      return target[property];
    }
  });

  return {
    state,
    subscribe(listener) {
      listeners.add(listener);
      return () =&gt; listeners.delete(listener);
    },
    getState() {
      return { ...state };
    }
  };
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">// Create reactive state
const { state, subscribe } = createReactiveState({
  count: 0,
  user: null,
  theme: &#039;light&#039;
});

// Components automatically react to changes
class CountDisplay extends HTMLElement {
  connectedCallback() {
    // Subscribe to specific property changes
    this.unsubscribe = subscribe((property, value) =&gt; {
      if (property === &#039;count&#039;) {
        this.textContent = `Count: ${value}`;
      }
    });

    // Initial render
    this.textContent = `Count: ${state.count}`;
  }

  disconnectedCallback() {
    this.unsubscribe();
  }
}

// Update state (automatically triggers updates)
state.count++;  // All subscribers notified
state.count = 42;  // All subscribers notified</code></pre>
<h3>Store Pattern</h3>
<p>Build a more sophisticated store:</p>
<pre><code class="language-javascript">// lib/store.js
class Store {
  constructor(initialState = {}) {
    this.state = initialState;
    this.listeners = new Map();
    this.middleware = [];
  }

  getState() {
    return { ...this.state };
  }

  setState(updates) {
    const oldState = { ...this.state };
    this.state = { ...this.state, ...updates };

    // Run middleware
    this.middleware.forEach(fn =&gt; fn(this.state, oldState));

    // Notify listeners
    this.listeners.forEach((listeners, key) =&gt; {
      if (key === &#039;*&#039; || key in updates) {
        listeners.forEach(listener =&gt; {
          listener(this.state, oldState);
        });
      }
    });
  }

  subscribe(key, listener) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }

    this.listeners.get(key).add(listener);

    // Return unsubscribe function
    return () =&gt; {
      const listeners = this.listeners.get(key);
      if (listeners) {
        listeners.delete(listener);
      }
    };
  }

  use(middleware) {
    this.middleware.push(middleware);
  }

  dispatch(action) {
    // Action pattern: { type, payload }
    switch (action.type) {
      case &#039;user/login&#039;:
        this.setState({ user: action.payload });
        break;
      case &#039;user/logout&#039;:
        this.setState({ user: null });
        break;
      case &#039;theme/change&#039;:
        this.setState({ theme: action.payload });
        break;
      default:
        console.warn(`Unknown action: ${action.type}`);
    }
  }
}

// Create store instance
export const store = new Store({
  user: null,
  theme: &#039;light&#039;,
  notifications: []
});

// Add logging middleware
store.use((state, oldState) =&gt; {
  console.log(&#039;State changed:&#039;, { old: oldState, new: state });
});

// Add persistence middleware
store.use((state) =&gt; {
  localStorage.setItem(&#039;app-state&#039;, JSON.stringify(state));
});</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { store } from &#039;../lib/store.js&#039;;

class UserMenu extends HTMLElement {
  connectedCallback() {
    // Subscribe to user changes only
    this.unsubscribe = store.subscribe(&#039;user&#039;, (state) =&gt; {
      this.render(state.user);
    });

    // Initial render
    this.render(store.getState().user);
  }

  disconnectedCallback() {
    this.unsubscribe();
  }

  render(user) {
    if (user) {
      this.innerHTML = `
        &lt;div&gt;Hello, ${user.name}&lt;/div&gt;
        &lt;button id=&quot;logout&quot;&gt;Logout&lt;/button&gt;
      `;

      this.querySelector(&#039;#logout&#039;).addEventListener(&#039;click&#039;, () =&gt; {
        store.dispatch({ type: &#039;user/logout&#039; });
      });
    } else {
      this.innerHTML = &#039;&lt;button id=&quot;login&quot;&gt;Login&lt;/button&gt;&#039;;

      this.querySelector(&#039;#login&#039;).addEventListener(&#039;click&#039;, () =&gt; {
        // Trigger login flow
        pan.publish(&#039;auth.login.requested&#039;);
      });
    }
  }
}</code></pre>
<h2>The pan-store Component</h2>
<p>!<a href="/Users/cdr/Projects/larc-repos/docs/books/learning-larc/build/images/06-state-management-9.png"><strong>Figure 6.2:</strong> pan-store Architecture</a></p>
<p>LARC provides a built-in component for state management:</p>
<pre><code class="language-html">&lt;pan-store id=&quot;app-store&quot; persist=&quot;true&quot;&gt;
  &lt;!-- Initial state --&gt;
  &lt;script type=&quot;application/json&quot;&gt;
  {
    &quot;user&quot;: null,
    &quot;theme&quot;: &quot;light&quot;,
    &quot;cart&quot;: {
      &quot;items&quot;: [],
      &quot;total&quot;: 0
    }
  }
  &lt;/script&gt;
&lt;/pan-store&gt;

&lt;script type=&quot;module&quot;&gt;
  const store = document.getElementById(&#039;app-store&#039;);

  // Get state
  const state = store.getState();

  // Update state
  store.setState({ theme: &#039;dark&#039; });

  // Subscribe to changes
  store.addEventListener(&#039;state-changed&#039;, (e) =&gt; {
    console.log(&#039;State changed:&#039;, e.detail);
  });

  // Or use PAN bus
  pan.subscribe(&#039;store.changed&#039;, (state) =&gt; {
    console.log(&#039;State via PAN:&#039;, state);
  });
&lt;/script&gt;</code></pre>
<strong>Features:</strong>
<ul><li>Declarative state initialization</li>
<li>Optional persistence to localStorage</li>
<li>Integrates with PAN bus</li>
<li>Supports nested state updates</li>
<li>Time-travel debugging in dev mode</li>
</ul>
<strong>Advanced usage:</strong>
<pre><code class="language-javascript">// Get nested state
const cartItems = store.getState(&#039;cart.items&#039;);

// Update nested state
store.setState(&#039;cart.items&#039;, [...items, newItem]);

// Subscribe to specific paths
store.subscribe(&#039;cart.total&#039;, (value) =&gt; {
  console.log(&#039;Cart total changed:&#039;, value);
});

// Computed properties
store.computed(&#039;cart.itemCount&#039;, (state) =&gt; {
  return state.cart.items.length;
});

// Actions
store.action(&#039;addToCart&#039;, (item) =&gt; {
  const cart = store.getState(&#039;cart&#039;);
  const items = [...cart.items, item];
  const total = items.reduce((sum, item) =&gt; sum + item.price, 0);

  store.setState({
    &#039;cart.items&#039;: items,
    &#039;cart.total&#039;: total
  });
});

// Use action
store.dispatch(&#039;addToCart&#039;, { id: 1, name: &#039;Product&#039;, price: 29.99 });</code></pre>
<h2>IndexedDB Integration</h2>
<p>For large datasets or offline capability, use IndexedDB:</p>
<h3>Basic IndexedDB Wrapper</h3>
<pre><code class="language-javascript">// lib/db.js
class Database {
  constructor(name, version = 1) {
    this.name = name;
    this.version = version;
    this.db = null;
  }

  async open(stores) {
    return new Promise((resolve, reject) =&gt; {
      const request = indexedDB.open(this.name, this.version);

      request.onerror = () =&gt; reject(request.error);
      request.onsuccess = () =&gt; {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) =&gt; {
        const db = event.target.result;

        stores.forEach(({ name, keyPath, indexes }) =&gt; {
          if (!db.objectStoreNames.contains(name)) {
            const store = db.createObjectStore(name, { keyPath });

            indexes?.forEach(({ name, keyPath, options }) =&gt; {
              store.createIndex(name, keyPath, options);
            });
          }
        });
      };
    });
  }

  async add(storeName, data) {
    const tx = this.db.transaction(storeName, &#039;readwrite&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.add(data);
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async get(storeName, key) {
    const tx = this.db.transaction(storeName, &#039;readonly&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.get(key);
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async getAll(storeName) {
    const tx = this.db.transaction(storeName, &#039;readonly&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.getAll();
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async update(storeName, data) {
    const tx = this.db.transaction(storeName, &#039;readwrite&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.put(data);
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async delete(storeName, key) {
    const tx = this.db.transaction(storeName, &#039;readwrite&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.delete(key);
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }

  async clear(storeName) {
    const tx = this.db.transaction(storeName, &#039;readwrite&#039;);
    const store = tx.objectStore(storeName);

    return new Promise((resolve, reject) =&gt; {
      const request = store.clear();
      request.onsuccess = () =&gt; resolve(request.result);
      request.onerror = () =&gt; reject(request.error);
    });
  }
}

// Initialize database
export const db = new Database(&#039;MyApp&#039;, 1);

await db.open([
  {
    name: &#039;todos&#039;,
    keyPath: &#039;id&#039;,
    indexes: [
      { name: &#039;by-status&#039;, keyPath: &#039;status&#039; },
      { name: &#039;by-created&#039;, keyPath: &#039;createdAt&#039; }
    ]
  },
  {
    name: &#039;users&#039;,
    keyPath: &#039;id&#039;
  }
]);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { db } from &#039;../lib/db.js&#039;;

class TodoList extends HTMLElement {
  async connectedCallback() {
    // Load todos from IndexedDB
    this.todos = await db.getAll(&#039;todos&#039;);
    this.render();

    // Subscribe to changes
    pan.subscribe(&#039;todo.added&#039;, async ({ todo }) =&gt; {
      await db.add(&#039;todos&#039;, todo);
      this.todos = await db.getAll(&#039;todos&#039;);
      this.render();
    });

    pan.subscribe(&#039;todo.updated&#039;, async ({ todo }) =&gt; {
      await db.update(&#039;todos&#039;, todo);
      this.todos = await db.getAll(&#039;todos&#039;);
      this.render();
    });

    pan.subscribe(&#039;todo.deleted&#039;, async ({ id }) =&gt; {
      await db.delete(&#039;todos&#039;, id);
      this.todos = await db.getAll(&#039;todos&#039;);
      this.render();
    });
  }

  render() {
    this.innerHTML = `
      &lt;ul&gt;
        ${this.todos.map(todo =&gt; `
          &lt;li&gt;
            &lt;span&gt;${todo.text}&lt;/span&gt;
            &lt;button data-id=&quot;${todo.id}&quot;&gt;Delete&lt;/button&gt;
          &lt;/li&gt;
        `).join(&#039;&#039;)}
      &lt;/ul&gt;
    `;
  }
}</code></pre>
<h3>Cache-First Strategy</h3>
<p>Implement cache-first data loading:</p>
<pre><code class="language-javascript">class DataManager {
  constructor(storeName) {
    this.storeName = storeName;
    this.cache = new Map();
  }

  async get(id) {
    // 1. Check memory cache
    if (this.cache.has(id)) {
      return this.cache.get(id);
    }

    // 2. Check IndexedDB
    const cached = await db.get(this.storeName, id);
    if (cached) {
      this.cache.set(id, cached);
      return cached;
    }

    // 3. Fetch from API
    const data = await this.fetchFromAPI(id);

    // 4. Store in cache and IndexedDB
    this.cache.set(id, data);
    await db.add(this.storeName, data);

    return data;
  }

  async fetchFromAPI(id) {
    const response = await fetch(`/api/${this.storeName}/${id}`);
    return response.json();
  }

  async refresh(id) {
    // Force refresh from API
    const data = await this.fetchFromAPI(id);

    // Update cache and IndexedDB
    this.cache.set(id, data);
    await db.update(this.storeName, data);

    return data;
  }

  async getAll() {
    // Load from IndexedDB first
    const items = await db.getAll(this.storeName);

    // Cache in memory
    items.forEach(item =&gt; {
      this.cache.set(item.id, item);
    });

    return items;
  }
}

// Usage
const userManager = new DataManager(&#039;users&#039;);

// Always returns fast (from cache if available)
const user = await userManager.get(123);

// Force refresh
const freshUser = await userManager.refresh(123);</code></pre>
<h2>Persistence Strategies</h2>
<h3>localStorage</h3>
<p>Simple key-value storage:</p>
<pre><code class="language-javascript">class PersistentState {
  constructor(key) {
    this.key = key;
    this.state = this.load();
  }

  load() {
    try {
      const data = localStorage.getItem(this.key);
      return data ? JSON.parse(data) : {};
    } catch (error) {
      console.error(&#039;Failed to load state:&#039;, error);
      return {};
    }
  }

  save() {
    try {
      localStorage.setItem(this.key, JSON.stringify(this.state));
    } catch (error) {
      console.error(&#039;Failed to save state:&#039;, error);
    }
  }

  get(path) {
    return this.getNestedValue(this.state, path);
  }

  set(path, value) {
    this.setNestedValue(this.state, path, value);
    this.save();
  }

  getNestedValue(obj, path) {
    return path.split(&#039;.&#039;).reduce((current, key) =&gt; current?.[key], obj);
  }

  setNestedValue(obj, path, value) {
    const keys = path.split(&#039;.&#039;);
    const lastKey = keys.pop();
    const target = keys.reduce((current, key) =&gt; {
      if (!(key in current)) current[key] = {};
      return current[key];
    }, obj);
    target[lastKey] = value;
  }

  clear() {
    this.state = {};
    localStorage.removeItem(this.key);
  }
}

// Usage
const settings = new PersistentState(&#039;app-settings&#039;);

settings.set(&#039;theme&#039;, &#039;dark&#039;);
settings.set(&#039;user.preferences.notifications&#039;, true);

console.log(settings.get(&#039;theme&#039;));  // &#039;dark&#039;
console.log(settings.get(&#039;user.preferences.notifications&#039;));  // true</code></pre>
<h3>sessionStorage</h3>
<p>For temporary session data:</p>
<pre><code class="language-javascript">class SessionState {
  constructor(key) {
    this.key = key;
  }

  set(data) {
    sessionStorage.setItem(this.key, JSON.stringify(data));
  }

  get() {
    const data = sessionStorage.getItem(this.key);
    return data ? JSON.parse(data) : null;
  }

  clear() {
    sessionStorage.removeItem(this.key);
  }
}

// Usage - data persists only for the session
const sessionData = new SessionState(&#039;form-draft&#039;);

// Save form draft
sessionData.set({ email: &#039;user@example.com&#039;, message: &#039;Draft...&#039; });

// Restore on page reload (same session)
const draft = sessionData.get();</code></pre>
<h3>Hybrid Strategy</h3>
<p>Combine localStorage and IndexedDB:</p>
<pre><code class="language-javascript">class HybridStorage {
  constructor(namespace) {
    this.namespace = namespace;
  }

  async set(key, value) {
    const fullKey = `${this.namespace}:${key}`;

    // Store small data in localStorage
    if (this.isSmall(value)) {
      localStorage.setItem(fullKey, JSON.stringify(value));
    } else {
      // Store large data in IndexedDB
      await db.update(&#039;storage&#039;, { key: fullKey, value });
    }
  }

  async get(key) {
    const fullKey = `${this.namespace}:${key}`;

    // Try localStorage first
    const local = localStorage.getItem(fullKey);
    if (local) {
      return JSON.parse(local);
    }

    // Try IndexedDB
    const result = await db.get(&#039;storage&#039;, fullKey);
    return result?.value;
  }

  isSmall(value) {
    const str = JSON.stringify(value);
    return str.length &lt; 1024 * 10; // 10KB threshold
  }

  async clear() {
    // Clear localStorage items
    Object.keys(localStorage).forEach(key =&gt; {
      if (key.startsWith(`${this.namespace}:`)) {
        localStorage.removeItem(key);
      }
    });

    // Clear IndexedDB items
    const all = await db.getAll(&#039;storage&#039;);
    for (const item of all) {
      if (item.key.startsWith(`${this.namespace}:`)) {
        await db.delete(&#039;storage&#039;, item.key);
      }
    }
  }
}</code></pre>
<h2>Offline-First Applications</h2>
<p>Build applications that work without connectivity:</p>
<h3>Service Worker + State Management</h3>
<pre><code class="language-javascript">// sw.js - Service Worker
self.addEventListener(&#039;install&#039;, (event) =&gt; {
  event.waitUntil(
    caches.open(&#039;v1&#039;).then((cache) =&gt; {
      return cache.addAll([
        &#039;/&#039;,
        &#039;/index.html&#039;,
        &#039;/src/app.js&#039;,
        &#039;/&#039;,
        // Cache critical assets
      ]);
    })
  );
});

self.addEventListener(&#039;fetch&#039;, (event) =&gt; {
  event.respondWith(
    caches.match(event.request).then((response) =&gt; {
      // Return cached version or fetch
      return response || fetch(event.request);
    })
  );
});</code></pre>
<h3>Sync Queue</h3>
<p>Queue operations when offline:</p>
<pre><code class="language-javascript">// lib/sync-queue.js
class SyncQueue {
  constructor() {
    this.queue = this.loadQueue();
    this.processing = false;

    // Listen for online events
    window.addEventListener(&#039;online&#039;, () =&gt; {
      this.process();
    });

    // Start processing if online
    if (navigator.onLine) {
      this.process();
    }
  }

  loadQueue() {
    const data = localStorage.getItem(&#039;sync-queue&#039;);
    return data ? JSON.parse(data) : [];
  }

  saveQueue() {
    localStorage.setItem(&#039;sync-queue&#039;, JSON.stringify(this.queue));
  }

  add(operation) {
    this.queue.push({
      id: Date.now() + Math.random(),
      operation,
      timestamp: Date.now(),
      attempts: 0
    });

    this.saveQueue();

    if (navigator.onLine) {
      this.process();
    }
  }

  async process() {
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;

    while (this.queue.length &gt; 0 &amp;&amp; navigator.onLine) {
      const item = this.queue[0];

      try {
        await this.executeOperation(item.operation);

        // Success - remove from queue
        this.queue.shift();
        this.saveQueue();

        pan.publish(&#039;sync.success&#039;, { operation: item.operation });
      } catch (error) {
        item.attempts++;

        if (item.attempts &gt;= 3) {
          // Max attempts - remove and report error
          this.queue.shift();
          this.saveQueue();

          pan.publish(&#039;sync.failed&#039;, {
            operation: item.operation,
            error: error.message
          });
        } else {
          // Retry later
          break;
        }
      }
    }

    this.processing = false;
  }

  async executeOperation(operation) {
    switch (operation.type) {
      case &#039;CREATE&#039;:
        return this.create(operation.data);
      case &#039;UPDATE&#039;:
        return this.update(operation.data);
      case &#039;DELETE&#039;:
        return this.delete(operation.id);
      default:
        throw new Error(`Unknown operation: ${operation.type}`);
    }
  }

  async create(data) {
    const response = await fetch(&#039;/api/items&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(data)
    });

    if (!response.ok) throw new Error(&#039;Create failed&#039;);
    return response.json();
  }

  async update(data) {
    const response = await fetch(`/api/items/${data.id}`, {
      method: &#039;PUT&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(data)
    });

    if (!response.ok) throw new Error(&#039;Update failed&#039;);
    return response.json();
  }

  async delete(id) {
    const response = await fetch(`/api/items/${id}`, {
      method: &#039;DELETE&#039;
    });

    if (!response.ok) throw new Error(&#039;Delete failed&#039;);
  }

  clear() {
    this.queue = [];
    this.saveQueue();
  }

  getStatus() {
    return {
      queued: this.queue.length,
      online: navigator.onLine,
      processing: this.processing
    };
  }
}

export const syncQueue = new SyncQueue();</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { syncQueue } from &#039;../lib/sync-queue.js&#039;;

class TodoManager {
  async addTodo(text) {
    const todo = {
      id: Date.now(),
      text,
      completed: false,
      createdAt: new Date()
    };

    // Save locally immediately
    await db.add(&#039;todos&#039;, todo);
    pan.publish(&#039;todo.added&#039;, { todo });

    // Queue for server sync
    if (!navigator.onLine) {
      syncQueue.add({
        type: &#039;CREATE&#039;,
        data: todo
      });

      pan.publish(&#039;notification.info&#039;, {
        message: &#039;Saved locally. Will sync when online.&#039;
      });
    } else {
      // Online - sync immediately
      try {
        await this.syncToServer(todo);
      } catch (error) {
        // Failed - add to queue
        syncQueue.add({
          type: &#039;CREATE&#039;,
          data: todo
        });
      }
    }
  }

  async syncToServer(todo) {
    const response = await fetch(&#039;/api/todos&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(todo)
    });

    if (!response.ok) {
      throw new Error(&#039;Sync failed&#039;);
    }

    const result = await response.json();

    // Update local copy with server ID
    await db.update(&#039;todos&#039;, { ...todo, serverId: result.id });
  }
}</code></pre>
<h2>Summary</h2>
<p>This chapter covered state management at every level:</p>
<ul><li><strong>Component-Local State</strong>: Instance properties, private fields, and state objects</li>
<li><strong>Shared State</strong>: Global state, reactive proxies, and store patterns</li>
<li><strong>pan-store</strong>: Built-in state management component</li>
<li><strong>IndexedDB</strong>: Large dataset storage and offline capability</li>
<li><strong>Persistence</strong>: localStorage, sessionStorage, and hybrid strategies</li>
<li><strong>Offline-First</strong>: Service workers, sync queues, and conflict resolution</li>
</ul>
Choose the simplest solution that meets your needs, then scale up complexity as requirements grow.
<hr>
<h2>Best Practices</h2>
<li><strong>Start with local state</strong></li>
   - Only share state when necessary
   - Keeps components independent
   - Easier to test and debug
<li><strong>Use IndexedDB for large data</strong></li>
   - localStorage limited to ~5-10MB
   - IndexedDB can store gigabytes
   - Better performance for large datasets
<li><strong>Implement cache-first strategies</strong></li>
   - Load from cache immediately
   - Update from server in background
   - Show stale data rather than loading spinner
<li><strong>Queue offline operations</strong></li>
   - Don't lose user data
   - Sync when connection restored
   - Show sync status to user
<li><strong>Test offline scenarios</strong></li>
   - Use DevTools to simulate offline
   - Test sync queue behavior
   - Verify conflict resolution
<li><strong>Monitor storage usage</strong></li>
   - Check quota before storing
   - Clean up old data
   - Provide clear error messages when full
<hr>
<h2>Further Reading</h2>
<strong>For complete state management reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 4: State Management - All state patterns and strategies</li>
<li><em>Building with LARC</em> Chapter 18: Data Components - pan-store and pan-idb API reference</li>
<li><em>Building with LARC</em> Appendix E: Recipes and Patterns - State management recipes</li>
</ul><div class="pagebreak"></div>
<h1>Advanced Component Patterns</h1>
<p>As your LARC applications grow, you'll encounter scenarios that require sophisticated component architectures. This chapter explores advanced patterns that enable code reuse, flexible composition, and optimal performance.</p>
<p>These patterns come from years of component-based development across frameworks. LARC implements them using web standards, making them portable and future-proof.</p>
<h2>Compound Components</h2>
<p>Compound components work together as a set, sharing implicit state. Think of HTML's <code><select></code> and <code><option></code> elements—they form a cohesive unit.</p>
<h3>Basic Compound Component</h3>
<pre><code class="language-javascript">// tabs.js - Container component
class TabGroup extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.activeTab = 0;
  }

  connectedCallback() {
    this.render();
    this.setupTabs();
  }

  setupTabs() {
    // Get all tab headers
    const headers = this.querySelectorAll(&#039;tab-header&#039;);
    headers.forEach((header, index) =&gt; {
      header.addEventListener(&#039;click&#039;, () =&gt; {
        this.activeTab = index;
        this.updateTabs();
      });
    });

    this.updateTabs();
  }

  updateTabs() {
    // Update headers
    const headers = this.querySelectorAll(&#039;tab-header&#039;);
    headers.forEach((header, index) =&gt; {
      header.active = index === this.activeTab;
    });

    // Update panels
    const panels = this.querySelectorAll(&#039;tab-panel&#039;);
    panels.forEach((panel, index) =&gt; {
      panel.active = index === this.activeTab;
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
        }
        .headers {
          display: flex;
          border-bottom: 2px solid #e2e8f0;
        }
        .panels {
          padding: 16px 0;
        }
      &lt;/style&gt;
      &lt;div class=&quot;headers&quot;&gt;
        &lt;slot name=&quot;headers&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
      &lt;div class=&quot;panels&quot;&gt;
        &lt;slot name=&quot;panels&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;
  }
}

// tab-header.js
class TabHeader extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  set active(value) {
    this._active = value;
    this.render();
  }

  connectedCallback() {
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        button {
          padding: 12px 24px;
          border: none;
          background: ${this._active ? &#039;#667eea&#039; : &#039;transparent&#039;};
          color: ${this._active ? &#039;white&#039; : &#039;#4a5568&#039;};
          cursor: pointer;
          font-weight: ${this._active ? &#039;600&#039; : &#039;400&#039;};
          transition: all 0.2s;
        }
        button:hover {
          background: ${this._active ? &#039;#5a67d8&#039; : &#039;#f7fafc&#039;};
        }
      &lt;/style&gt;
      &lt;button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;
    `;
  }
}

// tab-panel.js
class TabPanel extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  set active(value) {
    this._active = value;
    this.style.display = value ? &#039;block&#039; : &#039;none&#039;;
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
        }
      &lt;/style&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;
  }
}

customElements.define(&#039;tab-group&#039;, TabGroup);
customElements.define(&#039;tab-header&#039;, TabHeader);
customElements.define(&#039;tab-panel&#039;, TabPanel);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;tab-group&gt;
  &lt;tab-header slot=&quot;headers&quot;&gt;Profile&lt;/tab-header&gt;
  &lt;tab-header slot=&quot;headers&quot;&gt;Settings&lt;/tab-header&gt;
  &lt;tab-header slot=&quot;headers&quot;&gt;Billing&lt;/tab-header&gt;

  &lt;tab-panel slot=&quot;panels&quot;&gt;
    &lt;h2&gt;Profile Content&lt;/h2&gt;
    &lt;p&gt;User profile information...&lt;/p&gt;
  &lt;/tab-panel&gt;

  &lt;tab-panel slot=&quot;panels&quot;&gt;
    &lt;h2&gt;Settings Content&lt;/h2&gt;
    &lt;p&gt;Application settings...&lt;/p&gt;
  &lt;/tab-panel&gt;

  &lt;tab-panel slot=&quot;panels&quot;&gt;
    &lt;h2&gt;Billing Content&lt;/h2&gt;
    &lt;p&gt;Billing information...&lt;/p&gt;
  &lt;/tab-panel&gt;
&lt;/tab-group&gt;</code></pre>
<h3>Context API for Compound Components</h3>
<p>Share state without prop drilling:</p>
<pre><code class="language-javascript">// lib/context.js
const contexts = new WeakMap();

export function createContext(defaultValue) {
  return {
    Provider: class extends HTMLElement {
      constructor() {
        super();
        this.value = defaultValue;
        contexts.set(this, this.value);
      }

      provide(value) {
        this.value = value;
        contexts.set(this, value);
        this.notifyConsumers();
      }

      notifyConsumers() {
        const consumers = this.querySelectorAll(&#039;[data-context-consumer]&#039;);
        consumers.forEach(consumer =&gt; {
          if (consumer.onContextChange) {
            consumer.onContextChange(this.value);
          }
        });
      }

      connectedCallback() {
        this.innerHTML = `&lt;slot&gt;&lt;/slot&gt;`;
      }
    },

    Consumer: class extends HTMLElement {
      connectedCallback() {
        this.setAttribute(&#039;data-context-consumer&#039;, &#039;&#039;);

        // Find provider up the tree
        let provider = this.closest(&#039;[data-context-provider]&#039;);
        if (provider &amp;&amp; contexts.has(provider)) {
          this.onContextChange(contexts.get(provider));
        }
      }

      onContextChange(value) {
        // Override in subclasses
      }
    }
  };
}</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">// Create context
const ThemeContext = createContext({ theme: &#039;light&#039; });

// Provider component
class ThemeProvider extends ThemeContext.Provider {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute(&#039;data-context-provider&#039;, &#039;&#039;);

    this.provide({
      theme: &#039;light&#039;,
      toggleTheme: () =&gt; {
        const newTheme = this.value.theme === &#039;light&#039; ? &#039;dark&#039; : &#039;light&#039;;
        this.provide({ ...this.value, theme: newTheme });
      }
    });
  }
}

// Consumer component
class ThemedButton extends ThemeContext.Consumer {
  onContextChange(context) {
    this.context = context;
    this.render();
  }

  render() {
    const { theme } = this.context || { theme: &#039;light&#039; };

    this.innerHTML = `
      &lt;button style=&quot;
        background: ${theme === &#039;dark&#039; ? &#039;#333&#039; : &#039;#fff&#039;};
        color: ${theme === &#039;dark&#039; ? &#039;#fff&#039; : &#039;#333&#039;};
      &quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/button&gt;
    `;
  }
}

customElements.define(&#039;theme-provider&#039;, ThemeProvider);
customElements.define(&#039;themed-button&#039;, ThemedButton);</code></pre>
<pre><code class="language-html">&lt;theme-provider&gt;
  &lt;themed-button&gt;Light/Dark&lt;/themed-button&gt;
  &lt;themed-button&gt;Another Button&lt;/themed-button&gt;
&lt;/theme-provider&gt;</code></pre>
<h2>Higher-Order Components</h2>
<p>Higher-order components (HOCs) wrap other components to add functionality.</p>
<h3>Mixin Pattern</h3>
<p>JavaScript mixins add functionality to classes:</p>
<pre><code class="language-javascript">// mixins/observable.js
export const ObservableMixin = (Base) =&gt; class extends Base {
  constructor() {
    super();
    this._observers = new Map();
  }

  observe(property, callback) {
    if (!this._observers.has(property)) {
      this._observers.set(property, new Set());
    }
    this._observers.get(property).add(callback);

    // Return unobserve function
    return () =&gt; {
      this._observers.get(property)?.delete(callback);
    };
  }

  notify(property, value) {
    this._observers.get(property)?.forEach(callback =&gt; {
      callback(value);
    });
  }

  set(property, value) {
    this[`_${property}`] = value;
    this.notify(property, value);
  }

  get(property) {
    return this[`_${property}`];
  }
};

// mixins/resizable.js
export const ResizableMixin = (Base) =&gt; class extends Base {
  connectedCallback() {
    super.connectedCallback?.();

    this.resizeObserver = new ResizeObserver((entries) =&gt; {
      for (const entry of entries) {
        this.onResize?.(entry.contentRect);
      }
    });

    this.resizeObserver.observe(this);
  }

  disconnectedCallback() {
    super.disconnectedCallback?.();
    this.resizeObserver?.disconnect();
  }
};

// mixins/loading.js
export const LoadingMixin = (Base) =&gt; class extends Base {
  constructor() {
    super();
    this._loading = false;
  }

  startLoading() {
    this._loading = true;
    this.setAttribute(&#039;loading&#039;, &#039;&#039;);
    this.onLoadingChange?.(true);
  }

  stopLoading() {
    this._loading = false;
    this.removeAttribute(&#039;loading&#039;);
    this.onLoadingChange?.(false);
  }

  get loading() {
    return this._loading;
  }
};</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { ObservableMixin } from &#039;./mixins/observable.js&#039;;
import { ResizableMixin } from &#039;./mixins/resizable.js&#039;;
import { LoadingMixin } from &#039;./mixins/loading.js&#039;;

// Compose multiple mixins
class DataTable extends LoadingMixin(ResizableMixin(ObservableMixin(HTMLElement))) {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  async connectedCallback() {
    super.connectedCallback();

    // Use Observable mixin
    this.observe(&#039;data&#039;, (data) =&gt; {
      console.log(&#039;Data changed:&#039;, data);
      this.render();
    });

    // Use Loading mixin
    this.startLoading();
    const data = await this.fetchData();
    this.set(&#039;data&#039;, data);
    this.stopLoading();
  }

  // Use Resizable mixin
  onResize(rect) {
    console.log(&#039;Component resized:&#039;, rect.width, rect.height);
    this.updateLayout();
  }

  onLoadingChange(loading) {
    this.render();
  }

  async fetchData() {
    const response = await fetch(&#039;/api/data&#039;);
    return response.json();
  }

  render() {
    // Render based on state
  }
}

customElements.define(&#039;data-table&#039;, DataTable);</code></pre>
<h3>Decorator Pattern</h3>
<p>Wrap components to enhance them:</p>
<pre><code class="language-javascript">// decorators/with-loading.js
export function withLoading(ComponentClass) {
  return class extends ComponentClass {
    constructor() {
      super();
      this._originalConnectedCallback = this.connectedCallback;
    }

    connectedCallback() {
      // Inject loading overlay
      const loadingOverlay = document.createElement(&#039;div&#039;);
      loadingOverlay.className = &#039;loading-overlay&#039;;
      loadingOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255,255,255,0.8);
        display: none;
        align-items: center;
        justify-content: center;
      `;
      loadingOverlay.innerHTML = &#039;&lt;div class=&quot;spinner&quot;&gt;&lt;/div&gt;&#039;;

      this.appendChild(loadingOverlay);
      this._loadingOverlay = loadingOverlay;

      // Call original
      if (this._originalConnectedCallback) {
        this._originalConnectedCallback.call(this);
      }
    }

    showLoading() {
      if (this._loadingOverlay) {
        this._loadingOverlay.style.display = &#039;flex&#039;;
      }
    }

    hideLoading() {
      if (this._loadingOverlay) {
        this._loadingOverlay.style.display = &#039;none&#039;;
      }
    }
  };
}

// Usage
class UserProfile extends HTMLElement {
  async connectedCallback() {
    this.showLoading();

    const user = await fetch(&#039;/api/user&#039;).then(r =&gt; r.json());
    this.render(user);

    this.hideLoading();
  }

  render(user) {
    this.innerHTML = `&lt;h1&gt;${user.name}&lt;/h1&gt;`;
  }
}

// Apply decorator
const UserProfileWithLoading = withLoading(UserProfile);
customElements.define(&#039;user-profile&#039;, UserProfileWithLoading);</code></pre>
<h2>Component Composition</h2>
<p>Build complex UIs from simple, focused components.</p>
<h3>Container/Presentational Pattern</h3>
<p>Separate logic from presentation:</p>
<pre><code class="language-javascript">// Presentational - no logic, just rendering
class UserCard extends HTMLElement {
  set user(value) {
    this._user = value;
    this.render();
  }

  render() {
    if (!this._user) return;

    this.innerHTML = `
      &lt;div class=&quot;card&quot;&gt;
        &lt;img src=&quot;${this._user.avatar}&quot; alt=&quot;${this._user.name}&quot;&gt;
        &lt;h3&gt;${this._user.name}&lt;/h3&gt;
        &lt;p&gt;${this._user.email}&lt;/p&gt;
        &lt;button class=&quot;follow-btn&quot;&gt;Follow&lt;/button&gt;
      &lt;/div&gt;
    `;

    // Emit events, don&#039;t handle logic
    this.querySelector(&#039;.follow-btn&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.dispatchEvent(new CustomEvent(&#039;follow&#039;, {
        detail: { userId: this._user.id }
      }));
    });
  }
}

// Container - handles logic and data
class UserCardContainer extends HTMLElement {
  async connectedCallback() {
    const userId = this.getAttribute(&#039;user-id&#039;);

    // Fetch data
    this.user = await this.fetchUser(userId);

    // Create presentational component
    const card = document.createElement(&#039;user-card&#039;);
    card.user = this.user;

    // Handle events
    card.addEventListener(&#039;follow&#039;, (e) =&gt; {
      this.followUser(e.detail.userId);
    });

    this.appendChild(card);
  }

  async fetchUser(id) {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }

  async followUser(userId) {
    await fetch(`/api/users/${userId}/follow`, { method: &#039;POST&#039; });
    pan.publish(&#039;user.followed&#039;, { userId });
  }
}

customElements.define(&#039;user-card&#039;, UserCard);
customElements.define(&#039;user-card-container&#039;, UserCardContainer);</code></pre>
<h3>Render Props Pattern</h3>
<p>Pass rendering logic as a slot:</p>
<pre><code class="language-javascript">class DataProvider extends HTMLElement {
  async connectedCallback() {
    const url = this.getAttribute(&#039;url&#039;);

    // Render loading state
    this.innerHTML = &#039;&lt;slot name=&quot;loading&quot;&gt;Loading...&lt;/slot&gt;&#039;;

    try {
      const response = await fetch(url);
      const data = await response.json();

      // Render with data
      const renderSlot = this.querySelector(&#039;[slot=&quot;render&quot;]&#039;);
      if (renderSlot) {
        renderSlot.data = data;
        this.innerHTML = &#039;&#039;;
        this.appendChild(renderSlot);
      }
    } catch (error) {
      // Render error state
      this.innerHTML = `&lt;slot name=&quot;error&quot;&gt;Error: ${error.message}&lt;/slot&gt;`;
    }
  }
}

customElements.define(&#039;data-provider&#039;, DataProvider);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;data-provider url=&quot;/api/users&quot;&gt;
  &lt;div slot=&quot;loading&quot;&gt;
    &lt;spinner-component&gt;&lt;/spinner-component&gt;
  &lt;/div&gt;

  &lt;user-list slot=&quot;render&quot;&gt;&lt;/user-list&gt;

  &lt;div slot=&quot;error&quot;&gt;
    &lt;error-message&gt;&lt;/error-message&gt;
  &lt;/div&gt;
&lt;/data-provider&gt;</code></pre>
<h2>Slots and Content Projection</h2>
<p>Slots are powerful for flexible component composition.</p>
<h3>Named Slots</h3>
<pre><code class="language-javascript">class CardComponent extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .card {
          border: 1px solid #e2e8f0;
          border-radius: 8px;
          overflow: hidden;
        }
        .header {
          background: #f7fafc;
          padding: 16px;
          border-bottom: 1px solid #e2e8f0;
        }
        .body {
          padding: 16px;
        }
        .footer {
          background: #f7fafc;
          padding: 12px 16px;
          border-top: 1px solid #e2e8f0;
          display: flex;
          justify-content: flex-end;
          gap: 8px;
        }
      &lt;/style&gt;

      &lt;div class=&quot;card&quot;&gt;
        &lt;div class=&quot;header&quot;&gt;
          &lt;slot name=&quot;header&quot;&gt;Default Header&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;body&quot;&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;footer&quot;&gt;
          &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;card-component&#039;, CardComponent);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;card-component&gt;
  &lt;h2 slot=&quot;header&quot;&gt;User Profile&lt;/h2&gt;

  &lt;!-- Default slot --&gt;
  &lt;p&gt;User profile content goes here...&lt;/p&gt;

  &lt;div slot=&quot;footer&quot;&gt;
    &lt;button&gt;Save&lt;/button&gt;
    &lt;button&gt;Cancel&lt;/button&gt;
  &lt;/div&gt;
&lt;/card-component&gt;</code></pre>
<h3>Slot Change Detection</h3>
<p>React to slot content changes:</p>
<pre><code class="language-javascript">class DynamicList extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .count { font-weight: bold; color: #667eea; }
      &lt;/style&gt;
      &lt;div class=&quot;count&quot;&gt;&lt;/div&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;

    // Listen for slot changes
    const slot = this.shadowRoot.querySelector(&#039;slot&#039;);
    slot.addEventListener(&#039;slotchange&#039;, () =&gt; {
      this.updateCount();
    });

    this.updateCount();
  }

  updateCount() {
    const slot = this.shadowRoot.querySelector(&#039;slot&#039;);
    const elements = slot.assignedElements();

    const count = this.shadowRoot.querySelector(&#039;.count&#039;);
    count.textContent = `${elements.length} items`;
  }
}

customElements.define(&#039;dynamic-list&#039;, DynamicList);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;dynamic-list&gt;
  &lt;div&gt;Item 1&lt;/div&gt;
  &lt;div&gt;Item 2&lt;/div&gt;
  &lt;div&gt;Item 3&lt;/div&gt;
&lt;/dynamic-list&gt;

&lt;script&gt;
  const list = document.querySelector(&#039;dynamic-list&#039;);

  // Add item dynamically
  const newItem = document.createElement(&#039;div&#039;);
  newItem.textContent = &#039;Item 4&#039;;
  list.appendChild(newItem);
  // Count automatically updates!
&lt;/script&gt;</code></pre>
<h3>Conditional Slots</h3>
<p>Show/hide content based on slot presence:</p>
<pre><code class="language-javascript">class ConditionalCard extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    const hasHeader = this.querySelector(&#039;[slot=&quot;header&quot;]&#039;) !== null;
    const hasFooter = this.querySelector(&#039;[slot=&quot;footer&quot;]&#039;) !== null;

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .card { border: 1px solid #ddd; border-radius: 8px; }
        .header, .footer { background: #f5f5f5; padding: 16px; }
        .body { padding: 16px; }
        .hidden { display: none; }
      &lt;/style&gt;

      &lt;div class=&quot;card&quot;&gt;
        &lt;div class=&quot;header ${hasHeader ? &#039;&#039; : &#039;hidden&#039;}&quot;&gt;
          &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;body&quot;&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;footer ${hasFooter ? &#039;&#039; : &#039;hidden&#039;}&quot;&gt;
          &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;conditional-card&#039;, ConditionalCard);</code></pre>
<h2>Dynamic Component Loading</h2>
<p>Load components on demand for better performance.</p>
<h3>Lazy Loading</h3>
<pre><code class="language-javascript">class LazyLoader extends HTMLElement {
  async connectedCallback() {
    const component = this.getAttribute(&#039;component&#039;);
    const src = this.getAttribute(&#039;src&#039;);

    // Show placeholder
    this.innerHTML = &#039;&lt;div&gt;Loading component...&lt;/div&gt;&#039;;

    try {
      // Dynamically import component
      await import(src);

      // Wait for component to be defined
      await customElements.whenDefined(component);

      // Create and append component
      const element = document.createElement(component);

      // Copy attributes
      Array.from(this.attributes).forEach(attr =&gt; {
        if (attr.name !== &#039;component&#039; &amp;&amp; attr.name !== &#039;src&#039;) {
          element.setAttribute(attr.name, attr.value);
        }
      });

      this.innerHTML = &#039;&#039;;
      this.appendChild(element);
    } catch (error) {
      this.innerHTML = `&lt;div class=&quot;error&quot;&gt;Failed to load component: ${error.message}&lt;/div&gt;`;
    }
  }
}

customElements.define(&#039;lazy-loader&#039;, LazyLoader);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;!-- Component loads when added to DOM --&gt;
&lt;lazy-loader
  component=&quot;heavy-chart&quot;
  src=&quot;/components/heavy-chart.js&quot;
  data-url=&quot;/api/chart-data&quot;&gt;
&lt;/lazy-loader&gt;</code></pre>
<h3>Intersection Observer for Viewport Loading</h3>
<p>Load components when they enter the viewport:</p>
<pre><code class="language-javascript">class ViewportLoader extends HTMLElement {
  connectedCallback() {
    this.observer = new IntersectionObserver((entries) =&gt; {
      entries.forEach(entry =&gt; {
        if (entry.isIntersecting &amp;&amp; !this.loaded) {
          this.load();
        }
      });
    }, {
      rootMargin: &#039;50px&#039;  // Start loading 50px before visible
    });

    this.observer.observe(this);
  }

  disconnectedCallback() {
    this.observer?.disconnect();
  }

  async load() {
    this.loaded = true;
    const component = this.getAttribute(&#039;component&#039;);
    const src = this.getAttribute(&#039;src&#039;);

    await import(src);
    await customElements.whenDefined(component);

    const element = document.createElement(component);
    Array.from(this.attributes).forEach(attr =&gt; {
      if (![&#039;component&#039;, &#039;src&#039;].includes(attr.name)) {
        element.setAttribute(attr.name, attr.value);
      }
    });

    this.appendChild(element);
  }
}

customElements.define(&#039;viewport-loader&#039;, ViewportLoader);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;!-- Heavy image gallery - only loads when scrolled into view --&gt;
&lt;viewport-loader
  component=&quot;image-gallery&quot;
  src=&quot;/components/image-gallery.js&quot;
  album-id=&quot;123&quot;&gt;
&lt;/viewport-loader&gt;</code></pre>
<h2>Performance Optimization</h2>
<h3>Virtual Scrolling</h3>
<p>Render only visible items in long lists:</p>
<pre><code class="language-javascript">class VirtualList extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });

    this.items = [];
    this.itemHeight = 50;
    this.visibleCount = 20;
    this.scrollTop = 0;
  }

  set data(items) {
    this.items = items;
    this.render();
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          height: 100%;
          overflow-y: auto;
          position: relative;
        }
        .viewport {
          position: relative;
        }
        .item {
          position: absolute;
          left: 0;
          right: 0;
          height: ${this.itemHeight}px;
          display: flex;
          align-items: center;
          padding: 0 16px;
          border-bottom: 1px solid #eee;
        }
      &lt;/style&gt;
      &lt;div class=&quot;viewport&quot;&gt;&lt;/div&gt;
    `;

    this.viewport = this.shadowRoot.querySelector(&#039;.viewport&#039;);

    this.addEventListener(&#039;scroll&#039;, () =&gt; {
      this.scrollTop = this.scrollTop;
      this.renderVisibleItems();
    });
  }

  render() {
    if (!this.viewport) return;

    // Set total height
    const totalHeight = this.items.length * this.itemHeight;
    this.viewport.style.height = `${totalHeight}px`;

    this.renderVisibleItems();
  }

  renderVisibleItems() {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.min(
      startIndex + this.visibleCount,
      this.items.length
    );

    // Clear existing items
    this.viewport.innerHTML = &#039;&#039;;

    // Render only visible items
    for (let i = startIndex; i &lt; endIndex; i++) {
      const item = document.createElement(&#039;div&#039;);
      item.className = &#039;item&#039;;
      item.style.top = `${i * this.itemHeight}px`;
      item.textContent = this.items[i];

      this.viewport.appendChild(item);
    }
  }
}

customElements.define(&#039;virtual-list&#039;, VirtualList);</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">const list = document.createElement(&#039;virtual-list&#039;);
list.data = Array.from({ length: 10000 }, (_, i) =&gt; `Item ${i + 1}`);
list.style.height = &#039;400px&#039;;
document.body.appendChild(list);</code></pre>
<h3>Memoization</h3>
<p>Cache expensive computations:</p>
<pre><code class="language-javascript">class MemoizedComponent extends HTMLElement {
  constructor() {
    super();
    this.cache = new Map();
  }

  memoize(fn, keyFn) {
    return (...args) =&gt; {
      const key = keyFn ? keyFn(...args) : JSON.stringify(args);

      if (this.cache.has(key)) {
        return this.cache.get(key);
      }

      const result = fn(...args);
      this.cache.set(key, result);

      return result;
    };
  }

  computeExpensiveValue = this.memoize(
    (data) =&gt; {
      // Expensive computation
      console.log(&#039;Computing...&#039;);
      return data.reduce((acc, val) =&gt; acc + val.price, 0);
    },
    (data) =&gt; data.map(d =&gt; d.id).join(&#039;,&#039;)
  );

  connectedCallback() {
    const data = [
      { id: 1, price: 100 },
      { id: 2, price: 200 }
    ];

    // First call - computes
    console.log(this.computeExpensiveValue(data));

    // Second call - cached
    console.log(this.computeExpensiveValue(data));
  }
}</code></pre>
<h3>Debouncing and Throttling</h3>
<p>Limit expensive operations:</p>
<pre><code class="language-javascript">// lib/performance.js
export function debounce(fn, delay) {
  let timeoutId;

  return function(...args) {
    clearTimeout(timeoutId);

    timeoutId = setTimeout(() =&gt; {
      fn.apply(this, args);
    }, delay);
  };
}

export function throttle(fn, limit) {
  let inThrottle;

  return function(...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;

      setTimeout(() =&gt; {
        inThrottle = false;
      }, limit);
    }
  };
}

// Usage
class SearchBox extends HTMLElement {
  constructor() {
    super();

    // Debounce search - wait for user to stop typing
    this.handleSearch = debounce(this.search.bind(this), 300);

    // Throttle scroll - limit updates
    this.handleScroll = throttle(this.onScroll.bind(this), 100);
  }

  connectedCallback() {
    this.innerHTML = &#039;&lt;input type=&quot;search&quot; placeholder=&quot;Search...&quot;&gt;&#039;;

    this.querySelector(&#039;input&#039;).addEventListener(&#039;input&#039;, (e) =&gt; {
      this.handleSearch(e.target.value);
    });

    window.addEventListener(&#039;scroll&#039;, this.handleScroll);
  }

  search(query) {
    console.log(&#039;Searching for:&#039;, query);
    // Perform search
  }

  onScroll() {
    console.log(&#039;Scrolled&#039;);
    // Update UI based on scroll
  }
}</code></pre>
<h2>Summary</h2>
<p>This chapter explored advanced component patterns:</p>
<ul><li><strong>Compound Components</strong>: Components that work together as a cohesive unit</li>
<li><strong>Higher-Order Components</strong>: Mixins and decorators for code reuse</li>
<li><strong>Component Composition</strong>: Container/presentational pattern and render props</li>
<li><strong>Slots</strong>: Named slots, slot change detection, and conditional rendering</li>
<li><strong>Dynamic Loading</strong>: Lazy loading and viewport-based loading</li>
<li><strong>Performance</strong>: Virtual scrolling, memoization, debouncing, and throttling</li>
</ul>
These patterns enable you to build sophisticated, performant applications while keeping code maintainable and testable.
<hr>
<h2>Best Practices</h2>
<li><strong>Favor composition over inheritance</strong></li>
   - Build complex components from simple ones
   - Use slots for flexibility
   - Keep components focused
<li><strong>Use mixins for cross-cutting concerns</strong></li>
   - Observable behavior
   - Resize handling
   - Loading states
<li><strong>Separate logic from presentation</strong></li>
   - Container components handle data
   - Presentational components handle UI
   - Easier to test and reuse
<li><strong>Lazy load heavy components</strong></li>
   - Reduce initial bundle size
   - Load on demand or when visible
   - Show loading states
<li><strong>Optimize expensive operations</strong></li>
   - Memoize pure functions
   - Debounce user input
   - Throttle scroll/resize handlers
   - Use virtual scrolling for long lists
<li><strong>Keep performance in mind</strong></li>
   - Profile before optimizing
   - Measure impact of changes
   - Don't over-optimize prematurely
<hr>
<h2>Further Reading</h2>
<strong>For advanced patterns and optimization:</strong>
<ul><li><em>Building with LARC</em> Chapter 15: Advanced Patterns - Micro-frontends, plugin systems, middleware</li>
<li><em>Building with LARC</em> Chapter 12: Performance Optimization - Virtual scrolling, lazy loading, profiling</li>
<li><em>Building with LARC</em> Appendix E: Recipes and Patterns - Advanced component patterns</li>
</ul>
<div class="pagebreak"></div>
<h1>Business Logic Patterns</h1>
<p>In the previous chapters, we've learned how to build components, communicate via the PAN bus, and manage state. But when building real-world applications, you'll inevitably need to inject your own custom business logic: validation rules, pricing calculations, access control, analytics tracking, and countless other domain-specific concerns.</p>
<p>A common question developers ask when adopting LARC is: <em>"Where do I put my business logic?"</em> This chapter explores the architectural patterns for integrating business logic into LARC applications, helping you make informed decisions about code organization and separation of concerns.</p>
<h2>The Philosophy: Separation of Concerns</h2>
<p>LARC's architecture naturally encourages a clean separation between:</p>
<ul><li><strong>Components</strong>: UI and interaction concerns</li>
<li><strong>PAN Bus</strong>: Communication layer</li>
<li><strong>Business Logic</strong>: Domain rules and workflows</li>
</ul>
This separation isn't just academic—it makes your code:
<ul><li><strong>Testable</strong>: Logic can be tested independently of UI</li>
<li><strong>Maintainable</strong>: Changes to business rules don't require touching components</li>
<li><strong>Reusable</strong>: Logic can be shared across multiple components</li>
<li><strong>Flexible</strong>: Easy to modify workflows without refactoring components</li>
</ul>
Let's explore the patterns that make this possible.
<h2>Pattern 1: PAN Bus Listeners (Recommended)</h2>
<p>The most common and recommended approach is to create separate modules that listen to PAN bus events and implement your business logic. This pattern treats business logic as a <strong>first-class concern</strong>, separate from both UI components and state management.</p>
<h3>When to Use</h3>
<p>Use PAN bus listeners when you need to:</p>
<ul><li>Coordinate behavior across multiple components</li>
<li>Implement cross-cutting concerns (analytics, logging, validation)</li>
<li>Add business rules that aren't tied to a specific component</li>
<li>Keep components generic and reusable</li>
</ul>
<h3>Basic Implementation</h3>
<p>Let's build an e-commerce application where we need to enforce business rules around cart operations:</p>
<pre><code class="language-javascript">// business-logic/cart-rules.js
import { pan } from &#039;@larcjs/core&#039;;

class CartBusinessRules {
  constructor() {
    this.maxItemsPerOrder = 50;
    this.maxQuantityPerItem = 10;
  }

  init() {
    // Subscribe to cart events
    pan.subscribe(&#039;cart.item.add&#039;, this.handleItemAdd.bind(this));
    pan.subscribe(&#039;cart.item.update&#039;, this.handleItemUpdate.bind(this));
    pan.subscribe(&#039;cart.checkout.start&#039;, this.handleCheckout.bind(this));
  }

  async handleItemAdd(data) {
    console.log(&#039;Business rule: Validating item add&#039;, data);

    // Check current cart state
    const currentCart = await pan.request(&#039;cart.get&#039;);

    // Business Rule 1: Maximum items per order
    if (currentCart.items.length &gt;= this.maxItemsPerOrder) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;MAX_ITEMS_EXCEEDED&#039;,
        message: `Cannot add more than ${this.maxItemsPerOrder} items to cart`
      });
      return;
    }

    // Business Rule 2: Check inventory
    const available = await this.checkInventory(data.product.id);
    if (!available || available &lt; data.quantity) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;INSUFFICIENT_INVENTORY&#039;,
        message: &#039;This item is currently out of stock&#039;,
        product: data.product
      });
      return;
    }

    // Business Rule 3: Apply pricing
    const pricing = await this.calculatePrice(data.product, data.quantity);

    // All validations passed - allow the add and publish enriched data
    pan.publish(&#039;cart.item.validated&#039;, {
      ...data,
      pricing,
      timestamp: Date.now()
    });
  }

  async handleItemUpdate(data) {
    // Business Rule: Quantity limits
    if (data.quantity &gt; this.maxQuantityPerItem) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;MAX_QUANTITY_EXCEEDED&#039;,
        message: `Maximum ${this.maxQuantityPerItem} per item`
      });
      return;
    }

    // Check inventory for new quantity
    const available = await this.checkInventory(data.productId);
    if (available &lt; data.quantity) {
      pan.publish(&#039;cart.error&#039;, {
        code: &#039;INSUFFICIENT_INVENTORY&#039;,
        message: `Only ${available} available`,
        available
      });
      return;
    }

    pan.publish(&#039;cart.item.update.validated&#039;, data);
  }

  async handleCheckout(data) {
    // Business Rule: Minimum order value
    const cart = await pan.request(&#039;cart.get&#039;);
    const total = cart.items.reduce((sum, item) =&gt; sum + item.total, 0);

    if (total &lt; 10) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;MINIMUM_ORDER_NOT_MET&#039;,
        message: &#039;Minimum order value is $10&#039;,
        current: total,
        required: 10
      });
      return;
    }

    // Business Rule: User must be logged in
    const user = await pan.request(&#039;auth.user.get&#039;);
    if (!user) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;AUTH_REQUIRED&#039;,
        message: &#039;Please log in to continue&#039;
      });
      return;
    }

    pan.publish(&#039;checkout.validated&#039;, { cart, user });
  }

  async checkInventory(productId) {
    // In real app, this would call your backend
    const response = await fetch(`/api/inventory/${productId}`);
    const data = await response.json();
    return data.available;
  }

  async calculatePrice(product, quantity) {
    // Apply business logic: bulk discounts, promotions, etc.
    let unitPrice = product.price;

    // Bulk discount: 10% off for 5+ items
    if (quantity &gt;= 5) {
      unitPrice = unitPrice * 0.9;
    }

    // TODO: Check for active promotions
    // TODO: Apply user-specific pricing

    return {
      unitPrice,
      quantity,
      subtotal: unitPrice * quantity,
      discount: quantity &gt;= 5 ? (product.price - unitPrice) * quantity : 0
    };
  }
}

// Initialize and export
const cartRules = new CartBusinessRules();
export default cartRules;</code></pre>
<p>Now in your main application file:</p>
<pre><code class="language-javascript">// app.js
import { pan } from &#039;@larcjs/core&#039;;
import cartRules from &#039;./business-logic/cart-rules.js&#039;;

// Initialize business logic
cartRules.init();

// Your components just publish events - the business logic handles the rest
// No business logic in components themselves!</code></pre>
<p>Your components remain simple and focused on UI:</p>
<pre><code class="language-javascript">// components/product-card.js
class ProductCard extends HTMLElement {
  // ... component setup ...

  handleAddToCart() {
    // Just publish the event - business logic will validate
    pan.publish(&#039;cart.item.add&#039;, {
      product: this.product,
      quantity: this.quantity
    });

    // Show optimistic UI
    this.showAddingState();
  }

  connectedCallback() {
    super.connectedCallback();

    // Listen for validation results
    this.unsubscribers = [
      pan.subscribe(&#039;cart.item.validated&#039;, (data) =&gt; {
        if (data.product.id === this.product.id) {
          this.showSuccess();
        }
      }),

      pan.subscribe(&#039;cart.error&#039;, (error) =&gt; {
        this.showError(error.message);
      })
    ];
  }
}</code></pre>
<h3>Advantages</h3>
<p>This pattern provides several key benefits:</p>
<li><strong>Separation of Concerns</strong>: Components handle UI, business logic modules handle rules</li>
<li><strong>Easy Testing</strong>: Test business logic without rendering components</li>
<li><strong>Centralized Rules</strong>: All cart rules in one place, easy to modify</li>
<li><strong>Reusable</strong>: Multiple components can trigger the same logic</li>
<li><strong>Flexible</strong>: Easy to add, remove, or modify rules</li>
<h3>Advanced: Composable Business Logic</h3>
<p>For larger applications, you can compose multiple business logic modules:</p>
<pre><code class="language-javascript">// business-logic/index.js
import { pan } from &#039;@larcjs/core&#039;;
import cartRules from &#039;./cart-rules.js&#039;;
import pricingRules from &#039;./pricing-rules.js&#039;;
import inventoryRules from &#039;./inventory-rules.js&#039;;
import analyticsRules from &#039;./analytics-rules.js&#039;;

export function initBusinessLogic() {
  console.log(&#039;Initializing business logic...&#039;);

  // Initialize all business logic modules
  cartRules.init();
  pricingRules.init();
  inventoryRules.init();
  analyticsRules.init();

  console.log(&#039;Business logic ready&#039;);
}</code></pre>
<pre><code class="language-javascript">// app.js
import { initBusinessLogic } from &#039;./business-logic/index.js&#039;;

// Single call to initialize all business logic
initBusinessLogic();</code></pre>
<h2>Pattern 2: Extending Components</h2>
<p>Sometimes you need to add business logic directly to a component, especially when:</p>
<ul><li>The logic is specific to one component type</li>
<li>You need to override component behavior</li>
<li>You're creating specialized versions of generic components</li>
</ul>
<h3>When to Use</h3>
<p>Use component extension when:</p>
<ul><li>Logic is tightly coupled to component rendering</li>
<li>You need access to component internals (Shadow DOM, private methods)</li>
<li>Creating specialized variants of base components</li>
<li>Logic doesn't need to be shared across different component types</li>
</ul>
<h3>Implementation</h3>
<p>Let's extend a generic product card with business-specific behavior:</p>
<pre><code class="language-javascript">// components/base/product-card.js
export class ProductCard extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        /* Base styles */
      &lt;/style&gt;
      &lt;div class=&quot;card&quot;&gt;
        &lt;img src=&quot;${this.product.image}&quot; alt=&quot;${this.product.name}&quot;&gt;
        &lt;h3&gt;${this.product.name}&lt;/h3&gt;
        &lt;p class=&quot;price&quot;&gt;${this.formatPrice(this.product.price)}&lt;/p&gt;
        &lt;button class=&quot;add-to-cart&quot;&gt;Add to Cart&lt;/button&gt;
      &lt;/div&gt;
    `;

    this.shadowRoot.querySelector(&#039;.add-to-cart&#039;)
      .addEventListener(&#039;click&#039;, () =&gt; this.handleAddToCart());
  }

  handleAddToCart() {
    pan.publish(&#039;cart.item.add&#039;, {
      product: this.product,
      quantity: 1
    });
  }

  formatPrice(price) {
    return `$${price.toFixed(2)}`;
  }

  get product() {
    return JSON.parse(this.getAttribute(&#039;product&#039;));
  }
}

customElements.define(&#039;product-card&#039;, ProductCard);</code></pre>
<p>Now extend it with business-specific logic:</p>
<pre><code class="language-javascript">// components/premium-product-card.js
import { ProductCard } from &#039;./base/product-card.js&#039;;

export class PremiumProductCard extends ProductCard {
  connectedCallback() {
    super.connectedCallback();

    // Add business-specific subscriptions
    this._unsubscribers = [
      pan.subscribe(&#039;pricing.update&#039;, this.handlePriceUpdate.bind(this)),
      pan.subscribe(&#039;user.tier.changed&#039;, this.handleTierChange.bind(this))
    ];

    // Initialize premium features
    this.loadMemberPricing();
  }

  async loadMemberPricing() {
    const user = await pan.request(&#039;auth.user.get&#039;);
    if (user?.tier === &#039;premium&#039;) {
      this.applyPremiumDiscount();
    }
  }

  applyPremiumDiscount() {
    // Business Rule: 15% discount for premium members
    const discount = 0.15;
    const originalPrice = this.product.price;
    const discountedPrice = originalPrice * (1 - discount);

    this.product.price = discountedPrice;
    this.product.originalPrice = originalPrice;

    this.render(); // Re-render with new price
  }

  render() {
    // Call parent render
    super.render();

    // Add premium badge if applicable
    if (this.product.originalPrice) {
      this.addPremiumBadge();
    }
  }

  addPremiumBadge() {
    const badge = document.createElement(&#039;div&#039;);
    badge.className = &#039;premium-badge&#039;;
    badge.innerHTML = `
      &lt;style&gt;
        .premium-badge {
          position: absolute;
          top: 10px;
          right: 10px;
          background: gold;
          color: black;
          padding: 5px 10px;
          border-radius: 3px;
          font-weight: bold;
        }
        .original-price {
          text-decoration: line-through;
          color: #999;
          font-size: 0.9em;
        }
      &lt;/style&gt;
      &lt;span&gt;Premium Member&lt;/span&gt;
      &lt;div class=&quot;original-price&quot;&gt;
        ${this.formatPrice(this.product.originalPrice)}
      &lt;/div&gt;
    `;

    this.shadowRoot.querySelector(&#039;.card&#039;).prepend(badge);
  }

  async handleAddToCart() {
    // Business validation before adding
    const canAddPremiumItem = await this.validatePremiumAccess();

    if (!canAddPremiumItem) {
      pan.publish(&#039;app.error&#039;, {
        message: &#039;Premium membership required for this product&#039;
      });
      return;
    }

    // Track premium conversions
    this.trackPremiumConversion();

    // Call parent behavior
    super.handleAddToCart();
  }

  async validatePremiumAccess() {
    if (!this.product.premiumOnly) return true;

    const user = await pan.request(&#039;auth.user.get&#039;);
    return user?.tier === &#039;premium&#039;;
  }

  trackPremiumConversion() {
    pan.publish(&#039;analytics.track&#039;, {
      event: &#039;premium_product_add_to_cart&#039;,
      product: this.product.id,
      price: this.product.price,
      discount: this.product.originalPrice - this.product.price
    });
  }

  handlePriceUpdate(data) {
    if (data.productId === this.product.id) {
      this.product.price = data.newPrice;
      this.render();
    }
  }

  handleTierChange(data) {
    // User tier changed - recalculate pricing
    this.loadMemberPricing();
  }

  disconnectedCallback() {
    // Clean up subscriptions
    this._unsubscribers.forEach(unsub =&gt; unsub());
    super.disconnectedCallback?.();
  }
}

customElements.define(&#039;premium-product-card&#039;, PremiumProductCard);</code></pre>
<h3>When This Makes Sense</h3>
<p>Component extension works well when:</p>
<li><strong>The logic changes how the component renders or behaves</strong></li>
<li><strong>You need multiple variants of a base component</strong> (premium, free, guest, etc.)</li>
<li><strong>Business logic is closely tied to component lifecycle</strong></li>
<p>However, be cautious: overuse of extension can lead to:</p>
<ul><li>Tight coupling between business logic and UI</li>
<li>Harder to test business rules independently</li>
<li>Duplication if multiple components need the same logic</li>
</ul>
<h2>Pattern 3: Wrapper Components</h2>
<p>Wrapper components let you add behavior around existing components without modifying them. This is useful when you want to:</p>
<ul><li>Add behavior to third-party components</li>
<li>Keep base components pristine</li>
<li>Compose behaviors dynamically</li>
</ul>
<h3>Implementation</h3>
<pre><code class="language-javascript">// components/business-wrapper.js
class BusinessWrapper extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });

    // Intercept events from slotted content
    this.addEventListener(&#039;add-to-cart&#039;, this.handleBusinessLogic.bind(this));

    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
        }
        .validation-message {
          color: red;
          padding: 10px;
          background: #fee;
          border-radius: 4px;
          margin-bottom: 10px;
        }
        .validation-message.hidden {
          display: none;
        }
      &lt;/style&gt;
      &lt;div class=&quot;validation-message hidden&quot;&gt;&lt;/div&gt;
      &lt;slot&gt;&lt;/slot&gt;
    `;
  }

  async handleBusinessLogic(e) {
    // Stop the event from propagating immediately
    e.stopPropagation();

    // Apply business validation
    const validation = await this.validateBusinessRules(e.detail);

    if (!validation.valid) {
      this.showError(validation.message);
      return;
    }

    // Validation passed - let the event continue
    pan.publish(&#039;cart.item.add&#039;, e.detail);
  }

  async validateBusinessRules(data) {
    // Check user eligibility
    const user = await pan.request(&#039;auth.user.get&#039;);
    if (!user) {
      return {
        valid: false,
        message: &#039;Please log in to add items to cart&#039;
      };
    }

    // Check age restriction
    if (data.product.ageRestricted &amp;&amp; user.age &lt; 21) {
      return {
        valid: false,
        message: &#039;This product requires age verification (21+)&#039;
      };
    }

    // Check geographic restriction
    if (data.product.geoRestricted &amp;&amp; !this.isAllowedRegion(user.region)) {
      return {
        valid: false,
        message: &#039;This product is not available in your region&#039;
      };
    }

    return { valid: true };
  }

  isAllowedRegion(region) {
    // Business logic for regional restrictions
    const allowedRegions = [&#039;US&#039;, &#039;CA&#039;, &#039;UK&#039;];
    return allowedRegions.includes(region);
  }

  showError(message) {
    const errorEl = this.shadowRoot.querySelector(&#039;.validation-message&#039;);
    errorEl.textContent = message;
    errorEl.classList.remove(&#039;hidden&#039;);

    setTimeout(() =&gt; {
      errorEl.classList.add(&#039;hidden&#039;);
    }, 5000);
  }
}

customElements.define(&#039;business-wrapper&#039;, BusinessWrapper);</code></pre>
<p>Usage:</p>
<pre><code class="language-html">&lt;!-- Wrap any component with business logic --&gt;
&lt;business-wrapper&gt;
  &lt;product-card product-id=&quot;123&quot;&gt;&lt;/product-card&gt;
&lt;/business-wrapper&gt;

&lt;business-wrapper&gt;
  &lt;quick-buy-button product-id=&quot;456&quot;&gt;&lt;/quick-buy-button&gt;
&lt;/business-wrapper&gt;</code></pre>
<p>The wrapper intercepts events and applies business logic <strong>without modifying</strong> the wrapped components.</p>
<h2>Pattern 4: Behavior Mixins</h2>
<p>Mixins let you share behavior across multiple component types. This is useful for cross-cutting concerns like analytics, logging, or validation.</p>
<h3>Implementation</h3>
<pre><code class="language-javascript">// mixins/analytics-mixin.js
export const AnalyticsMixin = (BaseClass) =&gt; class extends BaseClass {
  track(event, data = {}) {
    pan.publish(&#039;analytics.track&#039;, {
      event,
      data,
      component: this.tagName.toLowerCase(),
      timestamp: Date.now(),
      ...this.getAnalyticsContext()
    });
  }

  trackInteraction(element, action) {
    this.track(`${element}.${action}`, {
      element,
      action
    });
  }

  getAnalyticsContext() {
    // Add common context to all analytics events
    return {
      page: window.location.pathname,
      referrer: document.referrer
    };
  }

  connectedCallback() {
    super.connectedCallback?.();
    this.track(&#039;component.mounted&#039;, { id: this.id });
  }

  disconnectedCallback() {
    this.track(&#039;component.unmounted&#039;, { id: this.id });
    super.disconnectedCallback?.();
  }
};</code></pre>
<pre><code class="language-javascript">// mixins/validation-mixin.js
export const ValidationMixin = (BaseClass) =&gt; class extends BaseClass {
  async validate(data, rules) {
    const errors = [];

    for (const [field, rule] of Object.entries(rules)) {
      const value = data[field];

      if (rule.required &amp;&amp; !value) {
        errors.push(`${field} is required`);
      }

      if (rule.min &amp;&amp; value &lt; rule.min) {
        errors.push(`${field} must be at least ${rule.min}`);
      }

      if (rule.max &amp;&amp; value &gt; rule.max) {
        errors.push(`${field} must be at most ${rule.max}`);
      }

      if (rule.pattern &amp;&amp; !rule.pattern.test(value)) {
        errors.push(`${field} is invalid`);
      }

      if (rule.custom) {
        const customError = await rule.custom(value, data);
        if (customError) errors.push(customError);
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  showValidationErrors(errors) {
    pan.publish(&#039;validation.errors&#039;, {
      component: this.tagName.toLowerCase(),
      errors
    });
  }
};</code></pre>
<p>Use mixins to compose behavior:</p>
<pre><code class="language-javascript">import { AnalyticsMixin } from &#039;./mixins/analytics-mixin.js&#039;;
import { ValidationMixin } from &#039;./mixins/validation-mixin.js&#039;;

class CheckoutForm extends ValidationMixin(AnalyticsMixin(HTMLElement)) {
  async handleSubmit() {
    // Use validation from mixin
    const validation = await this.validate(this.formData, {
      email: {
        required: true,
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      },
      cardNumber: {
        required: true,
        custom: async (value) =&gt; {
          const valid = await this.validateCard(value);
          return valid ? null : &#039;Invalid card number&#039;;
        }
      }
    });

    if (!validation.valid) {
      this.showValidationErrors(validation.errors);
      return;
    }

    // Use analytics from mixin
    this.track(&#039;checkout.submit&#039;, {
      amount: this.total,
      items: this.items.length
    });

    // Process checkout
    this.processOrder();
  }
}</code></pre>
<h2>Pattern 5: Service Layer</h2>
<p>For complex business logic, create a dedicated service layer that components and PAN listeners can both use:</p>
<pre><code class="language-javascript">// services/pricing-service.js
class PricingService {
  async calculatePrice(product, quantity, user) {
    let price = product.basePrice;

    // Business Rule: Volume discounts
    if (quantity &gt;= 10) price *= 0.85;
    else if (quantity &gt;= 5) price *= 0.90;

    // Business Rule: Member discounts
    if (user?.tier === &#039;premium&#039;) {
      price *= 0.85;
    } else if (user?.tier === &#039;gold&#039;) {
      price *= 0.90;
    }

    // Business Rule: Active promotions
    const promotions = await this.getActivePromotions(product.id);
    for (const promo of promotions) {
      price = this.applyPromotion(price, promo);
    }

    return {
      unitPrice: price,
      quantity,
      subtotal: price * quantity,
      savings: (product.basePrice - price) * quantity
    };
  }

  async getActivePromotions(productId) {
    const response = await fetch(`/api/promotions?product=${productId}`);
    return response.json();
  }

  applyPromotion(price, promotion) {
    if (promotion.type === &#039;percentage&#039;) {
      return price * (1 - promotion.value / 100);
    } else if (promotion.type === &#039;fixed&#039;) {
      return Math.max(0, price - promotion.value);
    }
    return price;
  }

  async getTax(subtotal, region) {
    const taxRates = {
      &#039;CA&#039;: 0.0725,
      &#039;NY&#039;: 0.08,
      &#039;TX&#039;: 0.0625
    };

    return subtotal * (taxRates[region] || 0);
  }
}

export default new PricingService();</code></pre>
<p>Use the service from both components and PAN listeners:</p>
<pre><code class="language-javascript">// In a component
import pricingService from &#039;./services/pricing-service.js&#039;;

class ProductCard extends HTMLElement {
  async updatePrice() {
    const user = await pan.request(&#039;auth.user.get&#039;);
    const pricing = await pricingService.calculatePrice(
      this.product,
      this.quantity,
      user
    );

    this.displayPrice(pricing);
  }
}</code></pre>
<pre><code class="language-javascript">// In business logic
import pricingService from &#039;./services/pricing-service.js&#039;;

class CartBusinessLogic {
  init() {
    pan.subscribe(&#039;cart.item.add&#039;, async (data) =&gt; {
      const user = await pan.request(&#039;auth.user.get&#039;);
      const pricing = await pricingService.calculatePrice(
        data.product,
        data.quantity,
        user
      );

      pan.publish(&#039;cart.item.priced&#039;, { ...data, pricing });
    });
  }
}</code></pre>
<h2>Decision Matrix</h2>
<p>Here's how to choose the right pattern:</p>
<p>| Scenario | Recommended Pattern | Why |
|----------|-------------------|-----|
| Cross-component coordination | PAN Bus Listeners | Decoupled, flexible |
| Analytics/logging | Mixins | Reusable across all components |
| Validation before actions | PAN Bus Listeners | Centralized rules |
| Component-specific UI logic | Extend Component | Access to internals |
| Add behavior to third-party components | Wrapper | Non-invasive |
| Complex business calculations | Service Layer | Testable, reusable |
| Component variants (premium, free) | Extend Component | Clear inheritance |
| Feature flags / A-B testing | Wrapper or PAN Listeners | Easy to toggle |</p>
<h2>Real-World Example: E-Commerce Checkout</h2>
<p>Let's see how these patterns work together in a complete checkout flow:</p>
<pre><code class="language-javascript">// services/checkout-service.js
class CheckoutService {
  async processOrder(cart, paymentInfo, shippingInfo) {
    // Complex business logic
    const pricing = await this.calculateFinalPricing(cart);
    const shipping = await this.calculateShipping(cart, shippingInfo);
    const tax = await this.calculateTax(pricing.subtotal, shippingInfo.state);

    return {
      items: cart.items,
      pricing,
      shipping,
      tax,
      total: pricing.subtotal + shipping.cost + tax
    };
  }

  async calculateFinalPricing(cart) {
    // Apply all discounts, coupons, etc.
    let subtotal = 0;
    let savings = 0;

    for (const item of cart.items) {
      const itemPricing = await pricingService.calculatePrice(
        item.product,
        item.quantity,
        cart.user
      );
      subtotal += itemPricing.subtotal;
      savings += itemPricing.savings;
    }

    return { subtotal, savings };
  }

  async calculateShipping(cart, shippingInfo) {
    // Shipping business rules
    if (cart.total &gt;= 50) {
      return { method: &#039;standard&#039;, cost: 0, freeShipping: true };
    }

    const weight = cart.items.reduce((sum, item) =&gt; sum + item.weight, 0);
    const zone = this.getShippingZone(shippingInfo.state);

    return {
      method: &#039;standard&#039;,
      cost: this.calculateShippingCost(weight, zone),
      freeShipping: false
    };
  }

  calculateShippingCost(weight, zone) {
    const baseRate = { 1: 5, 2: 7, 3: 10 };
    return baseRate[zone] + (weight &gt; 5 ? (weight - 5) * 0.5 : 0);
  }

  getShippingZone(state) {
    const zones = {
      1: [&#039;CA&#039;, &#039;OR&#039;, &#039;WA&#039;],
      2: [&#039;NV&#039;, &#039;AZ&#039;, &#039;UT&#039;, &#039;ID&#039;],
      3: [] // All other states
    };

    for (const [zone, states] of Object.entries(zones)) {
      if (states.includes(state)) return parseInt(zone);
    }
    return 3;
  }

  async calculateTax(subtotal, state) {
    return pricingService.getTax(subtotal, state);
  }
}

export default new CheckoutService();</code></pre>
<pre><code class="language-javascript">// business-logic/checkout-rules.js
import checkoutService from &#039;../services/checkout-service.js&#039;;

class CheckoutBusinessRules {
  init() {
    pan.subscribe(&#039;checkout.start&#039;, this.handleCheckoutStart.bind(this));
    pan.subscribe(&#039;checkout.submit&#039;, this.handleCheckoutSubmit.bind(this));
  }

  async handleCheckoutStart(data) {
    // Business validations
    const cart = await pan.request(&#039;cart.get&#039;);
    const user = await pan.request(&#039;auth.user.get&#039;);

    // Validation 1: Cart not empty
    if (!cart.items.length) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;EMPTY_CART&#039;,
        message: &#039;Your cart is empty&#039;
      });
      return;
    }

    // Validation 2: User logged in
    if (!user) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;AUTH_REQUIRED&#039;,
        message: &#039;Please log in to continue&#039;
      });
      return;
    }

    // Validation 3: Inventory check
    for (const item of cart.items) {
      const available = await this.checkInventory(item.product.id);
      if (available &lt; item.quantity) {
        pan.publish(&#039;checkout.error&#039;, {
          code: &#039;INSUFFICIENT_INVENTORY&#039;,
          message: `Only ${available} of &quot;${item.product.name}&quot; available`,
          item
        });
        return;
      }
    }

    // All validations passed
    pan.publish(&#039;checkout.validated&#039;, { cart, user });
  }

  async handleCheckoutSubmit(data) {
    try {
      // Process order through service
      const order = await checkoutService.processOrder(
        data.cart,
        data.paymentInfo,
        data.shippingInfo
      );

      // Submit to backend
      const response = await fetch(&#039;/api/orders&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify(order)
      });

      if (!response.ok) {
        throw new Error(&#039;Order submission failed&#039;);
      }

      const result = await response.json();

      // Success
      pan.publish(&#039;checkout.success&#039;, {
        orderId: result.orderId,
        order: result
      });

      // Clear cart
      pan.publish(&#039;cart.clear&#039;);

    } catch (error) {
      pan.publish(&#039;checkout.error&#039;, {
        code: &#039;SUBMISSION_FAILED&#039;,
        message: &#039;Unable to process order. Please try again.&#039;,
        error
      });
    }
  }

  async checkInventory(productId) {
    const response = await fetch(`/api/inventory/${productId}`);
    const data = await response.json();
    return data.available;
  }
}

export default new CheckoutBusinessRules();</code></pre>
<p>The checkout component stays simple:</p>
<pre><code class="language-javascript">// components/checkout-form.js
class CheckoutForm extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: &#039;open&#039; });
    this.render();
    this.attachEventListeners();
    this.subscribeToEvents();
  }

  subscribeToEvents() {
    this._unsubscribers = [
      pan.subscribe(&#039;checkout.validated&#039;, () =&gt; {
        this.showCheckoutForm();
      }),

      pan.subscribe(&#039;checkout.error&#039;, (error) =&gt; {
        this.showError(error.message);
      }),

      pan.subscribe(&#039;checkout.success&#039;, (data) =&gt; {
        this.showSuccess(data.orderId);
      })
    ];
  }

  handleSubmit(e) {
    e.preventDefault();

    // Just collect data and publish - business logic handles the rest
    pan.publish(&#039;checkout.submit&#039;, {
      cart: this.cart,
      paymentInfo: this.getPaymentInfo(),
      shippingInfo: this.getShippingInfo()
    });

    this.showProcessing();
  }

  // UI methods only - no business logic
  showCheckoutForm() { /* ... */ }
  showError(message) { /* ... */ }
  showSuccess(orderId) { /* ... */ }
  showProcessing() { /* ... */ }
}</code></pre>
<h2>Testing Business Logic</h2>
<p>One of the biggest advantages of separating business logic is testability. Here's how to test each pattern:</p>
<h3>Testing PAN Bus Listeners</h3>
<pre><code class="language-javascript">// __tests__/cart-rules.test.js
import { describe, it, expect, beforeEach, vi } from &#039;vitest&#039;;
import { pan } from &#039;@larcjs/core&#039;;
import cartRules from &#039;../business-logic/cart-rules.js&#039;;

describe(&#039;Cart Business Rules&#039;, () =&gt; {
  beforeEach(() =&gt; {
    // Reset PAN bus between tests
    pan.clear();
    cartRules.init();
  });

  it(&#039;should reject adding more than max items&#039;, async () =&gt; {
    // Mock cart with max items
    pan.respond(&#039;cart.get&#039;, () =&gt; ({
      items: new Array(50).fill({})
    }));

    const errorHandler = vi.fn();
    pan.subscribe(&#039;cart.error&#039;, errorHandler);

    // Try to add another item
    await pan.publish(&#039;cart.item.add&#039;, {
      product: { id: 1, name: &#039;Test&#039; },
      quantity: 1
    });

    expect(errorHandler).toHaveBeenCalledWith({
      code: &#039;MAX_ITEMS_EXCEEDED&#039;,
      message: expect.stringContaining(&#039;50 items&#039;)
    });
  });

  it(&#039;should apply bulk discount for 5+ items&#039;, async () =&gt; {
    const validated = vi.fn();
    pan.subscribe(&#039;cart.item.validated&#039;, validated);

    await pan.publish(&#039;cart.item.add&#039;, {
      product: { id: 1, name: &#039;Test&#039;, price: 100 },
      quantity: 5
    });

    expect(validated).toHaveBeenCalledWith(
      expect.objectContaining({
        pricing: expect.objectContaining({
          unitPrice: 90, // 10% discount
          discount: 50
        })
      })
    );
  });
});</code></pre>
<h3>Testing Services</h3>
<pre><code class="language-javascript">// __tests__/pricing-service.test.js
import { describe, it, expect } from &#039;vitest&#039;;
import pricingService from &#039;../services/pricing-service.js&#039;;

describe(&#039;Pricing Service&#039;, () =&gt; {
  it(&#039;should apply volume discount&#039;, async () =&gt; {
    const product = { basePrice: 100 };
    const pricing = await pricingService.calculatePrice(product, 10, null);

    expect(pricing.unitPrice).toBe(85); // 15% off for 10+
    expect(pricing.subtotal).toBe(850);
  });

  it(&#039;should stack member and volume discounts&#039;, async () =&gt; {
    const product = { basePrice: 100 };
    const user = { tier: &#039;premium&#039; };

    const pricing = await pricingService.calculatePrice(product, 10, user);

    // 15% volume + 15% premium = 72.25
    expect(pricing.unitPrice).toBe(72.25);
  });
});</code></pre>
<h2>Best Practices</h2>
<h3>1. Keep Components Dumb</h3>
<p>Components should focus on UI and user interaction. They publish events but don't implement business rules.</p>
<strong>Good:</strong>
<pre><code class="language-javascript">handleAddToCart() {
  pan.publish(&#039;cart.item.add&#039;, { product: this.product });
}</code></pre>
<strong>Bad:</strong>
<pre><code class="language-javascript">async handleAddToCart() {
  // Business logic in component - hard to test and reuse
  const inventory = await fetch(&#039;/api/inventory&#039;);
  if (inventory &lt; this.quantity) {
    alert(&#039;Out of stock&#039;);
    return;
  }

  const user = await fetch(&#039;/api/user&#039;);
  if (user.age &lt; 21 &amp;&amp; this.product.ageRestricted) {
    alert(&#039;Age restricted&#039;);
    return;
  }

  // ... more business logic
}</code></pre>
<h3>2. Use Services for Complex Logic</h3>
<p>If business logic involves multiple steps, calculations, or external APIs, put it in a service:</p>
<pre><code class="language-javascript">// Good: Service handles complexity
const pricing = await pricingService.calculatePrice(product, quantity, user);

// Bad: Business logic scattered across components and PAN listeners
const basePrice = product.price;
const volumeDiscount = quantity &gt;= 10 ? 0.15 : 0;
const memberDiscount = user?.tier === &#039;premium&#039; ? 0.15 : 0;
// ... etc</code></pre>
<h3>3. Make Business Logic Observable</h3>
<p>Use PAN bus to make business logic transparent:</p>
<pre><code class="language-javascript">class OrderProcessor {
  async processOrder(order) {
    pan.publish(&#039;order.processing.start&#039;, { orderId: order.id });

    try {
      await this.validateOrder(order);
      pan.publish(&#039;order.validated&#039;, { orderId: order.id });

      await this.chargePayment(order);
      pan.publish(&#039;order.charged&#039;, { orderId: order.id });

      await this.createShipment(order);
      pan.publish(&#039;order.shipped&#039;, { orderId: order.id });

      pan.publish(&#039;order.complete&#039;, { orderId: order.id });
    } catch (error) {
      pan.publish(&#039;order.failed&#039;, { orderId: order.id, error });
    }
  }
}</code></pre>
<p>Now other parts of your app can react to these events (analytics, notifications, UI updates, etc.).</p>
<h3>4. Document Business Rules</h3>
<p>Make business rules explicit and documented:</p>
<pre><code class="language-javascript">/**
 * Shopping Cart Business Rules
 *
 * 1. Maximum 50 items per order
 * 2. Maximum 10 quantity per item
 * 3. Free shipping over $50
 * 4. Volume discounts:
 *    - 5-9 items: 10% off
 *    - 10+ items: 15% off
 * 5. Member discounts:
 *    - Premium: 15% off
 *    - Gold: 10% off
 * 6. Minimum order value: $10
 */
class CartBusinessRules {
  // Implementation
}</code></pre>
<h3>5. Use Feature Flags</h3>
<p>Make business logic toggleable:</p>
<pre><code class="language-javascript">class CheckoutRules {
  constructor() {
    this.features = {
      guestCheckout: true,
      expressCheckout: false,
      digitalWallet: true
    };
  }

  async handleCheckout(data) {
    if (!this.features.guestCheckout &amp;&amp; !data.user) {
      pan.publish(&#039;checkout.error&#039;, {
        message: &#039;Account required for checkout&#039;
      });
      return;
    }

    // ... rest of logic
  }
}</code></pre>
<h2>Summary</h2>
<p>When integrating business logic into LARC applications:</p>
<li><strong>Default to PAN Bus listeners</strong> for most business logic - it's decoupled, testable, and flexible</li>
<li><strong>Use services</strong> for complex calculations and workflows</li>
<li><strong>Extend components</strong> only when logic is tightly coupled to UI</li>
<li><strong>Use mixins</strong> for cross-cutting concerns like analytics</li>
<li><strong>Wrap components</strong> when adding behavior to third-party code</li>
<li><strong>Keep components dumb</strong> - they publish events, business logic handles the rest</li>
<p>This separation of concerns makes your application:</p>
<ul><li><strong>Easier to test</strong> - business logic without rendering components</li>
<li><strong>More maintainable</strong> - business rules in one place</li>
<li><strong>More flexible</strong> - easy to change rules without touching UI</li>
<li><strong>More reusable</strong> - logic can be shared across components</li>
</ul>
In the next chapter, we'll explore routing and navigation, building on these patterns to create complete single-page applications.
<hr>
<h2>Further Reading</h2>
<strong>For business logic and architecture patterns:</strong>
<ul><li><em>Building with LARC</em> Chapter 15: Advanced Patterns - Architecture patterns and middleware</li>
<li><em>Building with LARC</em> Chapter 4: State Management - State management strategies</li>
<li><em>Building with LARC</em> Appendix E: Recipes and Patterns - Design patterns and anti-patterns</li>
</ul>
<div class="pagebreak"></div>
<h1>Routing and Navigation</h1>
<p>Client-side routing enables single-page applications (SPAs) to feel like multi-page websites without full page reloads. LARC provides routing through web standards and the PAN bus, keeping things simple and framework-free.</p>
<h2>Client-Side Routing Basics</h2>
<p>Client-side routing intercepts link clicks and updates the URL without reloading:</p>
<pre><code class="language-javascript">// lib/router.js
class Router {
  constructor() {
    this.routes = new Map();
    this.currentRoute = null;

    // Intercept link clicks
    document.addEventListener(&#039;click&#039;, (e) =&gt; {
      if (e.target.matches(&#039;a[href^=&quot;/&quot;]&#039;)) {
        e.preventDefault();
        this.navigate(e.target.getAttribute(&#039;href&#039;));
      }
    });

    // Handle browser back/forward
    window.addEventListener(&#039;popstate&#039;, () =&gt; {
      this.handleRoute(window.location.pathname);
    });
  }

  register(path, handler) {
    this.routes.set(path, handler);
  }

  navigate(path, state = {}) {
    window.history.pushState(state, &#039;&#039;, path);
    this.handleRoute(path);

    // Publish navigation event
    pan.publish(&#039;router.navigated&#039;, { path, state });
  }

  handleRoute(path) {
    // Find matching route
    for (const [pattern, handler] of this.routes) {
      const params = this.matchRoute(pattern, path);
      if (params) {
        this.currentRoute = { path, pattern, params };
        handler(params);
        return;
      }
    }

    // 404 - no match
    pan.publish(&#039;router.not-found&#039;, { path });
  }

  matchRoute(pattern, path) {
    // Simple pattern matching
    const patternParts = pattern.split(&#039;/&#039;).filter(Boolean);
    const pathParts = path.split(&#039;/&#039;).filter(Boolean);

    if (patternParts.length !== pathParts.length) {
      return null;
    }

    const params = {};

    for (let i = 0; i &lt; patternParts.length; i++) {
      const patternPart = patternParts[i];
      const pathPart = pathParts[i];

      if (patternPart.startsWith(&#039;:&#039;)) {
        // Dynamic segment
        params[patternPart.slice(1)] = pathPart;
      } else if (patternPart !== pathPart) {
        // Mismatch
        return null;
      }
    }

    return params;
  }

  start() {
    this.handleRoute(window.location.pathname);
  }
}

export const router = new Router();</code></pre>
<strong>Usage:</strong>
<pre><code class="language-javascript">import { router } from &#039;./lib/router.js&#039;;

// Register routes
router.register(&#039;/&#039;, () =&gt; {
  document.getElementById(&#039;app&#039;).innerHTML = &#039;&lt;home-page&gt;&lt;/home-page&gt;&#039;;
});

router.register(&#039;/about&#039;, () =&gt; {
  document.getElementById(&#039;app&#039;).innerHTML = &#039;&lt;about-page&gt;&lt;/about-page&gt;&#039;;
});

router.register(&#039;/users/:id&#039;, (params) =&gt; {
  const page = document.createElement(&#039;user-page&#039;);
  page.setAttribute(&#039;user-id&#039;, params.id);
  document.getElementById(&#039;app&#039;).innerHTML = &#039;&#039;;
  document.getElementById(&#039;app&#039;).appendChild(page);
});

// Start router
router.start();</code></pre>
<h2>The pan-router Component</h2>
<p>LARC provides a declarative router component:</p>
<pre><code class="language-html">&lt;pan-router&gt;
  &lt;pan-route path=&quot;/&quot; component=&quot;home-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/about&quot; component=&quot;about-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/users/:id&quot; component=&quot;user-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/posts/:postId/comments/:commentId&quot; component=&quot;comment-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;*&quot; component=&quot;not-found-page&quot;&gt;&lt;/pan-route&gt;
&lt;/pan-router&gt;</code></pre>
<strong>Implementation:</strong>
<pre><code class="language-javascript">class PanRouter extends HTMLElement {
  connectedCallback() {
    this.routes = Array.from(this.querySelectorAll(&#039;pan-route&#039;)).map(route =&gt; ({
      path: route.getAttribute(&#039;path&#039;),
      component: route.getAttribute(&#039;component&#039;),
      guard: route.getAttribute(&#039;guard&#039;)
    }));

    // Create outlet
    this.outlet = document.createElement(&#039;div&#039;);
    this.outlet.className = &#039;router-outlet&#039;;
    this.appendChild(this.outlet);

    // Listen for navigation
    pan.subscribe(&#039;router.navigate&#039;, ({ path, params }) =&gt; {
      this.navigate(path, params);
    });

    // Handle browser navigation
    window.addEventListener(&#039;popstate&#039;, () =&gt; {
      this.handleRoute(window.location.pathname);
    });

    // Intercept links
    document.addEventListener(&#039;click&#039;, (e) =&gt; {
      const link = e.target.closest(&#039;a[href^=&quot;/&quot;]&#039;);
      if (link) {
        e.preventDefault();
        this.navigate(link.getAttribute(&#039;href&#039;));
      }
    });

    // Initial route
    this.handleRoute(window.location.pathname);
  }

  navigate(path, params = {}) {
    window.history.pushState(params, &#039;&#039;, path);
    this.handleRoute(path);
  }

  async handleRoute(path) {
    // Find matching route
    for (const route of this.routes) {
      const params = this.matchRoute(route.path, path);

      if (params) {
        // Check route guard
        if (route.guard) {
          const canActivate = await this.runGuard(route.guard, params);
          if (!canActivate) {
            return;
          }
        }

        // Render component
        await this.renderComponent(route.component, params);
        return;
      }
    }

    // 404
    pan.publish(&#039;router.not-found&#039;, { path });
  }

  matchRoute(pattern, path) {
    if (pattern === &#039;*&#039;) return {};

    const patternParts = pattern.split(&#039;/&#039;).filter(Boolean);
    const pathParts = path.split(&#039;/&#039;).filter(Boolean);

    if (patternParts.length !== pathParts.length) return null;

    const params = {};

    for (let i = 0; i &lt; patternParts.length; i++) {
      if (patternParts[i].startsWith(&#039;:&#039;)) {
        params[patternParts[i].slice(1)] = pathParts[i];
      } else if (patternParts[i] !== pathParts[i]) {
        return null;
      }
    }

    return params;
  }

  async runGuard(guardName, params) {
    const result = await pan.request(`guard.${guardName}`, params);
    return result !== false;
  }

  async renderComponent(componentName, params) {
    // Wait for component to be defined
    await customElements.whenDefined(componentName);

    // Create component
    const component = document.createElement(componentName);

    // Pass route params
    Object.entries(params).forEach(([key, value]) =&gt; {
      component.setAttribute(key, value);
    });

    // Clear outlet and add component
    this.outlet.innerHTML = &#039;&#039;;
    this.outlet.appendChild(component);

    // Publish route change
    pan.publish(&#039;router.changed&#039;, { component: componentName, params });
  }
}

customElements.define(&#039;pan-router&#039;, PanRouter);
customElements.define(&#039;pan-route&#039;, class extends HTMLElement {});</code></pre>
<h2>Route Parameters</h2>
<p>Access route parameters in components:</p>
<pre><code class="language-javascript">class UserPage extends HTMLElement {
  static get observedAttributes() {
    return [&#039;user-id&#039;];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === &#039;user-id&#039; &amp;&amp; newValue) {
      this.loadUser(newValue);
    }
  }

  async loadUser(id) {
    const response = await fetch(`/api/users/${id}`);
    const user = await response.json();
    this.render(user);
  }

  render(user) {
    this.innerHTML = `
      &lt;h1&gt;${user.name}&lt;/h1&gt;
      &lt;p&gt;${user.email}&lt;/p&gt;
    `;
  }
}

customElements.define(&#039;user-page&#039;, UserPage);</code></pre>
<h2>Route Guards</h2>
<p>Protect routes with authentication checks:</p>
<pre><code class="language-javascript">// Respond to auth guard
pan.respond(&#039;guard.auth&#039;, async () =&gt; {
  const token = localStorage.getItem(&#039;authToken&#039;);

  if (!token) {
    // Redirect to login
    pan.publish(&#039;router.navigate&#039;, { path: &#039;/login&#039; });
    return false;
  }

  // Verify token
  try {
    const response = await fetch(&#039;/api/auth/verify&#039;, {
      headers: { &#039;Authorization&#039;: `Bearer ${token}` }
    });

    return response.ok;
  } catch {
    return false;
  }
});

// Respond to admin guard
pan.respond(&#039;guard.admin&#039;, async () =&gt; {
  const user = await pan.request(&#039;auth.user.get&#039;);
  return user?.role === &#039;admin&#039;;
});</code></pre>
<strong>Usage:</strong>
<pre><code class="language-html">&lt;pan-router&gt;
  &lt;pan-route path=&quot;/login&quot; component=&quot;login-page&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/dashboard&quot; component=&quot;dashboard-page&quot; guard=&quot;auth&quot;&gt;&lt;/pan-route&gt;
  &lt;pan-route path=&quot;/admin&quot; component=&quot;admin-page&quot; guard=&quot;admin&quot;&gt;&lt;/pan-route&gt;
&lt;/pan-router&gt;</code></pre>
<h2>Nested Routes</h2>
<p>Support hierarchical routing:</p>
<pre><code class="language-html">&lt;pan-router&gt;
  &lt;pan-route path=&quot;/settings&quot; component=&quot;settings-layout&quot;&gt;
    &lt;pan-route path=&quot;/settings/profile&quot; component=&quot;profile-settings&quot;&gt;&lt;/pan-route&gt;
    &lt;pan-route path=&quot;/settings/security&quot; component=&quot;security-settings&quot;&gt;&lt;/pan-route&gt;
    &lt;pan-route path=&quot;/settings/billing&quot; component=&quot;billing-settings&quot;&gt;&lt;/pan-route&gt;
  &lt;/pan-route&gt;
&lt;/pan-router&gt;</code></pre>
<h2>Programmatic Navigation</h2>
<p>Navigate from JavaScript:</p>
<pre><code class="language-javascript">// Navigate to a path
pan.publish(&#039;router.navigate&#039;, { path: &#039;/users/123&#039; });

// Navigate with state
pan.publish(&#039;router.navigate&#039;, {
  path: &#039;/search&#039;,
  state: { query: &#039;web components&#039; }
});

// Go back
pan.publish(&#039;router.back&#039;);

// Go forward
pan.publish(&#039;router.forward&#039;);

// Replace current route (no history entry)
pan.publish(&#039;router.replace&#039;, { path: &#039;/new-path&#039; });</code></pre>
<h2>Query Parameters</h2>
<p>Parse and use query parameters:</p>
<pre><code class="language-javascript">class SearchPage extends HTMLElement {
  connectedCallback() {
    // Parse query params
    const params = new URLSearchParams(window.location.search);
    const query = params.get(&#039;q&#039;);
    const page = parseInt(params.get(&#039;page&#039;) || &#039;1&#039;);

    this.performSearch(query, page);

    // Listen for query changes
    pan.subscribe(&#039;router.changed&#039;, () =&gt; {
      const params = new URLSearchParams(window.location.search);
      const newQuery = params.get(&#039;q&#039;);
      const newPage = parseInt(params.get(&#039;page&#039;) || &#039;1&#039;);

      if (newQuery !== query || newPage !== page) {
        this.performSearch(newQuery, newPage);
      }
    });
  }

  performSearch(query, page) {
    // Search implementation
  }
}</code></pre>
<strong>Update query params:</strong>
<pre><code class="language-javascript">function updateQuery(params) {
  const url = new URL(window.location);

  Object.entries(params).forEach(([key, value]) =&gt; {
    url.searchParams.set(key, value);
  });

  pan.publish(&#039;router.navigate&#039;, { path: url.pathname + url.search });
}

// Usage
updateQuery({ q: &#039;web components&#039;, page: &#039;2&#039; });</code></pre>
<h2>Summary</h2>
<p>LARC routing provides:</p>
<ul><li>Client-side navigation without page reloads</li>
<li>Declarative route configuration</li>
<li>Route parameters and guards</li>
<li>Nested routing support</li>
<li>Browser history integration</li>
<li>PAN bus integration</li>
</ul>
<hr>
<h2>Best Practices</h2>
<li><strong>Use declarative routing</strong> - Prefer <code><pan-router></code> over imperative API</li>
<li><strong>Implement route guards</strong> - Protect sensitive routes</li>
<li><strong>Handle 404s gracefully</strong> - Always include catch-all route</li>
<li><strong>Preserve scroll position</strong> - Restore scroll on back navigation</li>
<li><strong>Use query params for filters</strong> - Makes URLs shareable</li>
<hr>
<h2>Further Reading</h2>
<strong>For complete routing reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 5: Routing and Navigation - All routing patterns and guards</li>
<li><em>Building with LARC</em> Chapter 17: Core Components - pan-routes API reference</li>
<li><em>Building with LARC</em> Appendix E: Recipes and Patterns - Routing recipes and examples</li>
</ul>
<div class="pagebreak"></div>
<h1>Forms and Validation</h1>
<p>Forms are the primary way users input data into web applications. LARC provides patterns for building accessible, validated forms using web standards and the PAN bus.</p>
<h2>Form Components</h2>
<h3>Basic Form Component</h3>
<pre><code class="language-javascript">class ContactForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  connectedCallback() {
    this.render();
    this.attachEventListeners();
  }

  attachEventListeners() {
    const form = this.shadowRoot.querySelector(&#039;form&#039;);

    form.addEventListener(&#039;submit&#039;, async (e) =&gt; {
      e.preventDefault();

      if (this.validate()) {
        const data = this.getFormData();
        await this.handleSubmit(data);
      }
    });
  }

  getFormData() {
    const form = this.shadowRoot.querySelector(&#039;form&#039;);
    const formData = new FormData(form);
    return Object.fromEntries(formData);
  }

  validate() {
    const form = this.shadowRoot.querySelector(&#039;form&#039;);
    return form.checkValidity();
  }

  async handleSubmit(data) {
    try {
      const response = await fetch(&#039;/api/contact&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify(data)
      });

      if (response.ok) {
        pan.publish(&#039;form.submitted&#039;, { form: &#039;contact&#039;, data });
        this.showSuccess();
      } else {
        throw new Error(&#039;Submission failed&#039;);
      }
    } catch (error) {
      this.showError(error.message);
    }
  }

  showSuccess() {
    pan.publish(&#039;notification.success&#039;, { message: &#039;Form submitted successfully!&#039; });
    this.shadowRoot.querySelector(&#039;form&#039;).reset();
  }

  showError(message) {
    pan.publish(&#039;notification.error&#039;, { message });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        form { max-width: 500px; }
        .field { margin-bottom: 16px; }
        label {
          display: block;
          margin-bottom: 4px;
          font-weight: 600;
        }
        input, textarea {
          width: 100%;
          padding: 8px 12px;
          border: 1px solid #cbd5e0;
          border-radius: 4px;
        }
        input:invalid, textarea:invalid {
          border-color: #fc8181;
        }
        button {
          background: #667eea;
          color: white;
          padding: 10px 24px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
      &lt;/style&gt;

      &lt;form&gt;
        &lt;div class=&quot;field&quot;&gt;
          &lt;label for=&quot;name&quot;&gt;Name *&lt;/label&gt;
          &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; required minlength=&quot;2&quot;&gt;
        &lt;/div&gt;

        &lt;div class=&quot;field&quot;&gt;
          &lt;label for=&quot;email&quot;&gt;Email *&lt;/label&gt;
          &lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; required&gt;
        &lt;/div&gt;

        &lt;div class=&quot;field&quot;&gt;
          &lt;label for=&quot;message&quot;&gt;Message *&lt;/label&gt;
          &lt;textarea id=&quot;message&quot; name=&quot;message&quot; required minlength=&quot;10&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;
        &lt;/div&gt;

        &lt;button type=&quot;submit&quot;&gt;Send Message&lt;/button&gt;
      &lt;/form&gt;
    `;
  }
}

customElements.define(&#039;contact-form&#039;, ContactForm);</code></pre>
<h2>Two-Way Data Binding</h2>
<p>Sync form inputs with component state:</p>
<pre><code class="language-javascript">class DataBoundForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.state = {
      firstName: &#039;&#039;,
      lastName: &#039;&#039;,
      email: &#039;&#039;
    };
  }

  connectedCallback() {
    this.render();
    this.bindInputs();
  }

  bindInputs() {
    const inputs = this.shadowRoot.querySelectorAll(&#039;input&#039;);

    inputs.forEach(input =&gt; {
      // Update state when input changes
      input.addEventListener(&#039;input&#039;, (e) =&gt; {
        this.state[e.target.name] = e.target.value;
        pan.publish(&#039;form.state.changed&#039;, { state: this.state });
      });

      // Update input when state changes
      pan.subscribe(&#039;form.state.update&#039;, (updates) =&gt; {
        if (updates[input.name] !== undefined) {
          input.value = updates[input.name];
          this.state[input.name] = updates[input.name];
        }
      });
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;form&gt;
        &lt;input type=&quot;text&quot; name=&quot;firstName&quot; value=&quot;${this.state.firstName}&quot; placeholder=&quot;First Name&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;lastName&quot; value=&quot;${this.state.lastName}&quot; placeholder=&quot;Last Name&quot;&gt;
        &lt;input type=&quot;email&quot; name=&quot;email&quot; value=&quot;${this.state.email}&quot; placeholder=&quot;Email&quot;&gt;
      &lt;/form&gt;
      &lt;div class=&quot;preview&quot;&gt;
        &lt;p&gt;Hello, ${this.state.firstName} ${this.state.lastName}!&lt;/p&gt;
        &lt;p&gt;Email: ${this.state.email}&lt;/p&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h2>Validation Strategies</h2>
<h3>Native HTML5 Validation</h3>
<pre><code class="language-html">&lt;input type=&quot;email&quot; required&gt;
&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;100&quot;&gt;
&lt;input type=&quot;text&quot; pattern=&quot;[A-Za-z]{3,}&quot; title=&quot;At least 3 letters&quot;&gt;
&lt;input type=&quot;url&quot; required&gt;</code></pre>
<h3>Custom Validation</h3>
<pre><code class="language-javascript">class ValidatedInput extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;
      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;
    `;

    const input = this.querySelector(&#039;input&#039;);
    const error = this.querySelector(&#039;.error&#039;);

    input.addEventListener(&#039;blur&#039;, () =&gt; {
      const validationResult = this.customValidate(input.value);

      if (!validationResult.valid) {
        error.textContent = validationResult.message;
        input.classList.add(&#039;invalid&#039;);
      } else {
        error.textContent = &#039;&#039;;
        input.classList.remove(&#039;invalid&#039;);
      }
    });
  }

  customValidate(value) {
    // Custom validation logic
    if (value.length &lt; 3) {
      return { valid: false, message: &#039;Must be at least 3 characters&#039; };
    }

    if (!/^[a-zA-Z]+$/.test(value)) {
      return { valid: false, message: &#039;Only letters allowed&#039; };
    }

    return { valid: true };
  }
}</code></pre>
<h3>Async Validation</h3>
<pre><code class="language-javascript">class UsernameInput extends HTMLElement {
  connectedCallback() {
    this.render();

    const input = this.querySelector(&#039;input&#039;);
    let timeoutId;

    input.addEventListener(&#039;input&#039;, (e) =&gt; {
      clearTimeout(timeoutId);

      timeoutId = setTimeout(async () =&gt; {
        await this.checkAvailability(e.target.value);
      }, 500);
    });
  }

  async checkAvailability(username) {
    const status = this.querySelector(&#039;.status&#039;);

    if (username.length &lt; 3) {
      status.textContent = &#039;&#039;;
      return;
    }

    status.textContent = &#039;Checking...&#039;;

    try {
      const response = await fetch(`/api/check-username?username=${username}`);
      const { available } = await response.json();

      if (available) {
        status.textContent = &#039;✓ Available&#039;;
        status.className = &#039;status success&#039;;
      } else {
        status.textContent = &#039;✗ Already taken&#039;;
        status.className = &#039;status error&#039;;
      }
    } catch (error) {
      status.textContent = &#039;Could not check availability&#039;;
      status.className = &#039;status error&#039;;
    }
  }

  render() {
    this.innerHTML = `
      &lt;label&gt;Username&lt;/label&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;Choose a username&quot;&gt;
      &lt;span class=&quot;status&quot;&gt;&lt;/span&gt;
    `;
  }
}</code></pre>
<h2>Error Handling</h2>
<p>Display validation errors elegantly:</p>
<pre><code class="language-javascript">class FormWithErrors extends HTMLElement {
  constructor() {
    super();
    this.errors = {};
  }

  connectedCallback() {
    this.render();

    const form = this.querySelector(&#039;form&#039;);

    form.addEventListener(&#039;submit&#039;, (e) =&gt; {
      e.preventDefault();

      this.clearErrors();
      const errors = this.validateForm();

      if (Object.keys(errors).length === 0) {
        this.handleSubmit();
      } else {
        this.showErrors(errors);
      }
    });
  }

  validateForm() {
    const errors = {};
    const inputs = this.querySelectorAll(&#039;input&#039;);

    inputs.forEach(input =&gt; {
      if (!input.validity.valid) {
        errors[input.name] = this.getErrorMessage(input);
      }
    });

    return errors;
  }

  getErrorMessage(input) {
    if (input.validity.valueMissing) {
      return &#039;This field is required&#039;;
    }
    if (input.validity.typeMismatch) {
      return `Please enter a valid ${input.type}`;
    }
    if (input.validity.tooShort) {
      return `Must be at least ${input.minLength} characters`;
    }
    if (input.validity.tooLong) {
      return `Must be no more than ${input.maxLength} characters`;
    }
    if (input.validity.patternMismatch) {
      return input.title || &#039;Invalid format&#039;;
    }

    return &#039;Invalid input&#039;;
  }

  showErrors(errors) {
    Object.entries(errors).forEach(([fieldName, message]) =&gt; {
      const field = this.querySelector(`[name=&quot;${fieldName}&quot;]`);
      const errorEl = field.parentElement.querySelector(&#039;.error&#039;);

      if (errorEl) {
        errorEl.textContent = message;
        field.classList.add(&#039;invalid&#039;);
      }
    });
  }

  clearErrors() {
    this.querySelectorAll(&#039;.error&#039;).forEach(el =&gt; {
      el.textContent = &#039;&#039;;
    });

    this.querySelectorAll(&#039;.invalid&#039;).forEach(el =&gt; {
      el.classList.remove(&#039;invalid&#039;);
    });
  }

  render() {
    this.innerHTML = `
      &lt;form&gt;
        &lt;div class=&quot;field&quot;&gt;
          &lt;label&gt;Email&lt;/label&gt;
          &lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt;
          &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;

        &lt;div class=&quot;field&quot;&gt;
          &lt;label&gt;Password&lt;/label&gt;
          &lt;input type=&quot;password&quot; name=&quot;password&quot; required minlength=&quot;8&quot;&gt;
          &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;

        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    `;
  }
}</code></pre>
<h2>File Uploads</h2>
<p>Handle file uploads with progress tracking:</p>
<pre><code class="language-javascript">class FileUpload extends HTMLElement {
  connectedCallback() {
    this.render();

    const input = this.querySelector(&#039;input[type=&quot;file&quot;]&#039;);
    const button = this.querySelector(&#039;button&#039;);

    input.addEventListener(&#039;change&#039;, (e) =&gt; {
      const file = e.target.files[0];
      if (file) {
        this.showPreview(file);
        button.disabled = false;
      }
    });

    button.addEventListener(&#039;click&#039;, () =&gt; {
      const file = input.files[0];
      if (file) {
        this.uploadFile(file);
      }
    });
  }

  showPreview(file) {
    const preview = this.querySelector(&#039;.preview&#039;);

    if (file.type.startsWith(&#039;image/&#039;)) {
      const reader = new FileReader();
      reader.onload = (e) =&gt; {
        preview.innerHTML = `&lt;img src=&quot;${e.target.result}&quot; alt=&quot;Preview&quot;&gt;`;
      };
      reader.readAsDataURL(file);
    } else {
      preview.innerHTML = `
        &lt;p&gt;${file.name}&lt;/p&gt;
        &lt;p&gt;${this.formatFileSize(file.size)}&lt;/p&gt;
      `;
    }
  }

  async uploadFile(file) {
    const formData = new FormData();
    formData.append(&#039;file&#039;, file);

    const xhr = new XMLHttpRequest();

    xhr.upload.addEventListener(&#039;progress&#039;, (e) =&gt; {
      const percent = (e.loaded / e.total) * 100;
      this.updateProgress(percent);
    });

    xhr.addEventListener(&#039;load&#039;, () =&gt; {
      if (xhr.status === 200) {
        pan.publish(&#039;file.uploaded&#039;, {
          filename: file.name,
          response: JSON.parse(xhr.response)
        });
        this.showSuccess();
      } else {
        this.showError(&#039;Upload failed&#039;);
      }
    });

    xhr.addEventListener(&#039;error&#039;, () =&gt; {
      this.showError(&#039;Upload failed&#039;);
    });

    xhr.open(&#039;POST&#039;, &#039;/api/upload&#039;);
    xhr.send(formData);
  }

  updateProgress(percent) {
    const progress = this.querySelector(&#039;.progress-bar&#039;);
    progress.style.width = `${percent}%`;
    progress.textContent = `${Math.round(percent)}%`;
  }

  formatFileSize(bytes) {
    if (bytes &lt; 1024) return bytes + &#039; B&#039;;
    if (bytes &lt; 1024 * 1024) return (bytes / 1024).toFixed(1) + &#039; KB&#039;;
    return (bytes / (1024 * 1024)).toFixed(1) + &#039; MB&#039;;
  }

  showSuccess() {
    this.querySelector(&#039;.status&#039;).innerHTML = &#039;✓ Uploaded successfully&#039;;
  }

  showError(message) {
    this.querySelector(&#039;.status&#039;).innerHTML = `✗ ${message}`;
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;upload-container&quot;&gt;
        &lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&gt;
        &lt;div class=&quot;preview&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;progress&quot;&gt;
          &lt;div class=&quot;progress-bar&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;button disabled&gt;Upload&lt;/button&gt;
        &lt;div class=&quot;status&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;file-upload&#039;, FileUpload);</code></pre>
<h2>Form Submission</h2>
<p>Handle form submission with loading states and error recovery:</p>
<pre><code class="language-javascript">class SmartForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.submitting = false;
  }

  connectedCallback() {
    this.render();

    this.shadowRoot.querySelector(&#039;form&#039;).addEventListener(&#039;submit&#039;, async (e) =&gt; {
      e.preventDefault();

      if (this.submitting) return;

      this.submitting = true;
      this.disableForm();

      try {
        const data = this.getFormData();
        await this.submitForm(data);
        this.handleSuccess();
      } catch (error) {
        this.handleError(error);
      } finally {
        this.submitting = false;
        this.enableForm();
      }
    });
  }

  getFormData() {
    const form = this.shadowRoot.querySelector(&#039;form&#039;);
    const formData = new FormData(form);
    return Object.fromEntries(formData);
  }

  async submitForm(data) {
    const response = await fetch(&#039;/api/submit&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || &#039;Submission failed&#039;);
    }

    return response.json();
  }

  disableForm() {
    const inputs = this.shadowRoot.querySelectorAll(&#039;input, button, textarea&#039;);
    inputs.forEach(el =&gt; el.disabled = true);

    this.shadowRoot.querySelector(&#039;.loading&#039;).style.display = &#039;block&#039;;
  }

  enableForm() {
    const inputs = this.shadowRoot.querySelectorAll(&#039;input, button, textarea&#039;);
    inputs.forEach(el =&gt; el.disabled = false);

    this.shadowRoot.querySelector(&#039;.loading&#039;).style.display = &#039;none&#039;;
  }

  handleSuccess() {
    pan.publish(&#039;notification.success&#039;, { message: &#039;Form submitted successfully!&#039; });
    this.shadowRoot.querySelector(&#039;form&#039;).reset();
  }

  handleError(error) {
    pan.publish(&#039;notification.error&#039;, { message: error.message });
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .loading {
          display: none;
          text-align: center;
          padding: 16px;
        }
      &lt;/style&gt;

      &lt;form&gt;
        &lt;!-- Form fields --&gt;
        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
      &lt;/form&gt;

      &lt;div class=&quot;loading&quot;&gt;
        &lt;div class=&quot;spinner&quot;&gt;&lt;/div&gt;
        &lt;p&gt;Submitting...&lt;/p&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;smart-form&#039;, SmartForm);</code></pre>
<h2>Summary</h2>
<p>This chapter covered:</p>
<ul><li>Building accessible form components</li>
<li>Two-way data binding patterns</li>
<li>Validation strategies (native and custom)</li>
<li>Error handling and display</li>
<li>File upload with progress tracking</li>
<li>Form submission with loading states</li>
</ul>
<hr>
<h2>Best Practices</h2>
<li><strong>Use native validation first</strong> - HTML5 provides powerful built-in validation</li>
<li><strong>Provide clear error messages</strong> - Tell users exactly what's wrong</li>
<li><strong>Validate on blur</strong> - Don't show errors while user is typing</li>
<li><strong>Disable during submission</strong> - Prevent double-submission</li>
<li><strong>Show progress for uploads</strong> - Users want to see progress</li>
<li><strong>Handle errors gracefully</strong> - Network can fail, handle it well</li>
<hr>
<h2>Further Reading</h2>
<strong>For complete forms and validation reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 6: Forms and User Input - All form patterns and validation strategies</li>
<li><em>Building with LARC</em> Chapter 19: UI Components - pan-files and pan-markdown-editor reference</li>
<li><em>Building with LARC</em> Appendix E: Recipes and Patterns - Form validation recipes</li>
</ul>
<div class="pagebreak"></div>
<h1>Data Fetching and APIs</h1>
<p>Every meaningful web application needs to communicate with servers. Whether you're loading user profiles, submitting forms, or streaming real-time updates, data fetching is the bridge between your frontend and the outside world. LARC embraces the browser's native fetch API while providing patterns that make common tasks simple and complex scenarios manageable.</p>
<h2>The Fetch API: Your Foundation</h2>
<p>The Fetch API is built into every modern browser, and it's genuinely excellent. Unlike the XMLHttpRequest it replaced, fetch returns Promises, works naturally with async/await, and provides a clean interface for HTTP operations.</p>
<p>Here's the simplest possible fetch:</p>
<pre><code class="language-javascript">const response = await fetch(&#039;/api/users&#039;);
const users = await response.json();</code></pre>
<p>Two lines. No libraries. No configuration. This is the foundation everything else builds upon.</p>
<p>But real applications need more: error handling, loading states, retries, caching. Let's build these capabilities systematically.</p>
<h2>Building an API Client</h2>
<p>Rather than scattering fetch calls throughout your application, centralize them in an API client. This gives you one place to handle authentication, errors, and common patterns:</p>
<pre><code class="language-javascript">// api-client.js
class ApiClient {
  constructor(baseUrl = &#039;/api&#039;) {
    this.baseUrl = baseUrl;
  }

  async fetch(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;

    const config = {
      headers: {
        &#039;Content-Type&#039;: &#039;application/json&#039;,
        ...options.headers
      },
      ...options
    };

    // Add auth token if available
    const token = localStorage.getItem(&#039;authToken&#039;);
    if (token) {
      config.headers[&#039;Authorization&#039;] = `Bearer ${token}`;
    }

    try {
      const response = await fetch(url, config);

      if (!response.ok) {
        const error = await response.json().catch(() =&gt; ({}));
        throw new ApiError(response.status, error.message || &#039;Request failed&#039;);
      }

      return response.json();
    } catch (error) {
      if (error instanceof ApiError) throw error;
      throw new ApiError(0, &#039;Network error&#039;);
    }
  }

  get(endpoint) {
    return this.fetch(endpoint);
  }

  post(endpoint, data) {
    return this.fetch(endpoint, {
      method: &#039;POST&#039;,
      body: JSON.stringify(data)
    });
  }

  put(endpoint, data) {
    return this.fetch(endpoint, {
      method: &#039;PUT&#039;,
      body: JSON.stringify(data)
    });
  }

  delete(endpoint) {
    return this.fetch(endpoint, { method: &#039;DELETE&#039; });
  }
}

class ApiError extends Error {
  constructor(status, message) {
    super(message);
    this.status = status;
  }
}

export const api = new ApiClient();</code></pre>
<p>Now every component in your application can import this client and make requests with consistent error handling and authentication.</p>
<h2>Integrating with the PAN Bus</h2>
<p>Here's where LARC shines. Instead of each component managing its own loading states and error handling, broadcast API events on the PAN bus:</p>
<pre><code class="language-javascript">// api-client.js (enhanced)
import { pan } from &#039;@aspect/pan-client&#039;;

class ApiClient {
  async fetch(endpoint, options = {}) {
    const requestId = crypto.randomUUID();

    // Announce request start
    pan.publish(&#039;api.request.start&#039;, { requestId, endpoint });

    try {
      const response = await fetch(/* ... */);
      const data = await response.json();

      // Announce success
      pan.publish(&#039;api.request.success&#039;, { requestId, endpoint, data });
      return data;

    } catch (error) {
      // Announce failure
      pan.publish(&#039;api.request.error&#039;, { requestId, endpoint, error });
      throw error;
    }
  }
}</code></pre>
<p>Now any component can listen for API events. A loading indicator component might subscribe to <code>api.request.start</code> and <code>api.request.success</code>. An error toast might listen only for <code>api.request.error</code>. Components become loosely coupled—they don't need to know about each other, just the messages they care about.</p>
<h2>Caching Strategies</h2>
<p>Network requests are slow and expensive. Smart caching makes your application feel instant while reducing server load.</p>
<h3>Cache-First Strategy</h3>
<p>For data that changes infrequently, serve from cache immediately and update in the background:</p>
<pre><code class="language-javascript">class CachedApiClient extends ApiClient {
  constructor() {
    super();
    this.cache = new Map();
  }

  async getCached(endpoint, maxAge = 60000) {
    const cached = this.cache.get(endpoint);

    if (cached &amp;&amp; Date.now() - cached.timestamp &lt; maxAge) {
      // Return cached data immediately
      return cached.data;
    }

    // Fetch fresh data
    const data = await this.get(endpoint);
    this.cache.set(endpoint, { data, timestamp: Date.now() });
    return data;
  }

  async getStaleWhileRevalidate(endpoint, maxAge = 60000) {
    const cached = this.cache.get(endpoint);

    // Return stale data immediately if available
    if (cached) {
      // Revalidate in background
      this.get(endpoint).then(data =&gt; {
        this.cache.set(endpoint, { data, timestamp: Date.now() });
        pan.publish(`cache.updated.${endpoint}`, { data });
      });

      return cached.data;
    }

    // No cache, must wait for network
    const data = await this.get(endpoint);
    this.cache.set(endpoint, { data, timestamp: Date.now() });
    return data;
  }
}</code></pre>
<h3>Network-First Strategy</h3>
<p>For data that must be current, try the network first and fall back to cache:</p>
<pre><code class="language-javascript">async getNetworkFirst(endpoint, maxAge = 300000) {
  try {
    const data = await this.get(endpoint);
    this.cache.set(endpoint, { data, timestamp: Date.now() });
    return data;
  } catch (error) {
    const cached = this.cache.get(endpoint);
    if (cached &amp;&amp; Date.now() - cached.timestamp &lt; maxAge) {
      console.warn(&#039;Using cached data due to network error&#039;);
      return cached.data;
    }
    throw error;
  }
}</code></pre>
<h2>WebSocket Communication</h2>
<p>When you need real-time bidirectional communication, WebSockets provide a persistent connection between browser and server:</p>
<pre><code class="language-javascript">// websocket-client.js
class WebSocketClient {
  constructor(url) {
    this.url = url;
    this.socket = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
  }

  connect() {
    this.socket = new WebSocket(this.url);

    this.socket.onopen = () =&gt; {
      this.reconnectAttempts = 0;
      pan.publish(&#039;ws.connected&#039;);
    };

    this.socket.onmessage = (event) =&gt; {
      const message = JSON.parse(event.data);
      // Broadcast message on PAN bus
      pan.publish(`ws.message.${message.type}`, message.payload);
    };

    this.socket.onclose = () =&gt; {
      pan.publish(&#039;ws.disconnected&#039;);
      this.attemptReconnect();
    };

    this.socket.onerror = (error) =&gt; {
      pan.publish(&#039;ws.error&#039;, { error });
    };
  }

  send(type, payload) {
    if (this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify({ type, payload }));
    }
  }

  attemptReconnect() {
    if (this.reconnectAttempts &lt; this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
      setTimeout(() =&gt; this.connect(), delay);
    }
  }
}</code></pre>
<p>The beauty of this approach: your components don't know or care that data comes from a WebSocket. They just subscribe to PAN bus topics like <code>ws.message.user-joined</code> or <code>ws.message.chat-message</code>.</p>
<h2>Server-Sent Events</h2>
<p>When you only need server-to-client updates (no bidirectional communication), Server-Sent Events (SSE) are simpler and more reliable than WebSockets:</p>
<pre><code class="language-javascript">// sse-client.js
class SSEClient {
  constructor(url) {
    this.url = url;
    this.eventSource = null;
  }

  connect() {
    this.eventSource = new EventSource(this.url);

    this.eventSource.onmessage = (event) =&gt; {
      const data = JSON.parse(event.data);
      pan.publish(&#039;sse.message&#039;, data);
    };

    this.eventSource.addEventListener(&#039;notification&#039;, (event) =&gt; {
      const data = JSON.parse(event.data);
      pan.publish(&#039;sse.notification&#039;, data);
    });

    this.eventSource.onerror = () =&gt; {
      pan.publish(&#039;sse.error&#039;);
      // EventSource automatically reconnects
    };
  }

  disconnect() {
    this.eventSource?.close();
  }
}</code></pre>
<p>SSE reconnects automatically, handles authentication through cookies, and works through proxies that might block WebSockets. For many real-time use cases, it's the better choice.</p>
<h2>Retry Logic with Exponential Backoff</h2>
<p>Network requests fail. Good applications handle failure gracefully:</p>
<pre><code class="language-javascript">async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;

  for (let attempt = 0; attempt &lt; maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      if (response.ok) return response;

      // Don&#039;t retry client errors (4xx)
      if (response.status &gt;= 400 &amp;&amp; response.status &lt; 500) {
        throw new Error(`Client error: ${response.status}`);
      }

      throw new Error(`Server error: ${response.status}`);
    } catch (error) {
      lastError = error;

      if (attempt &lt; maxRetries - 1) {
        // Exponential backoff: 1s, 2s, 4s...
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(resolve =&gt; setTimeout(resolve, delay));
      }
    }
  }

  throw lastError;
}</code></pre>
<h2>Putting It All Together</h2>
<p>Here's a component that fetches user data with loading states, caching, and error handling—all integrated with the PAN bus:</p>
<pre><code class="language-javascript">class UserList extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.users = [];
    this.loading = true;
    this.error = null;
  }

  async connectedCallback() {
    // Subscribe to cache updates
    pan.subscribe(&#039;cache.updated./api/users&#039;, ({ data }) =&gt; {
      this.users = data;
      this.render();
    });

    try {
      this.users = await api.getStaleWhileRevalidate(&#039;/users&#039;);
      this.loading = false;
    } catch (error) {
      this.error = error.message;
      this.loading = false;
    }

    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host { display: block; }
        .loading { color: #666; }
        .error { color: red; }
        .user { padding: 8px; border-bottom: 1px solid #eee; }
      &lt;/style&gt;

      ${this.loading ? &#039;&lt;p class=&quot;loading&quot;&gt;Loading users...&lt;/p&gt;&#039; : &#039;&#039;}
      ${this.error ? `&lt;p class=&quot;error&quot;&gt;Error: ${this.error}&lt;/p&gt;` : &#039;&#039;}

      &lt;div class=&quot;users&quot;&gt;
        ${this.users.map(user =&gt; `
          &lt;div class=&quot;user&quot;&gt;${user.name} - ${user.email}&lt;/div&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;user-list&#039;, UserList);</code></pre>
<h2>GraphQL Integration</h2>
<p>While REST APIs are common, GraphQL offers precise data fetching—request exactly what you need, nothing more. Here's how to integrate GraphQL with LARC:</p>
<pre><code class="language-javascript">// graphql-client.js
class GraphQLClient {
  constructor(endpoint) {
    this.endpoint = endpoint;
  }

  async query(query, variables = {}) {
    const response = await fetch(this.endpoint, {
      method: &#039;POST&#039;,
      headers: {
        &#039;Content-Type&#039;: &#039;application/json&#039;,
        &#039;Authorization&#039;: `Bearer ${localStorage.getItem(&#039;authToken&#039;)}`
      },
      body: JSON.stringify({ query, variables })
    });

    const { data, errors } = await response.json();

    if (errors) {
      throw new GraphQLError(errors);
    }

    return data;
  }

  async mutation(mutation, variables = {}) {
    return this.query(mutation, variables);
  }
}

class GraphQLError extends Error {
  constructor(errors) {
    super(errors.map(e =&gt; e.message).join(&#039;, &#039;));
    this.errors = errors;
  }
}

export const graphql = new GraphQLClient(&#039;/graphql&#039;);</code></pre>
<h3>Using GraphQL in Components</h3>
<pre><code class="language-javascript">class UserProfile extends HTMLElement {
  async connectedCallback() {
    const userId = this.getAttribute(&#039;user-id&#039;);

    const query = `
      query GetUser($id: ID!) {
        user(id: $id) {
          id
          name
          email
          avatar
          posts {
            id
            title
            publishedAt
          }
        }
      }
    `;

    try {
      const { user } = await graphql.query(query, { id: userId });
      this.renderUser(user);
    } catch (error) {
      this.renderError(error);
    }
  }

  renderUser(user) {
    this.innerHTML = `
      &lt;div class=&quot;profile&quot;&gt;
        &lt;img src=&quot;${user.avatar}&quot; alt=&quot;${user.name}&quot;&gt;
        &lt;h2&gt;${user.name}&lt;/h2&gt;
        &lt;p&gt;${user.email}&lt;/p&gt;
        &lt;h3&gt;Recent Posts&lt;/h3&gt;
        &lt;ul&gt;
          ${user.posts.map(post =&gt; `
            &lt;li&gt;${post.title} (${new Date(post.publishedAt).toLocaleDateString()})&lt;/li&gt;
          `).join(&#039;&#039;)}
        &lt;/ul&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h2>Real-World Example: Building a Dashboard</h2>
<p>Let's build a complete dashboard that fetches data from multiple API endpoints, handles loading states, and updates in real-time.</p>
<h3>The Dashboard Component</h3>
<pre><code class="language-javascript">// components/dashboard.js
import { api } from &#039;../lib/api-client.js&#039;;
import { pan } from &#039;@larcjs/core&#039;;

class Dashboard extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.state = {
      stats: null,
      activity: [],
      loading: true,
      error: null
    };
  }

  async connectedCallback() {
    // Subscribe to real-time updates
    pan.subscribe(&#039;ws.message.stats-updated&#039;, ({ stats }) =&gt; {
      this.state.stats = stats;
      this.render();
    });

    pan.subscribe(&#039;ws.message.activity-added&#039;, ({ activity }) =&gt; {
      this.state.activity.unshift(activity);
      this.render();
    });

    await this.loadData();
    this.render();
  }

  async loadData() {
    try {
      // Load multiple endpoints in parallel
      const [stats, activity] = await Promise.all([
        api.getCached(&#039;/stats&#039;, 30000),
        api.get(&#039;/activity?limit=10&#039;)
      ]);

      this.state = {
        stats,
        activity,
        loading: false,
        error: null
      };
    } catch (error) {
      this.state = {
        ...this.state,
        loading: false,
        error: error.message
      };
    }
  }

  async refreshData() {
    this.state.loading = true;
    this.render();
    await this.loadData();
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          padding: 20px;
        }

        .header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 20px;
        }

        .stats {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 20px;
          margin-bottom: 30px;
        }

        .stat-card {
          background: white;
          padding: 20px;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-value {
          font-size: 32px;
          font-weight: bold;
          color: #667eea;
        }

        .stat-label {
          color: #666;
          margin-top: 5px;
        }

        .activity {
          background: white;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .activity-header {
          padding: 20px;
          border-bottom: 1px solid #eee;
          font-weight: 600;
        }

        .activity-item {
          padding: 15px 20px;
          border-bottom: 1px solid #eee;
        }

        .activity-item:last-child {
          border-bottom: none;
        }

        .loading {
          text-align: center;
          padding: 40px;
          color: #666;
        }

        .error {
          background: #fee;
          color: #c00;
          padding: 15px;
          border-radius: 4px;
        }

        button {
          background: #667eea;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
        }

        button:hover {
          background: #5568d3;
        }
      &lt;/style&gt;

      &lt;div class=&quot;header&quot;&gt;
        &lt;h1&gt;Dashboard&lt;/h1&gt;
        &lt;button @click=&quot;${() =&gt; this.refreshData()}&quot;&gt;Refresh&lt;/button&gt;
      &lt;/div&gt;

      ${this.state.loading &amp;&amp; !this.state.stats ? `
        &lt;div class=&quot;loading&quot;&gt;Loading dashboard...&lt;/div&gt;
      ` : &#039;&#039;}

      ${this.state.error ? `
        &lt;div class=&quot;error&quot;&gt;Error: ${this.state.error}&lt;/div&gt;
      ` : &#039;&#039;}

      ${this.state.stats ? `
        &lt;div class=&quot;stats&quot;&gt;
          &lt;div class=&quot;stat-card&quot;&gt;
            &lt;div class=&quot;stat-value&quot;&gt;${this.state.stats.totalUsers}&lt;/div&gt;
            &lt;div class=&quot;stat-label&quot;&gt;Total Users&lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;stat-card&quot;&gt;
            &lt;div class=&quot;stat-value&quot;&gt;${this.state.stats.activeUsers}&lt;/div&gt;
            &lt;div class=&quot;stat-label&quot;&gt;Active Users&lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;stat-card&quot;&gt;
            &lt;div class=&quot;stat-value&quot;&gt;${this.state.stats.revenue}&lt;/div&gt;
            &lt;div class=&quot;stat-label&quot;&gt;Revenue&lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;stat-card&quot;&gt;
            &lt;div class=&quot;stat-value&quot;&gt;${this.state.stats.conversionRate}%&lt;/div&gt;
            &lt;div class=&quot;stat-label&quot;&gt;Conversion Rate&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      ` : &#039;&#039;}

      ${this.state.activity.length &gt; 0 ? `
        &lt;div class=&quot;activity&quot;&gt;
          &lt;div class=&quot;activity-header&quot;&gt;Recent Activity&lt;/div&gt;
          ${this.state.activity.map(item =&gt; `
            &lt;div class=&quot;activity-item&quot;&gt;
              &lt;strong&gt;${item.user}&lt;/strong&gt; ${item.action}
              &lt;span style=&quot;color: #999; font-size: 14px;&quot;&gt;
                ${this.formatTime(item.timestamp)}
              &lt;/span&gt;
            &lt;/div&gt;
          `).join(&#039;&#039;)}
        &lt;/div&gt;
      ` : &#039;&#039;}
    `;

    // Attach event listeners
    const refreshBtn = this.shadowRoot.querySelector(&#039;button&#039;);
    if (refreshBtn) {
      refreshBtn.addEventListener(&#039;click&#039;, () =&gt; this.refreshData());
    }
  }

  formatTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;

    if (diff &lt; 60000) return &#039;just now&#039;;
    if (diff &lt; 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff &lt; 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return date.toLocaleDateString();
  }
}

customElements.define(&#039;app-dashboard&#039;, Dashboard);</code></pre>
<p>This dashboard demonstrates:</p>
<ul><li><strong>Parallel data loading</strong> with <code>Promise.all</code></li>
<li><strong>Caching</strong> for stats that don't change often</li>
<li><strong>Real-time updates</strong> via PAN bus</li>
<li><strong>Loading and error states</strong></li>
<li><strong>Manual refresh</strong> capability</li>
<li><strong>Relative time formatting</strong></li>
</ul>
<h2>Error Handling Patterns</h2>
<h3>Circuit Breaker Pattern</h3>
<p>Prevent cascading failures by stopping requests to failing services:</p>
<pre><code class="language-javascript">class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = &#039;CLOSED&#039;; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }

  async execute(fn) {
    if (this.state === &#039;OPEN&#039;) {
      if (Date.now() &lt; this.nextAttempt) {
        throw new Error(&#039;Circuit breaker is OPEN&#039;);
      }
      this.state = &#039;HALF_OPEN&#039;;
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = &#039;CLOSED&#039;;
  }

  onFailure() {
    this.failureCount++;
    if (this.failureCount &gt;= this.threshold) {
      this.state = &#039;OPEN&#039;;
      this.nextAttempt = Date.now() + this.timeout;
      pan.publish(&#039;circuit-breaker.opened&#039;, {
        breaker: this
      });
    }
  }
}

// Usage
const userApiBreaker = new CircuitBreaker();

async function fetchUsers() {
  return userApiBreaker.execute(() =&gt; api.get(&#039;/users&#039;));
}</code></pre>
<h3>Fallback Strategies</h3>
<p>Provide graceful degradation when APIs fail:</p>
<pre><code class="language-javascript">class FallbackApiClient extends ApiClient {
  async getWithFallback(endpoint, fallbackData) {
    try {
      return await this.get(endpoint);
    } catch (error) {
      console.warn(`API call failed, using fallback for ${endpoint}`);
      pan.publish(&#039;api.fallback&#039;, { endpoint, error });
      return fallbackData;
    }
  }

  async getWithCacheFallback(endpoint) {
    try {
      const data = await this.get(endpoint);
      localStorage.setItem(`fallback:${endpoint}`, JSON.stringify(data));
      return data;
    } catch (error) {
      const cached = localStorage.getItem(`fallback:${endpoint}`);
      if (cached) {
        return JSON.parse(cached);
      }
      throw error;
    }
  }
}</code></pre>
<h2>Optimistic Updates</h2>
<p>Update UI immediately before the server responds:</p>
<pre><code class="language-javascript">class TodoList extends HTMLElement {
  async addTodo(text) {
    const optimisticTodo = {
      id: `temp-${Date.now()}`,
      text,
      completed: false,
      pending: true
    };

    // Add to UI immediately
    this.todos.push(optimisticTodo);
    this.render();

    try {
      // Send to server
      const savedTodo = await api.post(&#039;/todos&#039;, { text });

      // Replace optimistic todo with server response
      const index = this.todos.findIndex(t =&gt; t.id === optimisticTodo.id);
      this.todos[index] = savedTodo;
      this.render();

    } catch (error) {
      // Revert on failure
      this.todos = this.todos.filter(t =&gt; t.id !== optimisticTodo.id);
      this.render();

      pan.publish(&#039;notification.error&#039;, {
        message: &#039;Failed to add todo&#039;
      });
    }
  }
}</code></pre>
<h2>Infinite Scroll / Pagination</h2>
<p>Load more data as the user scrolls:</p>
<pre><code class="language-javascript">class InfiniteList extends HTMLElement {
  constructor() {
    super();
    this.items = [];
    this.page = 1;
    this.loading = false;
    this.hasMore = true;
  }

  connectedCallback() {
    this.render();
    this.loadMore();

    // Intersection Observer for infinite scroll
    const sentinel = this.querySelector(&#039;.sentinel&#039;);
    const observer = new IntersectionObserver(entries =&gt; {
      if (entries[0].isIntersecting &amp;&amp; !this.loading &amp;&amp; this.hasMore) {
        this.loadMore();
      }
    });
    observer.observe(sentinel);
  }

  async loadMore() {
    if (this.loading || !this.hasMore) return;

    this.loading = true;
    this.render();

    try {
      const data = await api.get(`/items?page=${this.page}&amp;limit=20`);

      this.items.push(...data.items);
      this.hasMore = data.hasMore;
      this.page++;

    } catch (error) {
      console.error(&#039;Failed to load more items:&#039;, error);
    } finally {
      this.loading = false;
      this.render();
    }
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;items&quot;&gt;
        ${this.items.map(item =&gt; `
          &lt;div class=&quot;item&quot;&gt;${item.title}&lt;/div&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;

      ${this.loading ? &#039;&lt;div class=&quot;loading&quot;&gt;Loading...&lt;/div&gt;&#039; : &#039;&#039;}
      ${this.hasMore ? &#039;&lt;div class=&quot;sentinel&quot;&gt;&lt;/div&gt;&#039; : &#039;&#039;}
      ${!this.hasMore ? &#039;&lt;div class=&quot;end&quot;&gt;No more items&lt;/div&gt;&#039; : &#039;&#039;}
    `;
  }
}</code></pre>
<h2>Troubleshooting</h2>
<h3>Problem: CORS Errors</h3>
<strong>Symptom</strong>: <code>Access to fetch at 'https://api.example.com' from origin 'http://localhost:3000' has been blocked by CORS policy</code>
<strong>Solution</strong>: Configure your server to send CORS headers:
<pre><code class="language-javascript">// Express.js example
app.use((req, res, next) =&gt; {
  res.header(&#039;Access-Control-Allow-Origin&#039;, &#039;http://localhost:3000&#039;);
  res.header(&#039;Access-Control-Allow-Methods&#039;, &#039;GET, POST, PUT, DELETE&#039;);
  res.header(&#039;Access-Control-Allow-Headers&#039;, &#039;Content-Type, Authorization&#039;);
  res.header(&#039;Access-Control-Allow-Credentials&#039;, &#039;true&#039;);
  next();
});</code></pre>
<p>Or use a proxy in development:</p>
<pre><code class="language-javascript">// vite.config.js
export default {
  server: {
    proxy: {
      &#039;/api&#039;: {
        target: &#039;https://api.example.com&#039;,
        changeOrigin: true,
        rewrite: (path) =&gt; path.replace(/^\/api/, &#039;&#039;)
      }
    }
  }
};</code></pre>
<h3>Problem: Requests Timing Out</h3>
<strong>Symptom</strong>: Fetch hangs indefinitely or takes too long
<strong>Solution</strong>: Add timeout to fetch requests:
<pre><code class="language-javascript">async function fetchWithTimeout(url, options = {}, timeout = 5000) {
  const controller = new AbortController();
  const id = setTimeout(() =&gt; controller.abort(), timeout);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(id);
    return response;
  } catch (error) {
    clearTimeout(id);
    if (error.name === &#039;AbortError&#039;) {
      throw new Error(&#039;Request timeout&#039;);
    }
    throw error;
  }
}</code></pre>
<h3>Problem: Memory Leaks from Uncancelled Requests</h3>
<strong>Symptom</strong>: Component removed but requests still updating state
<strong>Solution</strong>: Cancel requests when component disconnects:
<pre><code class="language-javascript">class UserList extends HTMLElement {
  constructor() {
    super();
    this.abortController = new AbortController();
  }

  async connectedCallback() {
    try {
      const response = await fetch(&#039;/api/users&#039;, {
        signal: this.abortController.signal
      });
      const users = await response.json();
      this.render(users);
    } catch (error) {
      if (error.name !== &#039;AbortError&#039;) {
        console.error(error);
      }
    }
  }

  disconnectedCallback() {
    this.abortController.abort();
  }
}</code></pre>
<h3>Problem: Stale Data After Navigation</h3>
<strong>Symptom</strong>: Old data briefly appears before loading new data
<strong>Solution</strong>: Clear cache or reset state on navigation:
<pre><code class="language-javascript">pan.subscribe(&#039;navigation.changed&#039;, () =&gt; {
  // Clear API cache
  api.clearCache();

  // Or invalidate specific endpoints
  api.invalidate(&#039;/users&#039;);
});</code></pre>
<h2>Best Practices</h2>
<li><strong>Centralize API logic</strong> - Use a single API client, not scattered fetch calls</li>
<li><strong>Handle loading states</strong> - Always show feedback during async operations</li>
<li><strong>Implement caching</strong> - Reduce server load and improve perceived performance</li>
<li><strong>Use optimistic updates</strong> - Make UI feel instant for common operations</li>
<li><strong>Fail gracefully</strong> - Provide fallbacks, don't just show error messages</li>
<li><strong>Cancel requests</strong> - Clean up when components unmount</li>
<li><strong>Use the PAN bus</strong> - Decouple components from API implementation details</li>
<li><strong>Implement retries</strong> - Networks are unreliable, retry with backoff</li>
<li><strong>Monitor API health</strong> - Use circuit breakers for failing services</li>
<li><strong>Test with mocks</strong> - Don't depend on live APIs for tests</li>
<h2>Exercises</h2>
<h3>Exercise 1: Weather Dashboard</h3>
<p>Build a weather dashboard that:</p>
<ul><li>Fetches current weather for a city</li>
<li>Displays 5-day forecast</li>
<li>Caches results for 30 minutes</li>
<li>Updates automatically when city changes</li>
<li>Shows loading spinner during fetch</li>
<li>Handles API errors gracefully</li>
</ul>
<strong>Bonus</strong>: Add geolocation to auto-detect user's city.
<h3>Exercise 2: Infinite Scroll Blog</h3>
<p>Create a blog list with infinite scroll that:</p>
<ul><li>Loads 10 posts initially</li>
<li>Loads 10 more as user scrolls down</li>
<li>Shows loading indicator at bottom</li>
<li>Handles "no more posts" state</li>
<li>Implements pull-to-refresh on mobile</li>
</ul>
<strong>Bonus</strong>: Add search that filters posts while maintaining infinite scroll.
<h3>Exercise 3: Real-Time Chat</h3>
<p>Build a simple chat application that:</p>
<ul><li>Uses WebSockets for real-time messages</li>
<li>Shows typing indicators</li>
<li>Displays online/offline status</li>
<li>Reconnects automatically when connection drops</li>
<li>Falls back to polling if WebSockets unavailable</li>
</ul>
<strong>Bonus</strong>: Add message read receipts and "User is typing..." indicators.
<h3>Exercise 4: Optimistic Todo List</h3>
<p>Create a todo list with optimistic updates:</p>
<ul><li>Add todos instantly (before server confirms)</li>
<li>Revert if server rejects</li>
<li>Show pending state with different styling</li>
<li>Handle offline mode (queue operations)</li>
<li>Sync when connection restored</li>
</ul>
<strong>Bonus</strong>: Use IndexedDB for offline storage and sync queue.
<hr>
<h2>Summary</h2>
<p>Data fetching is the bridge between your frontend and the world. LARC embraces native browser APIs (fetch, WebSocket, EventSource) while providing patterns that make common tasks simple:</p>
<ul><li><strong>Use fetch</strong> for HTTP requests, enhance with retries and timeouts</li>
<li><strong>Build an API client</strong> to centralize authentication and error handling</li>
<li><strong>Integrate with PAN bus</strong> to decouple components from API details</li>
<li><strong>Implement caching</strong> to improve performance and reduce server load</li>
<li><strong>Handle errors gracefully</strong> with circuit breakers and fallbacks</li>
<li><strong>Use optimistic updates</strong> to make UI feel instant</li>
<li><strong>Choose the right tool</strong>: REST for standard APIs, GraphQL for flexible queries, WebSockets for bidirectional real-time, SSE for server push</li>
</ul>
The web platform provides excellent data fetching capabilities. LARC helps you use them effectively.
<hr>
<h2>Further Reading</h2>
<strong>For complete API integration reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 7: Data Fetching and APIs - All patterns and strategies</li>
<li><em>Building with LARC</em> Chapter 20: Integration Components - pan-data-connector, pan-websocket, pan-sse API reference</li>
<li><em>Building with LARC</em> Appendix E: Recipes and Patterns - API integration recipes</li>
</ul>
<div class="pagebreak"></div>
<h1>Authentication and Security</h1>
<p>Authentication is the bouncer at your application's door. Get it wrong, and either legitimate users can't get in, or everyone can. Security isn't a feature you add later—it's a mindset that shapes every decision from the start.</p>
<h2>Understanding Authentication vs Authorization</h2>
<p>These terms often get conflated, but they're distinct:</p>
<strong>Authentication</strong> answers: "Who are you?" It's verifying identity—matching a username and password, validating a token, confirming you are who you claim to be.
<strong>Authorization</strong> answers: "What can you do?" Once we know who you are, authorization determines your permissions—can you view this page, edit this record, delete this user?
<p>LARC applications typically handle authentication with JWT tokens and authorization with role-based or permission-based access control.</p>
<h2>JWT Token Management</h2>
<p>JSON Web Tokens (JWTs) are the standard for stateless authentication. A JWT contains encoded claims about the user, signed by the server:</p>
<pre><code class="language-javascript">// auth-service.js
class AuthService {
  constructor() {
    this.tokenKey = &#039;auth_token&#039;;
    this.refreshKey = &#039;refresh_token&#039;;
  }

  async login(email, password) {
    const response = await fetch(&#039;/api/auth/login&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify({ email, password })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || &#039;Login failed&#039;);
    }

    const { accessToken, refreshToken, user } = await response.json();

    this.setTokens(accessToken, refreshToken);
    pan.publish(&#039;auth.login&#039;, { user }, { retained: true });

    return user;
  }

  setTokens(accessToken, refreshToken) {
    localStorage.setItem(this.tokenKey, accessToken);
    if (refreshToken) {
      localStorage.setItem(this.refreshKey, refreshToken);
    }
  }

  getToken() {
    return localStorage.getItem(this.tokenKey);
  }

  isAuthenticated() {
    const token = this.getToken();
    if (!token) return false;

    try {
      const payload = this.decodeToken(token);
      return payload.exp * 1000 &gt; Date.now();
    } catch {
      return false;
    }
  }

  decodeToken(token) {
    const base64Url = token.split(&#039;.&#039;)[1];
    const base64 = base64Url.replace(/-/g, &#039;+&#039;).replace(/_/g, &#039;/&#039;);
    return JSON.parse(atob(base64));
  }

  async refresh() {
    const refreshToken = localStorage.getItem(this.refreshKey);
    if (!refreshToken) throw new Error(&#039;No refresh token&#039;);

    const response = await fetch(&#039;/api/auth/refresh&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify({ refreshToken })
    });

    if (!response.ok) {
      this.logout();
      throw new Error(&#039;Token refresh failed&#039;);
    }

    const { accessToken } = await response.json();
    localStorage.setItem(this.tokenKey, accessToken);
    return accessToken;
  }

  logout() {
    localStorage.removeItem(this.tokenKey);
    localStorage.removeItem(this.refreshKey);
    pan.publish(&#039;auth.logout&#039;, {}, { retained: true });
  }

  getCurrentUser() {
    const token = this.getToken();
    if (!token) return null;

    try {
      return this.decodeToken(token);
    } catch {
      return null;
    }
  }
}

export const auth = new AuthService();</code></pre>
<h2>Automatic Token Refresh</h2>
<p>Tokens expire. Good applications refresh them transparently:</p>
<pre><code class="language-javascript">// api-client.js with token refresh
class AuthenticatedApiClient {
  async fetch(endpoint, options = {}) {
    // First attempt
    try {
      return await this.doFetch(endpoint, options);
    } catch (error) {
      // If 401, try refreshing token
      if (error.status === 401) {
        try {
          await auth.refresh();
          // Retry with new token
          return await this.doFetch(endpoint, options);
        } catch (refreshError) {
          // Refresh failed, user must log in again
          auth.logout();
          throw error;
        }
      }
      throw error;
    }
  }

  async doFetch(endpoint, options) {
    const token = auth.getToken();
    const headers = {
      &#039;Content-Type&#039;: &#039;application/json&#039;,
      ...options.headers
    };

    if (token) {
      headers[&#039;Authorization&#039;] = `Bearer ${token}`;
    }

    const response = await fetch(`/api${endpoint}`, { ...options, headers });

    if (!response.ok) {
      throw { status: response.status, message: await response.text() };
    }

    return response.json();
  }
}</code></pre>
<h2>Protected Routes</h2>
<p>Some pages should only be accessible to authenticated users. Here's a route guard pattern:</p>
<pre><code class="language-javascript">// route-guard.js
class RouteGuard extends HTMLElement {
  connectedCallback() {
    this.checkAuth();
    pan.subscribe(&#039;auth.logout&#039;, () =&gt; this.checkAuth());
  }

  checkAuth() {
    if (!auth.isAuthenticated()) {
      // Store intended destination
      sessionStorage.setItem(&#039;returnUrl&#039;, window.location.pathname);
      // Redirect to login
      pan.publish(&#039;router.navigate&#039;, { path: &#039;/login&#039; });
    }
  }
}

customElements.define(&#039;route-guard&#039;, RouteGuard);</code></pre>
<p>Use it to wrap protected content:</p>
<pre><code class="language-html">&lt;route-guard&gt;
  &lt;dashboard-page&gt;&lt;/dashboard-page&gt;
&lt;/route-guard&gt;</code></pre>
<h2>Role-Based Access Control</h2>
<p>Different users have different permissions. A simple RBAC implementation:</p>
<pre><code class="language-javascript">// rbac.js
class RBAC {
  constructor() {
    this.permissions = {
      admin: [&#039;read&#039;, &#039;write&#039;, &#039;delete&#039;, &#039;manage-users&#039;],
      editor: [&#039;read&#039;, &#039;write&#039;],
      viewer: [&#039;read&#039;]
    };
  }

  can(user, action) {
    if (!user?.role) return false;
    const allowed = this.permissions[user.role] || [];
    return allowed.includes(action);
  }
}

export const rbac = new RBAC();</code></pre>
<p>Use it in components:</p>
<pre><code class="language-javascript">class AdminPanel extends HTMLElement {
  connectedCallback() {
    const user = auth.getCurrentUser();

    if (!rbac.can(user, &#039;manage-users&#039;)) {
      this.innerHTML = &#039;&lt;p&gt;Access denied&lt;/p&gt;&#039;;
      return;
    }

    this.render();
  }
}</code></pre>
<h2>Security Best Practices</h2>
<h3>Sanitize User Input</h3>
<p>Never trust user input. Always sanitize before rendering:</p>
<pre><code class="language-javascript">function escapeHtml(text) {
  const div = document.createElement(&#039;div&#039;);
  div.textContent = text;
  return div.innerHTML;
}

// Safe rendering
this.innerHTML = `&lt;p&gt;${escapeHtml(userInput)}&lt;/p&gt;`;</code></pre>
<h3>Use HTTPS</h3>
<p>Always serve your application over HTTPS. This protects tokens in transit and enables secure cookies.</p>
<h3>Secure Token Storage</h3>
<p>LocalStorage is convenient but accessible to JavaScript. For high-security applications, consider httpOnly cookies:</p>
<pre><code class="language-javascript">// Server sets cookie
res.cookie(&#039;token&#039;, jwt, {
  httpOnly: true,
  secure: true,
  sameSite: &#039;strict&#039;
});</code></pre>
<h3>Content Security Policy</h3>
<p>Set CSP headers to prevent XSS attacks:</p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;Content-Security-Policy&quot;
      content=&quot;default-src &#039;self&#039;; script-src &#039;self&#039;&quot;&gt;</code></pre>
<h2>Complete Login/Signup Flow</h2>
<p>Let's build a complete authentication system with login and signup components that work together:</p>
<h3>Login Component</h3>
<pre><code class="language-javascript">// components/login-form.js
import { auth } from &#039;../services/auth.js&#039;;
import { pan } from &#039;@larcjs/core&#039;;

class LoginForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.state = {
      email: &#039;&#039;,
      password: &#039;&#039;,
      loading: false,
      error: null
    };
  }

  connectedCallback() {
    this.render();
  }

  async handleSubmit(e) {
    e.preventDefault();

    this.state.loading = true;
    this.state.error = null;
    this.render();

    try {
      const user = await auth.login(this.state.email, this.state.password);

      // Redirect to intended destination or dashboard
      const returnUrl = sessionStorage.getItem(&#039;returnUrl&#039;) || &#039;/dashboard&#039;;
      sessionStorage.removeItem(&#039;returnUrl&#039;);
      pan.publish(&#039;router.navigate&#039;, { path: returnUrl });

    } catch (error) {
      this.state.error = error.message;
      this.state.loading = false;
      this.render();
    }
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          max-width: 400px;
          margin: 50px auto;
        }

        form {
          background: white;
          padding: 30px;
          border-radius: 8px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h2 {
          margin: 0 0 20px;
          color: #333;
        }

        .error {
          background: #fee;
          color: #c00;
          padding: 10px;
          border-radius: 4px;
          margin-bottom: 15px;
        }

        .form-group {
          margin-bottom: 15px;
        }

        label {
          display: block;
          margin-bottom: 5px;
          font-weight: 600;
          color: #555;
        }

        input {
          width: 100%;
          padding: 10px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 14px;
        }

        input:focus {
          outline: none;
          border-color: #667eea;
        }

        button {
          width: 100%;
          padding: 12px;
          background: #667eea;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 16px;
          cursor: pointer;
        }

        button:hover:not(:disabled) {
          background: #5568d3;
        }

        button:disabled {
          opacity: 0.6;
          cursor: not-allowed;
        }

        .signup-link {
          text-align: center;
          margin-top: 15px;
          color: #666;
        }

        .signup-link a {
          color: #667eea;
          text-decoration: none;
        }
      &lt;/style&gt;

      &lt;form&gt;
        &lt;h2&gt;Login&lt;/h2&gt;

        ${this.state.error ? `
          &lt;div class=&quot;error&quot;&gt;${this.state.error}&lt;/div&gt;
        ` : &#039;&#039;}

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;
          &lt;input
            type=&quot;email&quot;
            id=&quot;email&quot;
            value=&quot;${this.state.email}&quot;
            required
            autocomplete=&quot;email&quot;
          &gt;
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;
          &lt;input
            type=&quot;password&quot;
            id=&quot;password&quot;
            value=&quot;${this.state.password}&quot;
            required
            autocomplete=&quot;current-password&quot;
          &gt;
        &lt;/div&gt;

        &lt;button type=&quot;submit&quot; ?disabled=&quot;${this.state.loading}&quot;&gt;
          ${this.state.loading ? &#039;Logging in...&#039; : &#039;Login&#039;}
        &lt;/button&gt;

        &lt;div class=&quot;signup-link&quot;&gt;
          Don&#039;t have an account? &lt;a href=&quot;/signup&quot;&gt;Sign up&lt;/a&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    `;

    // Attach event listeners
    const form = this.shadowRoot.querySelector(&#039;form&#039;);
    const emailInput = this.shadowRoot.querySelector(&#039;#email&#039;);
    const passwordInput = this.shadowRoot.querySelector(&#039;#password&#039;);

    form.addEventListener(&#039;submit&#039;, (e) =&gt; this.handleSubmit(e));

    emailInput.addEventListener(&#039;input&#039;, (e) =&gt; {
      this.state.email = e.target.value;
    });

    passwordInput.addEventListener(&#039;input&#039;, (e) =&gt; {
      this.state.password = e.target.value;
    });

    // Handle signup link
    const signupLink = this.shadowRoot.querySelector(&#039;.signup-link a&#039;);
    signupLink?.addEventListener(&#039;click&#039;, (e) =&gt; {
      e.preventDefault();
      pan.publish(&#039;router.navigate&#039;, { path: &#039;/signup&#039; });
    });
  }
}

customElements.define(&#039;login-form&#039;, LoginForm);</code></pre>
<h3>Signup Component</h3>
<pre><code class="language-javascript">// components/signup-form.js
class SignupForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.state = {
      name: &#039;&#039;,
      email: &#039;&#039;,
      password: &#039;&#039;,
      confirmPassword: &#039;&#039;,
      loading: false,
      errors: {}
    };
  }

  connectedCallback() {
    this.render();
  }

  validate() {
    const errors = {};

    if (!this.state.name || this.state.name.length &lt; 2) {
      errors.name = &#039;Name must be at least 2 characters&#039;;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(this.state.email)) {
      errors.email = &#039;Invalid email address&#039;;
    }

    if (this.state.password.length &lt; 8) {
      errors.password = &#039;Password must be at least 8 characters&#039;;
    }

    if (this.state.password !== this.state.confirmPassword) {
      errors.confirmPassword = &#039;Passwords do not match&#039;;
    }

    return errors;
  }

  async handleSubmit(e) {
    e.preventDefault();

    const errors = this.validate();
    if (Object.keys(errors).length &gt; 0) {
      this.state.errors = errors;
      this.render();
      return;
    }

    this.state.loading = true;
    this.state.errors = {};
    this.render();

    try {
      const response = await fetch(&#039;/api/auth/signup&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify({
          name: this.state.name,
          email: this.state.email,
          password: this.state.password
        })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || &#039;Signup failed&#039;);
      }

      const { accessToken, refreshToken, user } = await response.json();

      auth.setTokens(accessToken, refreshToken);
      pan.publish(&#039;auth.login&#039;, { user }, { retained: true });
      pan.publish(&#039;router.navigate&#039;, { path: &#039;/dashboard&#039; });

    } catch (error) {
      this.state.errors = { general: error.message };
      this.state.loading = false;
      this.render();
    }
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        /* Similar styles to login-form */
        :host {
          display: block;
          max-width: 400px;
          margin: 50px auto;
        }
        /* ... (copy styles from login-form) ... */
      &lt;/style&gt;

      &lt;form&gt;
        &lt;h2&gt;Create Account&lt;/h2&gt;

        ${this.state.errors.general ? `
          &lt;div class=&quot;error&quot;&gt;${this.state.errors.general}&lt;/div&gt;
        ` : &#039;&#039;}

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
          &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;${this.state.name}&quot; required&gt;
          ${this.state.errors.name ? `
            &lt;span class=&quot;field-error&quot;&gt;${this.state.errors.name}&lt;/span&gt;
          ` : &#039;&#039;}
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;
          &lt;input type=&quot;email&quot; id=&quot;email&quot; value=&quot;${this.state.email}&quot; required&gt;
          ${this.state.errors.email ? `
            &lt;span class=&quot;field-error&quot;&gt;${this.state.errors.email}&lt;/span&gt;
          ` : &#039;&#039;}
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;
          &lt;input type=&quot;password&quot; id=&quot;password&quot; required autocomplete=&quot;new-password&quot;&gt;
          ${this.state.errors.password ? `
            &lt;span class=&quot;field-error&quot;&gt;${this.state.errors.password}&lt;/span&gt;
          ` : &#039;&#039;}
        &lt;/div&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label for=&quot;confirmPassword&quot;&gt;Confirm Password&lt;/label&gt;
          &lt;input type=&quot;password&quot; id=&quot;confirmPassword&quot; required&gt;
          ${this.state.errors.confirmPassword ? `
            &lt;span class=&quot;field-error&quot;&gt;${this.state.errors.confirmPassword}&lt;/span&gt;
          ` : &#039;&#039;}
        &lt;/div&gt;

        &lt;button type=&quot;submit&quot; ?disabled=&quot;${this.state.loading}&quot;&gt;
          ${this.state.loading ? &#039;Creating account...&#039; : &#039;Sign Up&#039;}
        &lt;/button&gt;

        &lt;div class=&quot;login-link&quot;&gt;
          Already have an account? &lt;a href=&quot;/login&quot;&gt;Login&lt;/a&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    `;

    // Attach event listeners (similar to login-form)
    const form = this.shadowRoot.querySelector(&#039;form&#039;);
    form.addEventListener(&#039;submit&#039;, (e) =&gt; this.handleSubmit(e));

    // Update state on input
    [&#039;name&#039;, &#039;email&#039;, &#039;password&#039;, &#039;confirmPassword&#039;].forEach(field =&gt; {
      const input = this.shadowRoot.querySelector(`#${field}`);
      input?.addEventListener(&#039;input&#039;, (e) =&gt; {
        this.state[field] = e.target.value;
      });
    });
  }
}

customElements.define(&#039;signup-form&#039;, SignupForm);</code></pre>
<h2>OAuth Integration (GitHub Example)</h2>
<p>OAuth allows users to log in with existing accounts from providers like GitHub, Google, or Facebook:</p>
<h3>OAuth Flow</h3>
<pre><code class="language-javascript">// services/oauth.js
class OAuthService {
  constructor() {
    this.providers = {
      github: {
        clientId: &#039;your-github-client-id&#039;,
        authUrl: &#039;https://github.com/login/oauth/authorize&#039;,
        scope: &#039;read:user user:email&#039;
      }
    };
  }

  initiateLogin(provider) {
    const config = this.providers[provider];
    if (!config) throw new Error(`Unknown provider: ${provider}`);

    const redirectUri = `${window.location.origin}/auth/callback`;
    const state = this.generateState();

    // Store state for CSRF protection
    sessionStorage.setItem(&#039;oauth_state&#039;, state);

    const params = new URLSearchParams({
      client_id: config.clientId,
      redirect_uri: redirectUri,
      scope: config.scope,
      state
    });

    // Redirect to provider
    window.location.href = `${config.authUrl}?${params}`;
  }

  generateState() {
    return Array.from(crypto.getRandomValues(new Uint8Array(16)))
      .map(b =&gt; b.toString(16).padStart(2, &#039;0&#039;))
      .join(&#039;&#039;);
  }

  async handleCallback() {
    const params = new URLSearchParams(window.location.search);
    const code = params.get(&#039;code&#039;);
    const state = params.get(&#039;state&#039;);

    // Verify state (CSRF protection)
    const storedState = sessionStorage.getItem(&#039;oauth_state&#039;);
    if (state !== storedState) {
      throw new Error(&#039;Invalid state parameter&#039;);
    }

    // Exchange code for token with your backend
    const response = await fetch(&#039;/api/auth/github/callback&#039;, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify({ code })
    });

    if (!response.ok) {
      throw new Error(&#039;OAuth authentication failed&#039;);
    }

    const { accessToken, refreshToken, user } = await response.json();

    auth.setTokens(accessToken, refreshToken);
    pan.publish(&#039;auth.login&#039;, { user }, { retained: true });

    // Clean up
    sessionStorage.removeItem(&#039;oauth_state&#039;);

    return user;
  }
}

export const oauth = new OAuthService();</code></pre>
<h3>OAuth Button Component</h3>
<pre><code class="language-javascript">class OAuthButtons extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;style&gt;
        .oauth-buttons {
          display: flex;
          flex-direction: column;
          gap: 10px;
          margin: 20px 0;
        }

        .oauth-button {
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 10px;
          padding: 12px;
          border: 1px solid #ddd;
          border-radius: 4px;
          background: white;
          cursor: pointer;
          transition: background 0.2s;
        }

        .oauth-button:hover {
          background: #f5f5f5;
        }

        .oauth-button img {
          width: 20px;
          height: 20px;
        }
      &lt;/style&gt;

      &lt;div class=&quot;oauth-buttons&quot;&gt;
        &lt;button class=&quot;oauth-button&quot; data-provider=&quot;github&quot;&gt;
          &lt;img src=&quot;/icons/github.svg&quot; alt=&quot;GitHub&quot;&gt;
          &lt;span&gt;Continue with GitHub&lt;/span&gt;
        &lt;/button&gt;

        &lt;button class=&quot;oauth-button&quot; data-provider=&quot;google&quot;&gt;
          &lt;img src=&quot;/icons/google.svg&quot; alt=&quot;Google&quot;&gt;
          &lt;span&gt;Continue with Google&lt;/span&gt;
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;div class=&quot;divider&quot;&gt;
        &lt;span&gt;or&lt;/span&gt;
      &lt;/div&gt;
    `;

    this.querySelectorAll(&#039;[data-provider]&#039;).forEach(button =&gt; {
      button.addEventListener(&#039;click&#039;, () =&gt; {
        const provider = button.dataset.provider;
        oauth.initiateLogin(provider);
      });
    });
  }
}

customElements.define(&#039;oauth-buttons&#039;, OAuthButtons);</code></pre>
<h2>Session Management</h2>
<p>Track active sessions and allow users to log out from all devices:</p>
<pre><code class="language-javascript">// services/session-manager.js
class SessionManager {
  async getSessions() {
    return await api.get(&#039;/auth/sessions&#039;);
  }

  async revokeSession(sessionId) {
    await api.delete(`/auth/sessions/${sessionId}`);
    pan.publish(&#039;session.revoked&#039;, { sessionId });
  }

  async revokeAllSessions() {
    await api.delete(&#039;/auth/sessions&#039;);
    pan.publish(&#039;session.all-revoked&#039;);
    auth.logout();
  }
}

export const sessionManager = new SessionManager();</code></pre>
<h3>Sessions Component</h3>
<pre><code class="language-javascript">class SessionsList extends HTMLElement {
  constructor() {
    super();
    this.sessions = [];
  }

  async connectedCallback() {
    await this.loadSessions();
    this.render();

    pan.subscribe(&#039;session.revoked&#039;, () =&gt; this.loadSessions());
  }

  async loadSessions() {
    try {
      this.sessions = await sessionManager.getSessions();
      this.render();
    } catch (error) {
      console.error(&#039;Failed to load sessions:&#039;, error);
    }
  }

  async revokeSession(sessionId) {
    if (!confirm(&#039;Revoke this session?&#039;)) return;

    try {
      await sessionManager.revokeSession(sessionId);
    } catch (error) {
      alert(&#039;Failed to revoke session&#039;);
    }
  }

  async revokeAll() {
    if (!confirm(&#039;Log out from all devices?&#039;)) return;

    try {
      await sessionManager.revokeAllSessions();
    } catch (error) {
      alert(&#039;Failed to revoke sessions&#039;);
    }
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;sessions&quot;&gt;
        &lt;h3&gt;Active Sessions&lt;/h3&gt;

        ${this.sessions.map(session =&gt; `
          &lt;div class=&quot;session&quot; data-current=&quot;${session.isCurrent}&quot;&gt;
            &lt;div class=&quot;session-info&quot;&gt;
              &lt;strong&gt;${session.device}&lt;/strong&gt;
              &lt;span&gt;${session.location}&lt;/span&gt;
              &lt;small&gt;Last active: ${new Date(session.lastActive).toLocaleString()}&lt;/small&gt;
            &lt;/div&gt;
            ${session.isCurrent ? `
              &lt;span class=&quot;badge&quot;&gt;Current&lt;/span&gt;
            ` : `
              &lt;button onclick=&quot;this.closest(&#039;sessions-list&#039;).revokeSession(&#039;${session.id}&#039;)&quot;&gt;
                Revoke
              &lt;/button&gt;
            `}
          &lt;/div&gt;
        `).join(&#039;&#039;)}

        &lt;button class=&quot;danger&quot; onclick=&quot;this.closest(&#039;sessions-list&#039;).revokeAll()&quot;&gt;
          Log out from all devices
        &lt;/button&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;sessions-list&#039;, SessionsList);</code></pre>
<h2>XSS and CSRF Protection</h2>
<h3>Preventing XSS (Cross-Site Scripting)</h3>
<p>Always sanitize user input before rendering:</p>
<pre><code class="language-javascript">// utils/sanitize.js
const ALLOWED_TAGS = [&#039;b&#039;, &#039;i&#039;, &#039;em&#039;, &#039;strong&#039;, &#039;a&#039;, &#039;p&#039;, &#039;br&#039;];

function sanitizeHtml(html) {
  const div = document.createElement(&#039;div&#039;);
  div.innerHTML = html;

  // Remove all scripts
  div.querySelectorAll(&#039;script&#039;).forEach(el =&gt; el.remove());

  // Remove event handlers
  div.querySelectorAll(&#039;*&#039;).forEach(el =&gt; {
    [...el.attributes].forEach(attr =&gt; {
      if (attr.name.startsWith(&#039;on&#039;)) {
        el.removeAttribute(attr.name);
      }
    });

    // Remove tags not in allowlist
    if (!ALLOWED_TAGS.includes(el.tagName.toLowerCase())) {
      el.replaceWith(...el.childNodes);
    }
  });

  return div.innerHTML;
}

export { sanitizeHtml };</code></pre>
<h3>CSRF Protection</h3>
<p>Include CSRF tokens in state-changing requests:</p>
<pre><code class="language-javascript">// api-client.js
class SecureApiClient {
  getCsrfToken() {
    // Get from meta tag or cookie
    return document.querySelector(&#039;meta[name=&quot;csrf-token&quot;]&#039;)?.content;
  }

  async fetch(endpoint, options = {}) {
    const headers = {
      &#039;Content-Type&#039;: &#039;application/json&#039;,
      &#039;X-CSRF-Token&#039;: this.getCsrfToken(),
      ...options.headers
    };

    return fetch(endpoint, { ...options, headers });
  }
}</code></pre>
<p>Server should validate CSRF tokens on state-changing requests (POST, PUT, DELETE).</p>
<h2>Password Reset Flow</h2>
<pre><code class="language-javascript">// components/password-reset.js
class PasswordResetForm extends HTMLElement {
  async handleRequest(e) {
    e.preventDefault();
    const email = this.querySelector(&#039;#email&#039;).value;

    try {
      await fetch(&#039;/api/auth/password-reset&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify({ email })
      });

      this.innerHTML = `
        &lt;p&gt;If an account exists for ${email}, you will receive a password reset email.&lt;/p&gt;
      `;
    } catch (error) {
      this.showError(&#039;Failed to send reset email&#039;);
    }
  }

  async handleReset(e) {
    e.preventDefault();
    const token = new URLSearchParams(window.location.search).get(&#039;token&#039;);
    const password = this.querySelector(&#039;#password&#039;).value;

    try {
      await fetch(&#039;/api/auth/password-reset/confirm&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify({ token, password })
      });

      pan.publish(&#039;router.navigate&#039;, { path: &#039;/login&#039; });
      pan.publish(&#039;notification.success&#039;, {
        message: &#039;Password reset successful&#039;
      });
    } catch (error) {
      this.showError(&#039;Failed to reset password&#039;);
    }
  }
}</code></pre>
<h2>Troubleshooting</h2>
<h3>Problem: Token Expires Too Quickly</h3>
<strong>Symptom</strong>: Users frequently get logged out
<strong>Solution</strong>: Implement automatic token refresh in background:
<pre><code class="language-javascript">// Auto-refresh tokens before expiry
class TokenRefreshManager {
  constructor() {
    this.refreshInterval = null;
  }

  start() {
    // Check token every minute
    this.refreshInterval = setInterval(async () =&gt; {
      const token = auth.getToken();
      if (!token) return;

      const payload = auth.decodeToken(token);
      const expiresIn = (payload.exp * 1000) - Date.now();

      // Refresh if expires in less than 5 minutes
      if (expiresIn &lt; 5 * 60 * 1000) {
        try {
          await auth.refresh();
        } catch (error) {
          console.error(&#039;Auto-refresh failed:&#039;, error);
          auth.logout();
        }
      }
    }, 60 * 1000);
  }

  stop() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
  }
}

export const tokenRefresh = new TokenRefreshManager();</code></pre>
<h3>Problem: OAuth Callback Not Working</h3>
<strong>Symptom</strong>: After OAuth redirect, nothing happens
<strong>Solution</strong>: Ensure callback route is registered and handles the code:
<pre><code class="language-javascript">// In your router setup
pan.subscribe(&#039;route.changed&#039;, ({ path }) =&gt; {
  if (path === &#039;/auth/callback&#039;) {
    oauth.handleCallback()
      .then(() =&gt; {
        pan.publish(&#039;router.navigate&#039;, { path: &#039;/dashboard&#039; });
      })
      .catch(error =&gt; {
        console.error(&#039;OAuth callback failed:&#039;, error);
        pan.publish(&#039;router.navigate&#039;, { path: &#039;/login&#039; });
      });
  }
});</code></pre>
<h3>Problem: Users See Flash of Protected Content</h3>
<strong>Symptom</strong>: Protected page renders briefly before redirect to login
<strong>Solution</strong>: Check authentication before mounting component:
<pre><code class="language-javascript">class ProtectedPage extends HTMLElement {
  connectedCallback() {
    // Don&#039;t render until auth check complete
    this.checkAuthThenRender();
  }

  async checkAuthThenRender() {
    if (!auth.isAuthenticated()) {
      sessionStorage.setItem(&#039;returnUrl&#039;, window.location.pathname);
      pan.publish(&#039;router.navigate&#039;, { path: &#039;/login&#039; });
      return;
    }

    this.render();
  }

  render() {
    // Only called if authenticated
    this.innerHTML = `
      &lt;h1&gt;Protected Content&lt;/h1&gt;
      &lt;p&gt;Only authenticated users see this&lt;/p&gt;
    `;
  }
}</code></pre>
<h3>Problem: Infinite Redirect Loop</h3>
<strong>Symptom</strong>: App keeps redirecting between login and protected route
<strong>Solution</strong>: Check for redirect loops in route guard:
<pre><code class="language-javascript">class RouteGuard extends HTMLElement {
  checkAuth() {
    if (!auth.isAuthenticated() &amp;&amp; window.location.pathname !== &#039;/login&#039;) {
      sessionStorage.setItem(&#039;returnUrl&#039;, window.location.pathname);
      pan.publish(&#039;router.navigate&#039;, { path: &#039;/login&#039; });
    }
  }
}</code></pre>
<h2>Best Practices</h2>
<li><strong>Never store passwords</strong> - Always hash on the server</li>
<li><strong>Use HTTPS everywhere</strong> - Tokens in plaintext over HTTP are vulnerable</li>
<li><strong>Implement token refresh</strong> - Don't force users to re-login frequently</li>
<li><strong>Validate on the server</strong> - Client-side validation is for UX, not security</li>
<li><strong>Use httpOnly cookies for tokens</strong> - Protects against XSS</li>
<li><strong>Implement CSRF protection</strong> - Required for cookie-based auth</li>
<li><strong>Rate limit authentication endpoints</strong> - Prevent brute force attacks</li>
<li><strong>Log authentication events</strong> - Track suspicious activity</li>
<li><strong>Use secure password requirements</strong> - Minimum 8 characters, complexity rules</li>
<li><strong>Provide 2FA</strong> - Add extra layer of security for sensitive apps</li>
<h2>Exercises</h2>
<h3>Exercise 1: Add "Remember Me"</h3>
<p>Extend the login form with a "Remember Me" checkbox that:</p>
<ul><li>Uses a longer-lived refresh token when checked</li>
<li>Falls back to session-only auth when unchecked</li>
<li>Persists the preference across sessions</li>
</ul>
<h3>Exercise 2: Implement 2FA</h3>
<p>Add two-factor authentication:</p>
<ul><li>Generate TOTP secret on enrollment</li>
<li>Display QR code for authenticator apps</li>
<li>Validate TOTP codes on login</li>
<li>Provide backup codes for account recovery</li>
</ul>
<h3>Exercise 3: Password Strength Meter</h3>
<p>Build a password strength indicator that:</p>
<ul><li>Shows strength in real-time as user types</li>
<li>Checks length, character variety, common passwords</li>
<li>Provides feedback on how to improve</li>
<li>Blocks weak passwords on submission</li>
</ul>
<h3>Exercise 4: Activity Log</h3>
<p>Create an activity log component that:</p>
<ul><li>Tracks login attempts, password changes, session activity</li>
<li>Displays timeline of security events</li>
<li>Alerts on suspicious activity (new device, new location)</li>
<li>Allows filtering by event type</li>
</ul>
<hr>
<h2>Summary</h2>
<p>Authentication and security are critical to any application that handles user data. LARC applications use industry-standard patterns:</p>
<ul><li><strong>JWT tokens</strong> for stateless authentication</li>
<li><strong>Automatic token refresh</strong> to maintain sessions</li>
<li><strong>OAuth integration</strong> for social login</li>
<li><strong>RBAC</strong> for fine-grained authorization</li>
<li><strong>XSS and CSRF protection</strong> to prevent attacks</li>
<li><strong>Secure token storage</strong> with httpOnly cookies when possible</li>
<li><strong>Route guards</strong> to protect sensitive pages</li>
<li><strong>Session management</strong> to track and revoke active sessions</li>
</ul>
Security isn't a checkbox—it's an ongoing practice. Stay updated on security best practices, use HTTPS everywhere, validate all input, and treat user data with respect.
<hr>
<h2>Further Reading</h2>
<strong>For complete authentication reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 8: Authentication and Authorization - All auth patterns and strategies</li>
<li><em>Building with LARC</em> Chapter 14: Error Handling and Debugging - Security debugging</li>
<li><em>Building with LARC</em> Appendix E: Recipes and Patterns - Auth implementation recipes</li>
</ul>
<div class="pagebreak"></div>
<h1>Server Integration</h1>
<p>LARC is frontend-agnostic about backends. Whether you're using Node.js, Python, PHP, or any other server technology, the patterns remain the same: your components communicate via HTTP and WebSockets, and the PAN bus coordinates the frontend.</p>
<h2>Node.js with Express</h2>
<p>Express is the most popular Node.js framework, and it pairs naturally with LARC:</p>
<pre><code class="language-javascript">// server.js
const express = require(&#039;express&#039;);
const cors = require(&#039;cors&#039;);
const jwt = require(&#039;jsonwebtoken&#039;);

const app = express();

app.use(cors());
app.use(express.json());
app.use(express.static(&#039;public&#039;));

// Authentication middleware
function authenticate(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith(&#039;Bearer &#039;)) {
    return res.status(401).json({ error: &#039;No token provided&#039; });
  }

  const token = authHeader.slice(7);
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET);
    next();
  } catch {
    res.status(401).json({ error: &#039;Invalid token&#039; });
  }
}

// Public routes
app.post(&#039;/api/auth/login&#039;, async (req, res) =&gt; {
  const { email, password } = req.body;

  const user = await db.users.findByEmail(email);
  if (!user || !await bcrypt.compare(password, user.password)) {
    return res.status(401).json({ error: &#039;Invalid credentials&#039; });
  }

  const accessToken = jwt.sign(
    { id: user.id, email: user.email, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: &#039;15m&#039; }
  );

  res.json({ accessToken, user: { id: user.id, email: user.email } });
});

// Protected routes
app.get(&#039;/api/users&#039;, authenticate, async (req, res) =&gt; {
  const users = await db.users.findAll();
  res.json(users);
});

app.post(&#039;/api/users&#039;, authenticate, async (req, res) =&gt; {
  const user = await db.users.create(req.body);
  res.status(201).json(user);
});

app.listen(3000, () =&gt; console.log(&#039;Server running on port 3000&#039;));</code></pre>
<h2>Python with Flask</h2>
<p>Flask provides a lightweight Python backend:</p>
<pre><code class="language-python"># app.py
from flask import Flask, jsonify, request
from flask_cors import CORS
from functools import wraps
import jwt

app = Flask(__name__, static_folder=&#039;public&#039;)
CORS(app)

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get(&#039;Authorization&#039;)
        if not auth_header or not auth_header.startswith(&#039;Bearer &#039;):
            return jsonify({&#039;error&#039;: &#039;No token provided&#039;}), 401

        token = auth_header[7:]
        try:
            data = jwt.decode(token, app.config[&#039;SECRET_KEY&#039;], algorithms=[&#039;HS256&#039;])
            request.user = data
        except:
            return jsonify({&#039;error&#039;: &#039;Invalid token&#039;}), 401

        return f(*args, **kwargs)
    return decorated

@app.route(&#039;/api/users&#039;)
@token_required
def get_users():
    users = User.query.all()
    return jsonify([u.to_dict() for u in users])

@app.route(&#039;/api/users&#039;, methods=[&#039;POST&#039;])
@token_required
def create_user():
    data = request.get_json()
    user = User(**data)
    db.session.add(user)
    db.session.commit()
    return jsonify(user.to_dict()), 201

if __name__ == &#039;__main__&#039;:
    app.run(debug=True)</code></pre>
<h2>PHP Integration</h2>
<p>PHP remains popular for web backends:</p>
<pre><code class="language-php">&lt;?php
// api.php
header(&#039;Content-Type: application/json&#039;);
header(&#039;Access-Control-Allow-Origin: *&#039;);
header(&#039;Access-Control-Allow-Headers: Content-Type, Authorization&#039;);

require_once &#039;vendor/autoload.php&#039;;
use Firebase\JWT\JWT;
use Firebase\JWT\Key;

function authenticate() {
    $headers = getallheaders();
    $auth = $headers[&#039;Authorization&#039;] ?? &#039;&#039;;

    if (!preg_match(&#039;/Bearer\s+(.*)$/i&#039;, $auth, $matches)) {
        http_response_code(401);
        echo json_encode([&#039;error&#039; =&gt; &#039;No token provided&#039;]);
        exit;
    }

    try {
        return JWT::decode($matches[1], new Key($_ENV[&#039;JWT_SECRET&#039;], &#039;HS256&#039;));
    } catch (Exception $e) {
        http_response_code(401);
        echo json_encode([&#039;error&#039; =&gt; &#039;Invalid token&#039;]);
        exit;
    }
}

$method = $_SERVER[&#039;REQUEST_METHOD&#039;];
$path = parse_url($_SERVER[&#039;REQUEST_URI&#039;], PHP_URL_PATH);

if ($path === &#039;/api/users&#039; &amp;&amp; $method === &#039;GET&#039;) {
    $user = authenticate();
    $users = $pdo-&gt;query(&#039;SELECT id, name, email FROM users&#039;)-&gt;fetchAll(PDO::FETCH_ASSOC);
    echo json_encode($users);
}</code></pre>
<h2>Real-Time with WebSockets</h2>
<p>For real-time features, add WebSocket support. Here's Node.js with the <code>ws</code> library:</p>
<pre><code class="language-javascript">// websocket-server.js
const WebSocket = require(&#039;ws&#039;);
const jwt = require(&#039;jsonwebtoken&#039;);

const wss = new WebSocket.Server({ port: 8080 });

const clients = new Map();

wss.on(&#039;connection&#039;, (ws, req) =&gt; {
  // Authenticate connection
  const url = new URL(req.url, &#039;http://localhost&#039;);
  const token = url.searchParams.get(&#039;token&#039;);

  try {
    const user = jwt.verify(token, process.env.JWT_SECRET);
    clients.set(ws, user);
  } catch {
    ws.close(4001, &#039;Unauthorized&#039;);
    return;
  }

  ws.on(&#039;message&#039;, (data) =&gt; {
    const message = JSON.parse(data);
    handleMessage(ws, message);
  });

  ws.on(&#039;close&#039;, () =&gt; {
    clients.delete(ws);
  });
});

function handleMessage(sender, message) {
  switch (message.type) {
    case &#039;broadcast&#039;:
      // Send to all connected clients
      wss.clients.forEach(client =&gt; {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify(message));
        }
      });
      break;

    case &#039;direct&#039;:
      // Send to specific user
      clients.forEach((user, client) =&gt; {
        if (user.id === message.targetUserId &amp;&amp; client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify(message));
        }
      });
      break;
  }
}</code></pre>
<h2>Database Patterns</h2>
<p>Most backends need a database. Here's a clean repository pattern:</p>
<pre><code class="language-javascript">// user-repository.js
class UserRepository {
  constructor(db) {
    this.db = db;
  }

  async findAll() {
    return this.db.query(&#039;SELECT id, name, email FROM users&#039;);
  }

  async findById(id) {
    const [user] = await this.db.query(
      &#039;SELECT id, name, email FROM users WHERE id = ?&#039;,
      [id]
    );
    return user;
  }

  async create(data) {
    const result = await this.db.query(
      &#039;INSERT INTO users (name, email, password) VALUES (?, ?, ?)&#039;,
      [data.name, data.email, data.hashedPassword]
    );
    return this.findById(result.insertId);
  }

  async update(id, data) {
    await this.db.query(
      &#039;UPDATE users SET name = ?, email = ? WHERE id = ?&#039;,
      [data.name, data.email, id]
    );
    return this.findById(id);
  }

  async delete(id) {
    await this.db.query(&#039;DELETE FROM users WHERE id = ?&#039;, [id]);
  }
}</code></pre>
<h2>Complete CRUD API Example</h2>
<p>Let's build a complete REST API for a todo application with full CRUD operations:</p>
<h3>Express Backend with SQLite</h3>
<pre><code class="language-javascript">// server/app.js
const express = require(&#039;express&#039;);
const cors = require(&#039;cors&#039;);
const sqlite3 = require(&#039;sqlite3&#039;).verbose();
const { open } = require(&#039;sqlite&#039;);

const app = express();
app.use(cors());
app.use(express.json());

// Database setup
let db;
(async () =&gt; {
  db = await open({
    filename: &#039;./database.sqlite&#039;,
    driver: sqlite3.Database
  });

  await db.exec(`
    CREATE TABLE IF NOT EXISTS todos (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      completed BOOLEAN DEFAULT 0,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);
})();

// Get all todos
app.get(&#039;/api/todos&#039;, async (req, res) =&gt; {
  try {
    const todos = await db.all(&#039;SELECT * FROM todos ORDER BY created_at DESC&#039;);
    res.json(todos);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get single todo
app.get(&#039;/api/todos/:id&#039;, async (req, res) =&gt; {
  try {
    const todo = await db.get(&#039;SELECT * FROM todos WHERE id = ?&#039;, req.params.id);
    if (!todo) {
      return res.status(404).json({ error: &#039;Todo not found&#039; });
    }
    res.json(todo);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create todo
app.post(&#039;/api/todos&#039;, async (req, res) =&gt; {
  try {
    const { title } = req.body;
    if (!title) {
      return res.status(400).json({ error: &#039;Title is required&#039; });
    }

    const result = await db.run(
      &#039;INSERT INTO todos (title) VALUES (?)&#039;,
      title
    );

    const todo = await db.get(&#039;SELECT * FROM todos WHERE id = ?&#039;, result.lastID);
    res.status(201).json(todo);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update todo
app.put(&#039;/api/todos/:id&#039;, async (req, res) =&gt; {
  try {
    const { title, completed } = req.body;

    await db.run(
      &#039;UPDATE todos SET title = ?, completed = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?&#039;,
      title,
      completed ? 1 : 0,
      req.params.id
    );

    const todo = await db.get(&#039;SELECT * FROM todos WHERE id = ?&#039;, req.params.id);
    res.json(todo);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Delete todo
app.delete(&#039;/api/todos/:id&#039;, async (req, res) =&gt; {
  try {
    await db.run(&#039;DELETE FROM todos WHERE id = ?&#039;, req.params.id);
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000, () =&gt; console.log(&#039;Server running on http://localhost:3000&#039;));</code></pre>
<h3>Frontend Integration</h3>
<pre><code class="language-javascript">// frontend/services/todo-service.js
class TodoService {
  constructor(baseUrl = &#039;http://localhost:3000/api&#039;) {
    this.baseUrl = baseUrl;
  }

  async getAll() {
    const response = await fetch(`${this.baseUrl}/todos`);
    if (!response.ok) throw new Error(&#039;Failed to fetch todos&#039;);
    return response.json();
  }

  async create(title) {
    const response = await fetch(`${this.baseUrl}/todos`, {
      method: &#039;POST&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify({ title })
    });
    if (!response.ok) throw new Error(&#039;Failed to create todo&#039;);
    return response.json();
  }

  async update(id, updates) {
    const response = await fetch(`${this.baseUrl}/todos/${id}`, {
      method: &#039;PUT&#039;,
      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
      body: JSON.stringify(updates)
    });
    if (!response.ok) throw new Error(&#039;Failed to update todo&#039;);
    return response.json();
  }

  async delete(id) {
    const response = await fetch(`${this.baseUrl}/todos/${id}`, {
      method: &#039;DELETE&#039;
    });
    if (!response.ok) throw new Error(&#039;Failed to delete todo&#039;);
  }
}

export const todoService = new TodoService();</code></pre>
<h2>Using ORMs</h2>
<p>Object-Relational Mappers simplify database operations. Here's Prisma (Node.js) and SQLAlchemy (Python):</p>
<h3>Prisma (Node.js)</h3>
<pre><code class="language-javascript">// prisma/schema.prisma
datasource db {
  provider = &quot;postgresql&quot;
  url      = env(&quot;DATABASE_URL&quot;)
}

generator client {
  provider = &quot;prisma-client-js&quot;
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
  createdAt DateTime @default(now())
}</code></pre>
<pre><code class="language-javascript">// server/routes/posts.js
const { PrismaClient } = require(&#039;@prisma/client&#039;);
const prisma = new PrismaClient();

app.get(&#039;/api/posts&#039;, async (req, res) =&gt; {
  const posts = await prisma.post.findMany({
    include: {
      author: {
        select: { id: true, name: true, email: true }
      }
    },
    orderBy: { createdAt: &#039;desc&#039; }
  });
  res.json(posts);
});

app.post(&#039;/api/posts&#039;, authenticate, async (req, res) =&gt; {
  const { title, content } = req.body;

  const post = await prisma.post.create({
    data: {
      title,
      content,
      author: {
        connect: { id: req.user.id }
      }
    },
    include: { author: true }
  });

  res.status(201).json(post);
});

app.put(&#039;/api/posts/:id&#039;, authenticate, async (req, res) =&gt; {
  const { id } = req.params;
  const { title, content, published } = req.body;

  // Check ownership
  const post = await prisma.post.findUnique({
    where: { id: parseInt(id) }
  });

  if (post.authorId !== req.user.id) {
    return res.status(403).json({ error: &#039;Forbidden&#039; });
  }

  const updated = await prisma.post.update({
    where: { id: parseInt(id) },
    data: { title, content, published },
    include: { author: true }
  });

  res.json(updated);
});</code></pre>
<h3>SQLAlchemy (Python)</h3>
<pre><code class="language-python"># models.py
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base

class User(Base):
    __tablename__ = &quot;users&quot;

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    name = Column(String)
    hashed_password = Column(String)
    posts = relationship(&quot;Post&quot;, back_populates=&quot;author&quot;)
    created_at = Column(DateTime, default=datetime.utcnow)

class Post(Base):
    __tablename__ = &quot;posts&quot;

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    content = Column(Text)
    published = Column(Boolean, default=False)
    author_id = Column(Integer, ForeignKey(&quot;users.id&quot;))
    author = relationship(&quot;User&quot;, back_populates=&quot;posts&quot;)
    created_at = Column(DateTime, default=datetime.utcnow)

# routes.py
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
import models, schemas
from database import get_db

app = FastAPI()

@app.get(&quot;/api/posts&quot;, response_model=List[schemas.Post])
def get_posts(db: Session = Depends(get_db)):
    return db.query(models.Post).order_by(models.Post.created_at.desc()).all()

@app.post(&quot;/api/posts&quot;, response_model=schemas.Post)
def create_post(post: schemas.PostCreate, db: Session = Depends(get_db), user=Depends(get_current_user)):
    db_post = models.Post(**post.dict(), author_id=user.id)
    db.add(db_post)
    db.commit()
    db.refresh(db_post)
    return db_post

@app.put(&quot;/api/posts/{post_id}&quot;, response_model=schemas.Post)
def update_post(post_id: int, post: schemas.PostUpdate, db: Session = Depends(get_db), user=Depends(get_current_user)):
    db_post = db.query(models.Post).filter(models.Post.id == post_id).first()
    if not db_post:
        raise HTTPException(status_code=404, detail=&quot;Post not found&quot;)
    if db_post.author_id != user.id:
        raise HTTPException(status_code=403, detail=&quot;Not authorized&quot;)

    for key, value in post.dict(exclude_unset=True).items():
        setattr(db_post, key, value)

    db.commit()
    db.refresh(db_post)
    return db_post</code></pre>
<h2>File Upload and Download</h2>
<p>Handle file uploads from LARC components:</p>
<h3>Express File Upload</h3>
<pre><code class="language-javascript">// server.js
const multer = require(&#039;multer&#039;);
const path = require(&#039;path&#039;);

// Configure storage
const storage = multer.diskStorage({
  destination: (req, file, cb) =&gt; {
    cb(null, &#039;uploads/&#039;);
  },
  filename: (req, file, cb) =&gt; {
    const uniqueSuffix = Date.now() + &#039;-&#039; + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
  fileFilter: (req, file, cb) =&gt; {
    const allowedTypes = /jpeg|jpg|png|gif|pdf/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);

    if (mimetype &amp;&amp; extname) {
      return cb(null, true);
    }
    cb(new Error(&#039;Invalid file type&#039;));
  }
});

// Upload endpoint
app.post(&#039;/api/upload&#039;, authenticate, upload.single(&#039;file&#039;), async (req, res) =&gt; {
  if (!req.file) {
    return res.status(400).json({ error: &#039;No file uploaded&#039; });
  }

  // Save file metadata to database
  const file = await db.files.create({
    userId: req.user.id,
    filename: req.file.filename,
    originalName: req.file.originalname,
    mimetype: req.file.mimetype,
    size: req.file.size,
    path: req.file.path
  });

  res.json({
    id: file.id,
    filename: file.filename,
    url: `/uploads/${file.filename}`
  });
});

// Download endpoint
app.get(&#039;/api/files/:id/download&#039;, authenticate, async (req, res) =&gt; {
  const file = await db.files.findById(req.params.id);

  if (!file) {
    return res.status(404).json({ error: &#039;File not found&#039; });
  }

  res.download(file.path, file.originalName);
});

// Serve uploaded files
app.use(&#039;/uploads&#039;, express.static(&#039;uploads&#039;));</code></pre>
<h3>Frontend Upload Component</h3>
<pre><code class="language-javascript">class FileUpload extends HTMLElement {
  async handleUpload(e) {
    const file = e.target.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append(&#039;file&#039;, file);

    try {
      const token = auth.getToken();
      const response = await fetch(&#039;http://localhost:3000/api/upload&#039;, {
        method: &#039;POST&#039;,
        headers: {
          &#039;Authorization&#039;: `Bearer ${token}`
        },
        body: formData
      });

      if (!response.ok) throw new Error(&#039;Upload failed&#039;);

      const result = await response.json();
      pan.publish(&#039;file.uploaded&#039;, result);

      this.showSuccess(`File uploaded: ${result.filename}`);
    } catch (error) {
      this.showError(error.message);
    }
  }

  connectedCallback() {
    this.innerHTML = `
      &lt;div class=&quot;upload-container&quot;&gt;
        &lt;input type=&quot;file&quot; id=&quot;file-input&quot;&gt;
        &lt;button onclick=&quot;document.getElementById(&#039;file-input&#039;).click()&quot;&gt;
          Choose File
        &lt;/button&gt;
        &lt;div class=&quot;message&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    `;

    this.querySelector(&#039;#file-input&#039;).addEventListener(&#039;change&#039;, (e) =&gt; {
      this.handleUpload(e);
    });
  }
}

customElements.define(&#039;file-upload&#039;, FileUpload);</code></pre>
<h2>Real-Time Chat Application</h2>
<p>Complete example combining HTTP and WebSocket:</p>
<h3>Backend (Node.js)</h3>
<pre><code class="language-javascript">// chat-server.js
const express = require(&#039;express&#039;);
const http = require(&#039;http&#039;);
const WebSocket = require(&#039;ws&#039;);
const jwt = require(&#039;jsonwebtoken&#039;);

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

app.use(express.json());

// Store active connections
const connections = new Map(); // ws -&gt; user
const rooms = new Map(); // roomId -&gt; Set of ws

// REST API for chat history
app.get(&#039;/api/rooms/:roomId/messages&#039;, authenticate, async (req, res) =&gt; {
  const messages = await db.query(
    &#039;SELECT * FROM messages WHERE room_id = ? ORDER BY created_at ASC&#039;,
    [req.params.roomId]
  );
  res.json(messages);
});

app.post(&#039;/api/rooms/:roomId/messages&#039;, authenticate, async (req, res) =&gt; {
  const { content } = req.body;

  const message = await db.query(
    &#039;INSERT INTO messages (room_id, user_id, content) VALUES (?, ?, ?)&#039;,
    [req.params.roomId, req.user.id, content]
  );

  res.status(201).json(message);
});

// WebSocket for real-time
wss.on(&#039;connection&#039;, (ws, req) =&gt; {
  const url = new URL(req.url, &#039;ws://localhost&#039;);
  const token = url.searchParams.get(&#039;token&#039;);

  try {
    const user = jwt.verify(token, process.env.JWT_SECRET);
    connections.set(ws, user);

    ws.on(&#039;message&#039;, (data) =&gt; {
      const message = JSON.parse(data);
      handleMessage(ws, user, message);
    });

    ws.on(&#039;close&#039;, () =&gt; {
      connections.delete(ws);
      // Remove from all rooms
      rooms.forEach(roomClients =&gt; roomClients.delete(ws));
    });

    ws.send(JSON.stringify({ type: &#039;connected&#039;, user }));
  } catch {
    ws.close(4001, &#039;Unauthorized&#039;);
  }
});

function handleMessage(ws, user, message) {
  switch (message.type) {
    case &#039;join-room&#039;:
      if (!rooms.has(message.roomId)) {
        rooms.set(message.roomId, new Set());
      }
      rooms.get(message.roomId).add(ws);

      // Notify room
      broadcastToRoom(message.roomId, {
        type: &#039;user-joined&#039;,
        user: { id: user.id, name: user.name }
      });
      break;

    case &#039;leave-room&#039;:
      rooms.get(message.roomId)?.delete(ws);

      broadcastToRoom(message.roomId, {
        type: &#039;user-left&#039;,
        user: { id: user.id, name: user.name }
      });
      break;

    case &#039;chat-message&#039;:
      // Save to database
      db.query(
        &#039;INSERT INTO messages (room_id, user_id, content) VALUES (?, ?, ?)&#039;,
        [message.roomId, user.id, message.content]
      ).then(result =&gt; {
        // Broadcast to room
        broadcastToRoom(message.roomId, {
          type: &#039;chat-message&#039;,
          message: {
            id: result.insertId,
            userId: user.id,
            userName: user.name,
            content: message.content,
            createdAt: new Date()
          }
        });
      });
      break;

    case &#039;typing&#039;:
      broadcastToRoom(message.roomId, {
        type: &#039;user-typing&#039;,
        user: { id: user.id, name: user.name }
      }, ws);
      break;
  }
}

function broadcastToRoom(roomId, message, exclude = null) {
  const roomClients = rooms.get(roomId);
  if (!roomClients) return;

  roomClients.forEach(client =&gt; {
    if (client !== exclude &amp;&amp; client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify(message));
    }
  });
}

server.listen(3000, () =&gt; console.log(&#039;Chat server running on port 3000&#039;));</code></pre>
<h3>Frontend Chat Component</h3>
<pre><code class="language-javascript">class ChatRoom extends HTMLElement {
  constructor() {
    super();
    this.roomId = this.getAttribute(&#039;room-id&#039;);
    this.messages = [];
    this.ws = null;
    this.typingTimer = null;
  }

  async connectedCallback() {
    await this.loadHistory();
    this.connectWebSocket();
    this.render();
  }

  async loadHistory() {
    try {
      this.messages = await api.get(`/rooms/${this.roomId}/messages`);
    } catch (error) {
      console.error(&#039;Failed to load chat history:&#039;, error);
    }
  }

  connectWebSocket() {
    const token = auth.getToken();
    this.ws = new WebSocket(`ws://localhost:3000?token=${token}`);

    this.ws.onopen = () =&gt; {
      this.ws.send(JSON.stringify({
        type: &#039;join-room&#039;,
        roomId: this.roomId
      }));
    };

    this.ws.onmessage = (event) =&gt; {
      const data = JSON.parse(event.data);
      this.handleWebSocketMessage(data);
    };

    this.ws.onclose = () =&gt; {
      // Reconnect after 3 seconds
      setTimeout(() =&gt; this.connectWebSocket(), 3000);
    };
  }

  handleWebSocketMessage(data) {
    switch (data.type) {
      case &#039;chat-message&#039;:
        this.messages.push(data.message);
        this.render();
        this.scrollToBottom();
        break;

      case &#039;user-joined&#039;:
        this.showNotification(`${data.user.name} joined`);
        break;

      case &#039;user-left&#039;:
        this.showNotification(`${data.user.name} left`);
        break;

      case &#039;user-typing&#039;:
        this.showTypingIndicator(data.user.name);
        break;
    }
  }

  sendMessage(content) {
    if (!content.trim()) return;

    this.ws.send(JSON.stringify({
      type: &#039;chat-message&#039;,
      roomId: this.roomId,
      content
    }));

    this.querySelector(&#039;#message-input&#039;).value = &#039;&#039;;
  }

  handleTyping() {
    clearTimeout(this.typingTimer);

    this.ws.send(JSON.stringify({
      type: &#039;typing&#039;,
      roomId: this.roomId
    }));

    this.typingTimer = setTimeout(() =&gt; {
      // Stop typing indicator after 2 seconds
    }, 2000);
  }

  render() {
    this.innerHTML = `
      &lt;style&gt;
        .chat-container {
          display: flex;
          flex-direction: column;
          height: 600px;
          border: 1px solid #ddd;
          border-radius: 8px;
        }

        .messages {
          flex: 1;
          overflow-y: auto;
          padding: 20px;
        }

        .message {
          margin-bottom: 15px;
        }

        .message-author {
          font-weight: 600;
          color: #667eea;
        }

        .message-content {
          margin-top: 5px;
        }

        .message-time {
          font-size: 12px;
          color: #999;
        }

        .input-area {
          display: flex;
          gap: 10px;
          padding: 15px;
          border-top: 1px solid #ddd;
        }

        input {
          flex: 1;
          padding: 10px;
          border: 1px solid #ddd;
          border-radius: 4px;
        }

        button {
          padding: 10px 20px;
          background: #667eea;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
      &lt;/style&gt;

      &lt;div class=&quot;chat-container&quot;&gt;
        &lt;div class=&quot;messages&quot;&gt;
          ${this.messages.map(msg =&gt; `
            &lt;div class=&quot;message&quot;&gt;
              &lt;div class=&quot;message-author&quot;&gt;${msg.userName}&lt;/div&gt;
              &lt;div class=&quot;message-content&quot;&gt;${this.escapeHtml(msg.content)}&lt;/div&gt;
              &lt;div class=&quot;message-time&quot;&gt;${new Date(msg.createdAt).toLocaleTimeString()}&lt;/div&gt;
            &lt;/div&gt;
          `).join(&#039;&#039;)}
        &lt;/div&gt;

        &lt;div class=&quot;input-area&quot;&gt;
          &lt;input
            type=&quot;text&quot;
            id=&quot;message-input&quot;
            placeholder=&quot;Type a message...&quot;
          &gt;
          &lt;button id=&quot;send-btn&quot;&gt;Send&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;

    const input = this.querySelector(&#039;#message-input&#039;);
    const sendBtn = this.querySelector(&#039;#send-btn&#039;);

    input.addEventListener(&#039;input&#039;, () =&gt; this.handleTyping());
    input.addEventListener(&#039;keypress&#039;, (e) =&gt; {
      if (e.key === &#039;Enter&#039;) {
        this.sendMessage(input.value);
      }
    });

    sendBtn.addEventListener(&#039;click&#039;, () =&gt; {
      this.sendMessage(input.value);
    });
  }

  escapeHtml(text) {
    const div = document.createElement(&#039;div&#039;);
    div.textContent = text;
    return div.innerHTML;
  }

  scrollToBottom() {
    const messages = this.querySelector(&#039;.messages&#039;);
    messages.scrollTop = messages.scrollHeight;
  }

  disconnectedCallback() {
    if (this.ws) {
      this.ws.send(JSON.stringify({
        type: &#039;leave-room&#039;,
        roomId: this.roomId
      }));
      this.ws.close();
    }
  }
}

customElements.define(&#039;chat-room&#039;, ChatRoom);</code></pre>
<h2>Troubleshooting</h2>
<h3>Problem: CORS Errors in Development</h3>
<strong>Symptom</strong>: <code>Access-Control-Allow-Origin</code> errors
<strong>Solution</strong>: Configure CORS properly for development:
<pre><code class="language-javascript">// Express
const cors = require(&#039;cors&#039;);
app.use(cors({
  origin: &#039;http://localhost:5173&#039;, // Your frontend URL
  credentials: true
}));

// Or for all origins in development
if (process.env.NODE_ENV === &#039;development&#039;) {
  app.use(cors({ origin: &#039;*&#039; }));
}</code></pre>
<h3>Problem: Database Connection Pool Exhaustion</h3>
<strong>Symptom</strong>: "Too many connections" errors
<strong>Solution</strong>: Configure connection pooling:
<pre><code class="language-javascript">const { Pool } = require(&#039;pg&#039;);

const pool = new Pool({
  max: 20, // Maximum connections
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Always release connections
app.get(&#039;/api/users&#039;, async (req, res) =&gt; {
  const client = await pool.connect();
  try {
    const result = await client.query(&#039;SELECT * FROM users&#039;);
    res.json(result.rows);
  } finally {
    client.release(); // Important!
  }
});</code></pre>
<h3>Problem: File Uploads Failing</h3>
<strong>Symptom</strong>: 413 Payload Too Large or multipart parsing errors
<strong>Solution</strong>: Increase limits and configure multer properly:
<pre><code class="language-javascript">app.use(express.json({ limit: &#039;10mb&#039; }));
app.use(express.urlencoded({ limit: &#039;10mb&#039;, extended: true }));

const upload = multer({
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 5 // Max 5 files
  }
});</code></pre>
<h3>Problem: WebSocket Connection Drops</h3>
<strong>Symptom</strong>: Frequent disconnections
<strong>Solution</strong>: Implement heartbeat/ping-pong:
<pre><code class="language-javascript">// Server
wss.on(&#039;connection&#039;, (ws) =&gt; {
  ws.isAlive = true;
  ws.on(&#039;pong&#039;, () =&gt; {
    ws.isAlive = true;
  });
});

// Ping clients every 30 seconds
const interval = setInterval(() =&gt; {
  wss.clients.forEach((ws) =&gt; {
    if (ws.isAlive === false) return ws.terminate();

    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

// Client
setInterval(() =&gt; {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: &#039;ping&#039; }));
  }
}, 30000);</code></pre>
<h2>Best Practices</h2>
<li><strong>Use environment variables</strong> - Never hardcode secrets or config</li>
<li><strong>Validate input</strong> - Always validate on the server, not just client</li>
<li><strong>Use connection pooling</strong> - Reuse database connections</li>
<li><strong>Implement rate limiting</strong> - Prevent abuse with rate limits</li>
<li><strong>Log errors properly</strong> - Use structured logging (Winston, Bunyan)</li>
<li><strong>Handle graceful shutdown</strong> - Close connections properly on SIGTERM</li>
<li><strong>Use transactions</strong> - For operations that must succeed or fail together</li>
<li><strong>Sanitize user input</strong> - Prevent SQL injection and XSS</li>
<li><strong>Set security headers</strong> - Use helmet.js or similar</li>
<li><strong>Monitor performance</strong> - Use APM tools (New Relic, DataDog)</li>
<h2>Exercises</h2>
<h3>Exercise 1: Build a Blog API</h3>
<p>Create a REST API with:</p>
<ul><li>User registration and authentication</li>
<li>CRUD operations for blog posts</li>
<li>Comments on posts</li>
<li>Search functionality</li>
<li>Tag/category filtering</li>
</ul>
<strong>Bonus</strong>: Add pagination and sorting options.
<h3>Exercise 2: Real-Time Notifications</h3>
<p>Build a notification system with:</p>
<ul><li>WebSocket connection for real-time delivery</li>
<li>Fallback to polling if WebSocket unavailable</li>
<li>Mark as read/unread functionality</li>
<li>Notification categories (info, warning, error)</li>
<li>Persistence to database</li>
</ul>
<strong>Bonus</strong>: Add push notifications for mobile.
<h3>Exercise 3: File Management System</h3>
<p>Create a file management API with:</p>
<ul><li>Upload multiple files</li>
<li>Organize files in folders</li>
<li>Share files with other users</li>
<li>Generate temporary download links</li>
<li>Thumbnail generation for images</li>
</ul>
<strong>Bonus</strong>: Implement file versioning.
<h3>Exercise 4: GraphQL API</h3>
<p>Convert a REST API to GraphQL:</p>
<ul><li>Define schema for users, posts, comments</li>
<li>Implement resolvers</li>
<li>Add authentication to resolvers</li>
<li>Implement subscriptions for real-time</li>
<li>Optimize N+1 queries with DataLoader</li>
</ul>
<strong>Bonus</strong>: Add GraphQL Playground for testing.
<hr>
<h2>Summary</h2>
<p>Server integration with LARC follows standard web patterns—your frontend communicates via HTTP and WebSockets, regardless of backend technology:</p>
<ul><li><strong>REST APIs</strong> with Express, Flask, FastAPI, or PHP</li>
<li><strong>ORMs</strong> like Prisma, SQLAlchemy for database access</li>
<li><strong>File uploads</strong> with multer or similar libraries</li>
<li><strong>Real-time features</strong> with WebSockets</li>
<li><strong>Authentication</strong> via JWT tokens</li>
<li><strong>Database patterns</strong> with repositories and connection pooling</li>
</ul>
LARC doesn't dictate your backend choices. Use whatever server technology fits your team's expertise and requirements. The PAN bus on the frontend keeps your components decoupled from implementation details.
<hr>
<h2>Further Reading</h2>
<strong>For complete server integration reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 13: Server Integration - Backend patterns and API design</li>
<li><em>Building with LARC</em> Chapter 7: Data Fetching and APIs - HTTP and WebSocket patterns</li>
<li><em>Building with LARC</em> Appendix E: Recipes and Patterns - Server integration recipes</li>
</ul>
<div class="pagebreak"></div>
<h1>Testing</h1>
<p>Testing isn't optional. It's how you know your code works, how you prevent regressions, and how you confidently refactor. LARC applications benefit from the same testing strategies as any JavaScript application, with some patterns specific to Web Components.</p>
<h2>Unit Testing Components</h2>
<p>The <code>@open-wc/testing</code> library provides excellent utilities for testing Web Components:</p>
<pre><code class="language-javascript">// user-card.test.js
import { expect, fixture, html } from &#039;@open-wc/testing&#039;;
import &#039;../components/user-card.js&#039;;

describe(&#039;UserCard&#039;, () =&gt; {
  it(&#039;renders user name and email&#039;, async () =&gt; {
    const el = await fixture(html`
      &lt;user-card&gt;&lt;/user-card&gt;
    `);

    el.user = { name: &#039;Alice&#039;, email: &#039;alice@example.com&#039; };
    await el.updateComplete;

    const name = el.shadowRoot.querySelector(&#039;.name&#039;);
    const email = el.shadowRoot.querySelector(&#039;.email&#039;);

    expect(name.textContent).to.equal(&#039;Alice&#039;);
    expect(email.textContent).to.equal(&#039;alice@example.com&#039;);
  });

  it(&#039;dispatches follow event when button clicked&#039;, async () =&gt; {
    const el = await fixture(html`&lt;user-card&gt;&lt;/user-card&gt;`);
    el.user = { id: 1, name: &#039;Alice&#039; };

    let eventDetail = null;
    el.addEventListener(&#039;follow&#039;, (e) =&gt; {
      eventDetail = e.detail;
    });

    el.shadowRoot.querySelector(&#039;.follow-btn&#039;).click();

    expect(eventDetail).to.deep.equal({ userId: 1 });
  });

  it(&#039;shows loading state initially&#039;, async () =&gt; {
    const el = await fixture(html`&lt;user-card loading&gt;&lt;/user-card&gt;`);

    const spinner = el.shadowRoot.querySelector(&#039;.spinner&#039;);
    expect(spinner).to.exist;
  });
});</code></pre>
<h2>Testing PAN Bus Integration</h2>
<p>Mock the PAN bus to test component communication:</p>
<pre><code class="language-javascript">// pan-mock.js
class MockPanBus {
  constructor() {
    this.messages = [];
    this.subscriptions = new Map();
  }

  publish(topic, data) {
    this.messages.push({ topic, data });
    const handlers = this.subscriptions.get(topic) || [];
    handlers.forEach(handler =&gt; handler(data));
  }

  subscribe(topic, handler) {
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.set(topic, []);
    }
    this.subscriptions.get(topic).push(handler);
    return () =&gt; this.unsubscribe(topic, handler);
  }

  unsubscribe(topic, handler) {
    const handlers = this.subscriptions.get(topic) || [];
    const index = handlers.indexOf(handler);
    if (index &gt; -1) handlers.splice(index, 1);
  }

  clear() {
    this.messages = [];
    this.subscriptions.clear();
  }
}

export const mockPan = new MockPanBus();</code></pre>
<p>Use it in tests:</p>
<pre><code class="language-javascript">import { mockPan } from &#039;./pan-mock.js&#039;;

describe(&#039;NotificationList&#039;, () =&gt; {
  beforeEach(() =&gt; mockPan.clear());

  it(&#039;displays notifications from PAN bus&#039;, async () =&gt; {
    const el = await fixture(html`&lt;notification-list&gt;&lt;/notification-list&gt;`);

    mockPan.publish(&#039;notification.new&#039;, {
      id: 1,
      message: &#039;Hello world&#039;
    });

    await el.updateComplete;

    const notifications = el.shadowRoot.querySelectorAll(&#039;.notification&#039;);
    expect(notifications.length).to.equal(1);
    expect(notifications[0].textContent).to.include(&#039;Hello world&#039;);
  });
});</code></pre>
<h2>Integration Testing</h2>
<p>Test components working together:</p>
<pre><code class="language-javascript">describe(&#039;Shopping Cart Integration&#039;, () =&gt; {
  it(&#039;updates cart when product added&#039;, async () =&gt; {
    const cart = await fixture(html`&lt;shopping-cart&gt;&lt;/shopping-cart&gt;`);
    const product = await fixture(html`
      &lt;product-card .product=${{ id: 1, name: &#039;Widget&#039;, price: 10 }}&gt;
      &lt;/product-card&gt;
    `);

    // Simulate add to cart
    product.shadowRoot.querySelector(&#039;.add-btn&#039;).click();

    await cart.updateComplete;

    expect(cart.items.length).to.equal(1);
    expect(cart.total).to.equal(10);
  });
});</code></pre>
<h2>End-to-End Testing with Playwright</h2>
<p>For full user flow testing, Playwright provides excellent browser automation:</p>
<pre><code class="language-javascript">// e2e/login.spec.js
import { test, expect } from &#039;@playwright/test&#039;;

test.describe(&#039;Login Flow&#039;, () =&gt; {
  test(&#039;successful login redirects to dashboard&#039;, async ({ page }) =&gt; {
    await page.goto(&#039;/login&#039;);

    await page.fill(&#039;input[name=&quot;email&quot;]&#039;, &#039;user@example.com&#039;);
    await page.fill(&#039;input[name=&quot;password&quot;]&#039;, &#039;password123&#039;);
    await page.click(&#039;button[type=&quot;submit&quot;]&#039;);

    await expect(page).toHaveURL(&#039;/dashboard&#039;);
    await expect(page.locator(&#039;h1&#039;)).toHaveText(&#039;Dashboard&#039;);
  });

  test(&#039;invalid credentials show error&#039;, async ({ page }) =&gt; {
    await page.goto(&#039;/login&#039;);

    await page.fill(&#039;input[name=&quot;email&quot;]&#039;, &#039;wrong@example.com&#039;);
    await page.fill(&#039;input[name=&quot;password&quot;]&#039;, &#039;wrongpassword&#039;);
    await page.click(&#039;button[type=&quot;submit&quot;]&#039;);

    await expect(page.locator(&#039;.error&#039;)).toHaveText(&#039;Invalid credentials&#039;);
    await expect(page).toHaveURL(&#039;/login&#039;);
  });
});</code></pre>
<h2>Mocking Fetch Requests</h2>
<p>Control network responses in tests:</p>
<pre><code class="language-javascript">// fetch-mock.js
class FetchMock {
  constructor() {
    this.mocks = new Map();
    this.originalFetch = window.fetch;
  }

  mock(url, response, options = {}) {
    this.mocks.set(url, { response, options });
  }

  enable() {
    window.fetch = async (url, config) =&gt; {
      const mock = this.mocks.get(url);
      if (mock) {
        if (mock.options.delay) {
          await new Promise(r =&gt; setTimeout(r, mock.options.delay));
        }
        return new Response(JSON.stringify(mock.response), {
          status: mock.options.status || 200,
          headers: { &#039;Content-Type&#039;: &#039;application/json&#039; }
        });
      }
      return this.originalFetch(url, config);
    };
  }

  disable() {
    window.fetch = this.originalFetch;
    this.mocks.clear();
  }
}

export const fetchMock = new FetchMock();</code></pre>
<p>Use in tests:</p>
<pre><code class="language-javascript">import { fetchMock } from &#039;./fetch-mock.js&#039;;

describe(&#039;UserList Component&#039;, () =&gt; {
  beforeEach(() =&gt; {
    fetchMock.enable();
    fetchMock.mock(&#039;/api/users&#039;, [
      { id: 1, name: &#039;Alice&#039; },
      { id: 2, name: &#039;Bob&#039; }
    ]);
  });

  afterEach(() =&gt; {
    fetchMock.disable();
  });

  it(&#039;loads and displays users&#039;, async () =&gt; {
    const el = await fixture(html`&lt;user-list&gt;&lt;/user-list&gt;`);
    await el.updateComplete;

    const users = el.shadowRoot.querySelectorAll(&#039;.user&#039;);
    expect(users.length).to.equal(2);
  });
});</code></pre>
<h2>Visual Regression Testing</h2>
<p>Catch visual changes with screenshot comparison:</p>
<pre><code class="language-javascript">// visual.test.js
import { test, expect } from &#039;@playwright/test&#039;;

test.describe(&#039;Visual Regression&#039;, () =&gt; {
  test(&#039;button should match snapshot&#039;, async ({ page }) =&gt; {
    await page.goto(&#039;/components/button&#039;);

    const button = page.locator(&#039;app-button&#039;);
    await expect(button).toHaveScreenshot(&#039;button-default.png&#039;);
  });

  test(&#039;button hover state&#039;, async ({ page }) =&gt; {
    await page.goto(&#039;/components/button&#039;);

    const button = page.locator(&#039;app-button&#039;);
    await button.hover();
    await expect(button).toHaveScreenshot(&#039;button-hover.png&#039;);
  });

  test(&#039;dark mode theme&#039;, async ({ page }) =&gt; {
    await page.goto(&#039;/&#039;);
    await page.locator(&#039;[data-theme-toggle]&#039;).click();

    await expect(page).toHaveScreenshot(&#039;homepage-dark.png&#039;, {
      fullPage: true
    });
  });
});</code></pre>
<p>Run visual tests:</p>
<pre><code class="language-bash"># First run creates baseline screenshots
npx playwright test visual.test.js

# Subsequent runs compare against baseline
npx playwright test visual.test.js

# Update baselines when changes are intentional
npx playwright test visual.test.js --update-snapshots</code></pre>
<h2>Test Coverage</h2>
<p>Track which code is tested:</p>
<pre><code class="language-javascript">// web-test-runner.config.js
export default {
  coverage: true,
  coverageConfig: {
    threshold: {
      statements: 80,
      branches: 75,
      functions: 80,
      lines: 80
    },
    include: [&#039;src/**/*.js&#039;],
    exclude: [&#039;src/**/*.test.js&#039;, &#039;src/test/**&#039;]
  }
};</code></pre>
<p>Generate coverage reports:</p>
<pre><code class="language-bash">npx wtr --coverage

# View HTML report
open coverage/index.html</code></pre>
<h3>What to Test</h3>
<p>Focus on:</p>
<ul><li><strong>Public API</strong> - Methods users will call</li>
<li><strong>Edge cases</strong> - Empty inputs, null values, errors</li>
<li><strong>State changes</strong> - Component updates correctly</li>
<li><strong>User interactions</strong> - Clicks, typing, form submission</li>
<li><strong>Integration points</strong> - Component communication</li>
</ul>
Skip testing:
<ul><li><strong>Framework internals</strong> - Trust Web Components API</li>
<li><strong>Third-party libraries</strong> - They have their own tests</li>
<li><strong>Trivial code</strong> - Simple getters/setters</li>
</ul>
<h2>Component Testing Patterns</h2>
<h3>Testing Async Loading</h3>
<pre><code class="language-javascript">it(&#039;shows loading state then data&#039;, async () =&gt; {
  const el = await fixture(html`&lt;user-profile user-id=&quot;1&quot;&gt;&lt;/user-profile&gt;`);

  // Should show loading initially
  expect(el.shadowRoot.querySelector(&#039;.loading&#039;)).to.exist;

  // Wait for data
  await waitUntil(() =&gt; !el.loading);

  // Should show user data
  expect(el.shadowRoot.querySelector(&#039;.user-name&#039;)).to.have.text(&#039;Alice&#039;);
  expect(el.shadowRoot.querySelector(&#039;.loading&#039;)).to.not.exist;
});</code></pre>
<h3>Testing Error States</h3>
<pre><code class="language-javascript">it(&#039;displays error message on fetch failure&#039;, async () =&gt; {
  fetchMock.mock(&#039;/api/users&#039;, { error: &#039;Server error&#039; }, { status: 500 });

  const el = await fixture(html`&lt;user-list&gt;&lt;/user-list&gt;`);
  await el.updateComplete;

  expect(el.shadowRoot.querySelector(&#039;.error&#039;)).to.have.text(&#039;Failed to load users&#039;);
});</code></pre>
<h3>Testing Form Validation</h3>
<pre><code class="language-javascript">it(&#039;validates email format&#039;, async () =&gt; {
  const el = await fixture(html`&lt;login-form&gt;&lt;/login-form&gt;`);

  const emailInput = el.shadowRoot.querySelector(&#039;#email&#039;);
  const form = el.shadowRoot.querySelector(&#039;form&#039;);

  // Invalid email
  emailInput.value = &#039;notanemail&#039;;
  emailInput.dispatchEvent(new Event(&#039;input&#039;));

  expect(el.errors.email).to.equal(&#039;Invalid email format&#039;);

  // Valid email
  emailInput.value = &#039;user@example.com&#039;;
  emailInput.dispatchEvent(new Event(&#039;input&#039;));

  expect(el.errors.email).to.be.undefined;
});</code></pre>
<h3>Testing Component Communication</h3>
<pre><code class="language-javascript">it(&#039;publishes event on button click&#039;, async () =&gt; {
  const el = await fixture(html`&lt;add-todo&gt;&lt;/add-todo&gt;`);

  let publishedData = null;
  mockPan.subscribe(&#039;todo.added&#039;, (msg) =&gt; {
    publishedData = msg.data;
  });

  el.shadowRoot.querySelector(&#039;#todo-input&#039;).value = &#039;Buy milk&#039;;
  el.shadowRoot.querySelector(&#039;button&#039;).click();

  expect(publishedData).to.deep.equal({ text: &#039;Buy milk&#039; });
});</code></pre>
<h2>CI/CD Integration</h2>
<h3>GitHub Actions</h3>
<pre><code class="language-yaml"># .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: &#039;18&#039;
          cache: &#039;npm&#039;

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm test

      - name: Run E2E tests
        run: npx playwright test

      - name: Upload test results
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: test-results/

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info</code></pre>
<h3>GitLab CI</h3>
<pre><code class="language-yaml"># .gitlab-ci.yml
stages:
  - test
  - report

test:
  stage: test
  image: node:18
  cache:
    paths:
      - node_modules/
  script:
    - npm ci
    - npm test
    - npx playwright test
  artifacts:
    when: always
    paths:
      - coverage/
      - test-results/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

coverage:
  stage: report
  image: node:18
  script:
    - npx nyc report --reporter=text-summary
  coverage: &#039;/Lines\s*:\s*(\d+\.\d+)%/&#039;</code></pre>
<h2>Test-Driven Development (TDD)</h2>
<p>Write tests first, then implement:</p>
<h3>Example: Building a Counter Component</h3>
<strong>Step 1: Write the test</strong>
<pre><code class="language-javascript">// counter.test.js
describe(&#039;Counter&#039;, () =&gt; {
  it(&#039;starts at zero&#039;, async () =&gt; {
    const counter = await fixture(html`&lt;app-counter&gt;&lt;/app-counter&gt;`);
    expect(counter.shadowRoot.querySelector(&#039;.count&#039;).textContent).to.equal(&#039;0&#039;);
  });

  it(&#039;increments when plus button clicked&#039;, async () =&gt; {
    const counter = await fixture(html`&lt;app-counter&gt;&lt;/app-counter&gt;`);

    counter.shadowRoot.querySelector(&#039;.plus-btn&#039;).click();
    await counter.updateComplete;

    expect(counter.shadowRoot.querySelector(&#039;.count&#039;).textContent).to.equal(&#039;1&#039;);
  });

  it(&#039;decrements when minus button clicked&#039;, async () =&gt; {
    const counter = await fixture(html`&lt;app-counter&gt;&lt;/app-counter&gt;`);

    counter.shadowRoot.querySelector(&#039;.plus-btn&#039;).click();
    await counter.updateComplete;

    counter.shadowRoot.querySelector(&#039;.minus-btn&#039;).click();
    await counter.updateComplete;

    expect(counter.shadowRoot.querySelector(&#039;.count&#039;).textContent).to.equal(&#039;0&#039;);
  });

  it(&#039;never goes below zero&#039;, async () =&gt; {
    const counter = await fixture(html`&lt;app-counter&gt;&lt;/app-counter&gt;`);

    counter.shadowRoot.querySelector(&#039;.minus-btn&#039;).click();
    await counter.updateComplete;

    expect(counter.shadowRoot.querySelector(&#039;.count&#039;).textContent).to.equal(&#039;0&#039;);
  });
});</code></pre>
<strong>Step 2: Run tests (they fail)</strong>
<pre><code class="language-bash">npx wtr
# All tests fail - component doesn&#039;t exist yet</code></pre>
<strong>Step 3: Implement minimal code</strong>
<pre><code class="language-javascript">// counter.js
class Counter extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.count = 0;
  }

  connectedCallback() {
    this.render();
  }

  increment() {
    this.count++;
    this.render();
  }

  decrement() {
    if (this.count &gt; 0) {
      this.count--;
      this.render();
    }
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;div&gt;
        &lt;button class=&quot;minus-btn&quot;&gt;-&lt;/button&gt;
        &lt;span class=&quot;count&quot;&gt;${this.count}&lt;/span&gt;
        &lt;button class=&quot;plus-btn&quot;&gt;+&lt;/button&gt;
      &lt;/div&gt;
    `;

    this.shadowRoot.querySelector(&#039;.plus-btn&#039;).addEventListener(&#039;click&#039;, () =&gt; this.increment());
    this.shadowRoot.querySelector(&#039;.minus-btn&#039;).addEventListener(&#039;click&#039;, () =&gt; this.decrement());
  }

  get updateComplete() {
    return Promise.resolve();
  }
}

customElements.define(&#039;app-counter&#039;, Counter);</code></pre>
<strong>Step 4: Run tests (they pass)</strong>
<pre><code class="language-bash">npx wtr
# All tests pass!</code></pre>
<strong>Step 5: Refactor with confidence</strong>
<p>Tests ensure refactoring doesn't break functionality.</p>
<h2>Advanced Testing Patterns</h2>
<h3>Testing Custom Events</h3>
<pre><code class="language-javascript">it(&#039;dispatches custom event with detail&#039;, async () =&gt; {
  const el = await fixture(html`&lt;product-card&gt;&lt;/product-card&gt;`);

  let eventDetail = null;
  el.addEventListener(&#039;add-to-cart&#039;, (e) =&gt; {
    eventDetail = e.detail;
  });

  el.shadowRoot.querySelector(&#039;.add-btn&#039;).click();

  expect(eventDetail).to.deep.equal({
    productId: 123,
    quantity: 1
  });
});</code></pre>
<h3>Testing Slots</h3>
<pre><code class="language-javascript">it(&#039;renders slotted content&#039;, async () =&gt; {
  const el = await fixture(html`
    &lt;card-component&gt;
      &lt;h2 slot=&quot;title&quot;&gt;My Title&lt;/h2&gt;
      &lt;p&gt;My content&lt;/p&gt;
    &lt;/card-component&gt;
  `);

  const title = el.shadowRoot.querySelector(&#039;slot[name=&quot;title&quot;]&#039;);
  const assignedNodes = title.assignedNodes();

  expect(assignedNodes[0].textContent).to.equal(&#039;My Title&#039;);
});</code></pre>
<h3>Testing Accessibility</h3>
<pre><code class="language-javascript">import { expect } from &#039;@open-wc/testing&#039;;

it(&#039;is accessible&#039;, async () =&gt; {
  const el = await fixture(html`&lt;my-button&gt;Click me&lt;/my-button&gt;`);

  await expect(el).to.be.accessible();
});

it(&#039;has correct ARIA attributes&#039;, async () =&gt; {
  const el = await fixture(html`&lt;dialog-box&gt;&lt;/dialog-box&gt;`);

  const dialog = el.shadowRoot.querySelector(&#039;[role=&quot;dialog&quot;]&#039;);
  expect(dialog).to.have.attribute(&#039;aria-modal&#039;, &#039;true&#039;);
  expect(dialog).to.have.attribute(&#039;aria-labelledby&#039;);
});</code></pre>
<h3>Testing Keyboard Navigation</h3>
<pre><code class="language-javascript">it(&#039;navigates with arrow keys&#039;, async () =&gt; {
  const el = await fixture(html`
    &lt;tab-panel&gt;
      &lt;tab-item&gt;Tab 1&lt;/tab-item&gt;
      &lt;tab-item&gt;Tab 2&lt;/tab-item&gt;
      &lt;tab-item&gt;Tab 3&lt;/tab-item&gt;
    &lt;/tab-panel&gt;
  `);

  const tabs = el.shadowRoot.querySelectorAll(&#039;tab-item&#039;);

  // Focus first tab
  tabs[0].focus();

  // Press arrow right
  tabs[0].dispatchEvent(new KeyboardEvent(&#039;keydown&#039;, { key: &#039;ArrowRight&#039; }));

  expect(document.activeElement).to.equal(tabs[1]);
});</code></pre>
<h2>Performance Testing</h2>
<p>Test component performance:</p>
<pre><code class="language-javascript">it(&#039;renders large list efficiently&#039;, async () =&gt; {
  const items = Array.from({ length: 10000 }, (_, i) =&gt; ({
    id: i,
    name: `Item ${i}`
  }));

  const startTime = performance.now();

  const el = await fixture(html`&lt;virtual-list .items=${items}&gt;&lt;/virtual-list&gt;`);
  await el.updateComplete;

  const renderTime = performance.now() - startTime;

  // Should render in under 100ms
  expect(renderTime).to.be.lessThan(100);

  // Should only render visible items
  const renderedItems = el.shadowRoot.querySelectorAll(&#039;.item&#039;);
  expect(renderedItems.length).to.be.lessThan(50);
});</code></pre>
<h2>Troubleshooting Tests</h2>
<h3>Problem: Tests Pass Locally but Fail in CI</h3>
<strong>Symptom</strong>: Tests work on your machine but fail in GitHub Actions
<strong>Solution</strong>: Common issues:
<pre><code class="language-javascript">// 1. Timing issues - add proper waits
await waitUntil(() =&gt; el.shadowRoot.querySelector(&#039;.data&#039;));

// 2. Browser differences - use consistent browser
// playwright.config.js
projects: [
  { name: &#039;chromium&#039;, use: { ...devices[&#039;Desktop Chrome&#039;] } }
]

// 3. Port conflicts - use random ports
const port = Math.floor(Math.random() * 10000) + 50000;</code></pre>
<h3>Problem: Flaky Tests</h3>
<strong>Symptom</strong>: Tests sometimes pass, sometimes fail
<strong>Solution</strong>:
<pre><code class="language-javascript">// Bad: Fixed timeout
await new Promise(resolve =&gt; setTimeout(resolve, 1000));

// Good: Wait for condition
await waitUntil(() =&gt; el.dataLoaded);

// Bad: Race condition
el.loadData();
expect(el.data).to.exist;

// Good: Wait for async
await el.loadData();
expect(el.data).to.exist;</code></pre>
<h3>Problem: Slow Tests</h3>
<strong>Symptom</strong>: Test suite takes too long
<strong>Solution</strong>:
<pre><code class="language-javascript">// 1. Run tests in parallel
// web-test-runner.config.js
export default {
  concurrency: 10,
  nodeResolve: true
};

// 2. Mock expensive operations
beforeEach(() =&gt; {
  fetchMock.mock(&#039;/api/expensive&#039;, cachedData);
});

// 3. Skip browser for pure logic
describe(&#039;pure functions&#039;, () =&gt; {
  it(&#039;calculates correctly&#039;, () =&gt; {
    expect(calculateTotal([1, 2, 3])).to.equal(6);
  });
});</code></pre>
<h2>Best Practices</h2>
<li><strong>Test behavior, not implementation</strong> - Test what users see, not internal details</li>
<li><strong>Keep tests focused</strong> - One assertion per test when possible</li>
<li><strong>Use descriptive names</strong> - Test names should document behavior</li>
<li><strong>Avoid test interdependence</strong> - Each test should run independently</li>
<li><strong>Mock external dependencies</strong> - Don't rely on real APIs</li>
<li><strong>Test error paths</strong> - Test failures, not just successes</li>
<li><strong>Run tests often</strong> - Catch bugs early</li>
<li><strong>Maintain test code</strong> - Refactor tests like production code</li>
<li><strong>Use setup/teardown</strong> - DRY principle applies to tests</li>
<li><strong>Achieve good coverage</strong> - Aim for 80%+, but focus on critical paths</li>
<h2>Exercises</h2>
<h3>Exercise 1: Test a Todo Component</h3>
<p>Write comprehensive tests for a todo component:</p>
<ul><li>Renders list of todos</li>
<li>Adds new todo when form submitted</li>
<li>Toggles complete status on click</li>
<li>Deletes todo when delete button clicked</li>
<li>Shows empty state when no todos</li>
<li>Validates input before adding</li>
</ul>
<strong>Bonus</strong>: Test keyboard shortcuts (Enter to submit, Escape to clear).
<h3>Exercise 2: E2E Shopping Flow</h3>
<p>Create E2E tests for shopping cart:</p>
<ul><li>Browse products</li>
<li>Add items to cart</li>
<li>Update quantities</li>
<li>Apply coupon code</li>
<li>Complete checkout</li>
<li>Verify order confirmation</li>
</ul>
<strong>Bonus</strong>: Test as guest and authenticated user.
<h3>Exercise 3: Visual Regression Suite</h3>
<p>Set up visual regression testing:</p>
<ul><li>Capture screenshots of all components</li>
<li>Test different states (hover, focus, disabled)</li>
<li>Test responsive breakpoints</li>
<li>Test dark/light themes</li>
<li>Integrate into CI pipeline</li>
</ul>
<strong>Bonus</strong>: Add Percy or Chromatic for cloud-based visual testing.
<h3>Exercise 4: TDD Calculator</h3>
<p>Build a calculator component using TDD:</p>
<ul><li>Write tests first for basic operations (+, -, ×, ÷)</li>
<li>Implement each operation one at a time</li>
<li>Add tests for edge cases (divide by zero, overflow)</li>
<li>Add memory functions (MC, MR, M+, M-)</li>
<li>Keep tests passing throughout</li>
</ul>
<strong>Bonus</strong>: Add scientific functions (sin, cos, sqrt).
<hr>
<h2>Summary</h2>
<p>Testing ensures your LARC applications work correctly and continue working as you make changes:</p>
<ul><li><strong>Unit tests</strong> verify individual components in isolation</li>
<li><strong>Integration tests</strong> verify components work together</li>
<li><strong>E2E tests</strong> verify complete user workflows</li>
<li><strong>Visual regression tests</strong> catch unintended visual changes</li>
<li><strong>Test coverage</strong> ensures critical code is tested</li>
<li><strong>CI/CD integration</strong> catches problems before deployment</li>
<li><strong>TDD</strong> helps design better components</li>
</ul>
Good tests give you confidence to refactor, add features, and deploy. They're not overhead—they're insurance that saves time debugging production issues.
<hr>
<h2>Further Reading</h2>
<strong>For complete testing reference:</strong>
<ul><li><em>Building with LARC</em> Chapter 13: Testing Strategies - All testing patterns and tools</li>
<li><em>Building with LARC</em> Appendix E: Recipes and Patterns - Testing recipes and examples</li>
<li><a href="https://open-wc.org/docs/testing/testing-package/">@open-wc/testing documentation</a></li>
<li><a href="https://playwright.dev/">Playwright documentation</a></li>
</ul>
<div class="pagebreak"></div>
<h1>Performance and Optimization</h1>
<p>Performance is a feature. Slow applications frustrate users and hurt business metrics. LARC's no-build philosophy gives you a head start—no framework overhead, no transpilation artifacts—but there's more you can do.</p>
<h2>Lazy Loading Components</h2>
<p>Don't load everything upfront. Load components when needed:</p>
<pre><code class="language-javascript">// Lazy load on route change
pan.subscribe(&#039;router.navigate&#039;, async ({ path }) =&gt; {
  if (path === &#039;/admin&#039;) {
    await import(&#039;./components/admin-panel.js&#039;);
  }
});

// Lazy load on user interaction
document.querySelector(&#039;.show-chart&#039;).addEventListener(&#039;click&#039;, async () =&gt; {
  const { ChartComponent } = await import(&#039;./components/chart.js&#039;);
  // Use component
}, { once: true });

// Lazy load when visible
const observer = new IntersectionObserver(async (entries) =&gt; {
  for (const entry of entries) {
    if (entry.isIntersecting) {
      const component = entry.target.dataset.component;
      await import(`./components/${component}.js`);
      observer.unobserve(entry.target);
    }
  }
});

document.querySelectorAll(&#039;[data-lazy]&#039;).forEach(el =&gt; observer.observe(el));</code></pre>
<h2>Image Optimization</h2>
<p>Images are often the largest assets. Optimize them:</p>
<pre><code class="language-javascript">class LazyImage extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;img
        loading=&quot;lazy&quot;
        src=&quot;${this.getAttribute(&#039;placeholder&#039;) || &#039;placeholder.svg&#039;}&quot;
        data-src=&quot;${this.getAttribute(&#039;src&#039;)}&quot;
        alt=&quot;${this.getAttribute(&#039;alt&#039;) || &#039;&#039;}&quot;
      &gt;
    `;

    const img = this.querySelector(&#039;img&#039;);

    const observer = new IntersectionObserver((entries) =&gt; {
      entries.forEach(entry =&gt; {
        if (entry.isIntersecting) {
          img.src = img.dataset.src;
          observer.unobserve(img);
        }
      });
    });

    observer.observe(img);
  }
}

customElements.define(&#039;lazy-image&#039;, LazyImage);</code></pre>
<p>Use responsive images with srcset:</p>
<pre><code class="language-html">&lt;img
  srcset=&quot;image-400.jpg 400w,
          image-800.jpg 800w,
          image-1200.jpg 1200w&quot;
  sizes=&quot;(max-width: 400px) 400px,
         (max-width: 800px) 800px,
         1200px&quot;
  src=&quot;image-800.jpg&quot;
  alt=&quot;Responsive image&quot;
  loading=&quot;lazy&quot;
&gt;</code></pre>
<h2>Service Worker Caching</h2>
<p>Service workers enable offline functionality and faster loads:</p>
<pre><code class="language-javascript">// sw.js
const CACHE_NAME = &#039;app-v1&#039;;
const ASSETS = [
  &#039;/&#039;,
  &#039;/index.html&#039;,
  &#039;/styles.css&#039;,
  &#039;/app.js&#039;,
  &#039;/components/header.js&#039;,
  &#039;/components/footer.js&#039;
];

self.addEventListener(&#039;install&#039;, (event) =&gt; {
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache =&gt; cache.addAll(ASSETS))
  );
});

self.addEventListener(&#039;fetch&#039;, (event) =&gt; {
  event.respondWith(
    caches.match(event.request).then(cached =&gt; {
      // Cache first, network fallback
      if (cached) return cached;

      return fetch(event.request).then(response =&gt; {
        // Cache successful responses
        if (response.ok) {
          const clone = response.clone();
          caches.open(CACHE_NAME).then(cache =&gt; {
            cache.put(event.request, clone);
          });
        }
        return response;
      });
    })
  );
});</code></pre>
<p>Register it in your app:</p>
<pre><code class="language-javascript">if (&#039;serviceWorker&#039; in navigator) {
  navigator.serviceWorker.register(&#039;/sw.js&#039;);
}</code></pre>
<h2>Measuring Performance</h2>
<p>You can't optimize what you don't measure. Use the Performance API:</p>
<pre><code class="language-javascript">// Measure component render time
performance.mark(&#039;render-start&#039;);
this.render();
performance.mark(&#039;render-end&#039;);
performance.measure(&#039;render&#039;, &#039;render-start&#039;, &#039;render-end&#039;);

const measure = performance.getEntriesByName(&#039;render&#039;)[0];
console.log(`Render took ${measure.duration}ms`);</code></pre>
<p>Track Web Vitals:</p>
<pre><code class="language-javascript">import { getCLS, getFID, getLCP } from &#039;web-vitals&#039;;

getCLS(console.log);  // Cumulative Layout Shift
getFID(console.log);  // First Input Delay
getLCP(console.log);  // Largest Contentful Paint</code></pre>
<h2>Virtual Lists for Large Data</h2>
<p>Rendering thousands of items kills performance. Virtualize:</p>
<pre><code class="language-javascript">class VirtualList extends HTMLElement {
  constructor() {
    super();
    this.items = [];
    this.itemHeight = 40;
    this.visibleCount = 20;
    this.scrollTop = 0;
  }

  set data(items) {
    this.items = items;
    this.render();
  }

  connectedCallback() {
    this.style.cssText = `
      display: block;
      height: 400px;
      overflow-y: auto;
    `;

    this.addEventListener(&#039;scroll&#039;, () =&gt; {
      this.scrollTop = this.scrollTop;
      this.render();
    });

    this.render();
  }

  render() {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const visibleItems = this.items.slice(startIndex, startIndex + this.visibleCount);

    this.innerHTML = `
      &lt;div style=&quot;height: ${this.items.length * this.itemHeight}px; position: relative;&quot;&gt;
        ${visibleItems.map((item, i) =&gt; `
          &lt;div style=&quot;
            position: absolute;
            top: ${(startIndex + i) * this.itemHeight}px;
            height: ${this.itemHeight}px;
            width: 100%;
          &quot;&gt;
            ${item.name}
          &lt;/div&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;virtual-list&#039;, VirtualList);</code></pre>
<h2>Code Splitting and Dynamic Imports</h2>
<p>Break your code into smaller chunks that load on demand:</p>
<pre><code class="language-javascript">// Route-based code splitting
class AppRouter extends HTMLElement {
  constructor() {
    super();
    this.routes = new Map([
      [&#039;/&#039;, () =&gt; import(&#039;./pages/home.js&#039;)],
      [&#039;/products&#039;, () =&gt; import(&#039;./pages/products.js&#039;)],
      [&#039;/admin&#039;, () =&gt; import(&#039;./pages/admin.js&#039;)]
    ]);
  }

  async navigate(path) {
    // Show loading state
    this.innerHTML = &#039;&lt;div class=&quot;loading&quot;&gt;Loading...&lt;/div&gt;&#039;;

    try {
      const loader = this.routes.get(path);
      if (!loader) {
        throw new Error(&#039;Route not found&#039;);
      }

      // Load the module
      const module = await loader();

      // Render the page component
      this.innerHTML = `&lt;${module.tagName}&gt;&lt;/${module.tagName}&gt;`;

      // Track page load time
      performance.mark(`page-${path}-loaded`);
    } catch (error) {
      this.innerHTML = `&lt;error-page message=&quot;${error.message}&quot;&gt;&lt;/error-page&gt;`;
    }
  }
}

// Feature-based code splitting
class DataGrid extends HTMLElement {
  async enableExport() {
    if (!this.exportModule) {
      // Only load export library when user needs it
      this.exportModule = await import(&#039;https://cdn.jsdelivr.net/npm/xlsx/+esm&#039;);
    }

    const worksheet = this.exportModule.utils.json_to_sheet(this.data);
    const workbook = this.exportModule.utils.book_new();
    this.exportModule.utils.book_append_sheet(workbook, worksheet, &#039;Data&#039;);
    this.exportModule.writeFile(workbook, &#039;export.xlsx&#039;);
  }
}</code></pre>
<h2>Debouncing and Throttling</h2>
<p>Control how often expensive operations run:</p>
<pre><code class="language-javascript">// Debounce: Wait for user to stop typing
function debounce(fn, delay = 300) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() =&gt; fn.apply(this, args), delay);
  };
}

class SearchBox extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot;&gt;
      &lt;div class=&quot;results&quot;&gt;&lt;/div&gt;
    `;

    const input = this.querySelector(&#039;input&#039;);
    const results = this.querySelector(&#039;.results&#039;);

    // Debounce search API calls
    const searchDebounced = debounce(async (query) =&gt; {
      if (query.length &lt; 2) {
        results.innerHTML = &#039;&#039;;
        return;
      }

      results.innerHTML = &#039;Searching...&#039;;

      const data = await fetch(`/api/search?q=${encodeURIComponent(query)}`)
        .then(r =&gt; r.json());

      results.innerHTML = data.map(item =&gt;
        `&lt;div class=&quot;result&quot;&gt;${item.title}&lt;/div&gt;`
      ).join(&#039;&#039;);
    }, 300);

    input.addEventListener(&#039;input&#039;, (e) =&gt; {
      searchDebounced(e.target.value);
    });
  }
}

// Throttle: Limit scroll handler frequency
function throttle(fn, delay = 100) {
  let lastCall = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastCall &gt;= delay) {
      lastCall = now;
      fn.apply(this, args);
    }
  };
}

class InfiniteScroll extends HTMLElement {
  connectedCallback() {
    const loadMore = throttle(() =&gt; {
      const scrollBottom = this.scrollTop + this.clientHeight;
      const threshold = this.scrollHeight - 200;

      if (scrollBottom &gt;= threshold &amp;&amp; !this.loading) {
        this.loadNextPage();
      }
    }, 200);

    this.addEventListener(&#039;scroll&#039;, loadMore);
  }

  async loadNextPage() {
    this.loading = true;
    // Load more items...
    this.loading = false;
  }
}</code></pre>
<h2>Memoization for Expensive Computations</h2>
<p>Cache computed values to avoid redundant work:</p>
<pre><code class="language-javascript">class DataTable extends HTMLElement {
  constructor() {
    super();
    this.cache = new Map();
  }

  // Memoize expensive sort operation
  getSortedData(data, sortKey, direction) {
    const cacheKey = `${sortKey}-${direction}`;

    if (this.cache.has(cacheKey)) {
      console.log(&#039;Using cached sort&#039;);
      return this.cache.get(cacheKey);
    }

    console.log(&#039;Computing sort&#039;);
    const sorted = [...data].sort((a, b) =&gt; {
      const aVal = a[sortKey];
      const bVal = b[sortKey];
      const multiplier = direction === &#039;asc&#039; ? 1 : -1;
      return aVal &lt; bVal ? -multiplier : aVal &gt; bVal ? multiplier : 0;
    });

    this.cache.set(cacheKey, sorted);
    return sorted;
  }

  // Clear cache when data changes
  set data(newData) {
    this._data = newData;
    this.cache.clear();
    this.render();
  }
}

// Memoize with WeakMap for object keys
const memoizedCalculations = new WeakMap();

function expensiveCalculation(obj) {
  if (memoizedCalculations.has(obj)) {
    return memoizedCalculations.get(obj);
  }

  const result = {
    total: obj.items.reduce((sum, item) =&gt; sum + item.price, 0),
    tax: obj.items.reduce((sum, item) =&gt; sum + item.price * 0.1, 0),
    // ... more expensive calculations
  };

  memoizedCalculations.set(obj, result);
  return result;
}</code></pre>
<h2>Bundle Size Optimization</h2>
<p>Keep your JavaScript small:</p>
<pre><code class="language-javascript">// Use import maps to share dependencies
// In your HTML:
/*
&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;lit&quot;: &quot;https://cdn.jsdelivr.net/npm/lit@3/+esm&quot;,
    &quot;lit/&quot;: &quot;https://cdn.jsdelivr.net/npm/lit@3/&quot;
  }
}
&lt;/script&gt;
*/

// Multiple components can share the same lit import
import { LitElement, html, css } from &#039;lit&#039;;

// Tree-shake unused code by importing only what you need
// ❌ Bad: imports everything
import * as utils from &#039;./utils.js&#039;;

// ✅ Good: imports only what&#039;s needed
import { formatDate, formatCurrency } from &#039;./utils.js&#039;;

// Prefer native APIs over libraries
// ❌ Heavy date library (40KB+)
import dayjs from &#039;dayjs&#039;;
const formatted = dayjs(date).format(&#039;YYYY-MM-DD&#039;);

// ✅ Native Intl (0KB)
const formatted = new Intl.DateTimeFormat(&#039;en-US&#039;).format(date);

// Use dynamic imports for conditional features
if (user.isAdmin) {
  const { AdminPanel } = await import(&#039;./admin.js&#039;);
  // Use AdminPanel
}</code></pre>
<p>Check your bundle size:</p>
<pre><code class="language-bash"># Analyze what&#039;s being loaded
ls -lh dist/*.js

# Use browser DevTools Network tab to see:
# - Total KB transferred
# - Uncompressed size
# - Number of requests</code></pre>
<h2>Web Vitals Monitoring</h2>
<p>Monitor real user experience:</p>
<pre><code class="language-javascript">// web-vitals-tracker.js
class WebVitalsTracker {
  constructor() {
    this.metrics = {};
  }

  async track() {
    // Import web-vitals library only when needed
    const { onCLS, onFID, onLCP, onFCP, onTTFB } = await import(
      &#039;https://cdn.jsdelivr.net/npm/web-vitals@3/+esm&#039;
    );

    onCLS((metric) =&gt; this.reportMetric(metric));
    onFID((metric) =&gt; this.reportMetric(metric));
    onLCP((metric) =&gt; this.reportMetric(metric));
    onFCP((metric) =&gt; this.reportMetric(metric));
    onTTFB((metric) =&gt; this.reportMetric(metric));
  }

  reportMetric(metric) {
    this.metrics[metric.name] = metric.value;

    // Send to analytics
    if (navigator.sendBeacon) {
      navigator.sendBeacon(&#039;/analytics&#039;, JSON.stringify({
        metric: metric.name,
        value: metric.value,
        rating: metric.rating,
        page: window.location.pathname
      }));
    }

    // Log for development
    console.log(`${metric.name}: ${metric.value} (${metric.rating})`);
  }

  getScores() {
    return {
      cls: this.metrics.CLS || 0,
      fid: this.metrics.FID || 0,
      lcp: this.metrics.LCP || 0,
      fcp: this.metrics.FCP || 0,
      ttfb: this.metrics.TTFB || 0
    };
  }
}

// Use in your app
const vitals = new WebVitalsTracker();
vitals.track();</code></pre>
<p>Display performance scores to users:</p>
<pre><code class="language-javascript">class PerformanceWidget extends HTMLElement {
  async connectedCallback() {
    const { onLCP, onFID, onCLS } = await import(
      &#039;https://cdn.jsdelivr.net/npm/web-vitals@3/+esm&#039;
    );

    this.innerHTML = `
      &lt;div class=&quot;vitals&quot;&gt;
        &lt;div class=&quot;metric&quot;&gt;
          &lt;span class=&quot;label&quot;&gt;LCP&lt;/span&gt;
          &lt;span class=&quot;value lcp&quot;&gt;...&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;metric&quot;&gt;
          &lt;span class=&quot;label&quot;&gt;FID&lt;/span&gt;
          &lt;span class=&quot;value fid&quot;&gt;...&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;metric&quot;&gt;
          &lt;span class=&quot;label&quot;&gt;CLS&lt;/span&gt;
          &lt;span class=&quot;value cls&quot;&gt;...&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;

    onLCP(({ value, rating }) =&gt; {
      this.querySelector(&#039;.lcp&#039;).textContent = `${Math.round(value)}ms`;
      this.querySelector(&#039;.lcp&#039;).className = `value lcp ${rating}`;
    });

    onFID(({ value, rating }) =&gt; {
      this.querySelector(&#039;.fid&#039;).textContent = `${Math.round(value)}ms`;
      this.querySelector(&#039;.fid&#039;).className = `value fid ${rating}`;
    });

    onCLS(({ value, rating }) =&gt; {
      this.querySelector(&#039;.cls&#039;).textContent = value.toFixed(3);
      this.querySelector(&#039;.cls&#039;).className = `value cls ${rating}`;
    });
  }
}

customElements.define(&#039;performance-widget&#039;, PerformanceWidget);</code></pre>
<h2>Real-World Example: Optimized Dashboard</h2>
<p>Here's a complete dashboard with all optimization techniques applied:</p>
<pre><code class="language-javascript">class OptimizedDashboard extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.cache = new Map();
    this.loadedWidgets = new Set();
  }

  async connectedCallback() {
    // 1. Render shell immediately (FCP)
    this.renderShell();

    // 2. Load critical data
    await this.loadCriticalData();

    // 3. Set up lazy loading for below-fold widgets
    this.setupLazyLoading();

    // 4. Track performance
    this.trackPerformance();
  }

  renderShell() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: block;
          container-type: inline-size;
        }

        .grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          gap: 1rem;
          padding: 1rem;
        }

        .widget {
          background: white;
          border-radius: 8px;
          padding: 1rem;
          min-height: 200px;
        }

        .skeleton {
          background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
          background-size: 200% 100%;
          animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
          0% { background-position: 200% 0; }
          100% { background-position: -200% 0; }
        }
      &lt;/style&gt;

      &lt;div class=&quot;grid&quot;&gt;
        &lt;div class=&quot;widget&quot; data-widget=&quot;revenue&quot;&gt;
          &lt;div class=&quot;skeleton&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;widget&quot; data-widget=&quot;users&quot;&gt;
          &lt;div class=&quot;skeleton&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;widget&quot; data-widget=&quot;chart&quot; data-lazy&gt;
          &lt;div class=&quot;skeleton&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;widget&quot; data-widget=&quot;table&quot; data-lazy&gt;
          &lt;div class=&quot;skeleton&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }

  async loadCriticalData() {
    // Load above-the-fold widgets in parallel
    const criticalWidgets = [&#039;revenue&#039;, &#039;users&#039;];

    await Promise.all(
      criticalWidgets.map(widget =&gt; this.loadWidget(widget))
    );
  }

  setupLazyLoading() {
    const lazyWidgets = this.shadowRoot.querySelectorAll(&#039;[data-lazy]&#039;);

    const observer = new IntersectionObserver(
      (entries) =&gt; {
        entries.forEach(entry =&gt; {
          if (entry.isIntersecting) {
            const widgetName = entry.target.dataset.widget;
            this.loadWidget(widgetName);
            observer.unobserve(entry.target);
          }
        });
      },
      { rootMargin: &#039;50px&#039; }
    );

    lazyWidgets.forEach(widget =&gt; observer.observe(widget));
  }

  async loadWidget(name) {
    if (this.loadedWidgets.has(name)) return;

    performance.mark(`widget-${name}-start`);

    try {
      // Check cache first
      let data = this.cache.get(name);

      if (!data) {
        // Load data with timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() =&gt; controller.abort(), 5000);

        data = await fetch(`/api/widgets/${name}`, {
          signal: controller.signal
        }).then(r =&gt; r.json());

        clearTimeout(timeoutId);

        // Cache for 5 minutes
        this.cache.set(name, data);
        setTimeout(() =&gt; this.cache.delete(name), 5 * 60 * 1000);
      }

      // Render widget
      const widget = this.shadowRoot.querySelector(`[data-widget=&quot;${name}&quot;]`);
      widget.innerHTML = this.renderWidget(name, data);

      this.loadedWidgets.add(name);

      performance.mark(`widget-${name}-end`);
      performance.measure(
        `widget-${name}`,
        `widget-${name}-start`,
        `widget-${name}-end`
      );
    } catch (error) {
      console.error(`Failed to load widget ${name}:`, error);

      const widget = this.shadowRoot.querySelector(`[data-widget=&quot;${name}&quot;]`);
      widget.innerHTML = `
        &lt;div class=&quot;error&quot;&gt;
          &lt;p&gt;Failed to load ${name}&lt;/p&gt;
          &lt;button onclick=&quot;this.getRootNode().host.loadWidget(&#039;${name}&#039;)&quot;&gt;
            Retry
          &lt;/button&gt;
        &lt;/div&gt;
      `;
    }
  }

  renderWidget(name, data) {
    switch (name) {
      case &#039;revenue&#039;:
        return `
          &lt;h3&gt;Revenue&lt;/h3&gt;
          &lt;div class=&quot;value&quot;&gt;$${data.total.toLocaleString()}&lt;/div&gt;
          &lt;div class=&quot;change ${data.change &gt;= 0 ? &#039;positive&#039; : &#039;negative&#039;}&quot;&gt;
            ${data.change &gt;= 0 ? &#039;↑&#039; : &#039;↓&#039;} ${Math.abs(data.change)}%
          &lt;/div&gt;
        `;

      case &#039;users&#039;:
        return `
          &lt;h3&gt;Active Users&lt;/h3&gt;
          &lt;div class=&quot;value&quot;&gt;${data.count.toLocaleString()}&lt;/div&gt;
        `;

      case &#039;chart&#039;:
        // Lazy load chart library only when needed
        return `&lt;canvas id=&quot;chart-${name}&quot;&gt;&lt;/canvas&gt;`;

      case &#039;table&#039;:
        return `
          &lt;h3&gt;Recent Activity&lt;/h3&gt;
          &lt;virtual-list&gt;&lt;/virtual-list&gt;
        `;

      default:
        return `&lt;div&gt;Unknown widget: ${name}&lt;/div&gt;`;
    }
  }

  trackPerformance() {
    // Track load time
    window.addEventListener(&#039;load&#039;, () =&gt; {
      const loadTime = performance.timing.loadEventEnd -
                      performance.timing.navigationStart;
      console.log(`Dashboard loaded in ${loadTime}ms`);
    });

    // Track widget render times
    const observer = new PerformanceObserver((list) =&gt; {
      list.getEntries().forEach((entry) =&gt; {
        if (entry.name.startsWith(&#039;widget-&#039;)) {
          console.log(`${entry.name}: ${entry.duration}ms`);
        }
      });
    });

    observer.observe({ entryTypes: [&#039;measure&#039;] });
  }
}

customElements.define(&#039;optimized-dashboard&#039;, OptimizedDashboard);</code></pre>
<h2>Troubleshooting Performance Issues</h2>
<h3>Problem 1: Memory Leaks</h3>
<strong>Symptoms</strong>: Page gets slower over time, browser tab uses increasing memory.
<strong>Common causes</strong>:
<ul><li>Event listeners not removed</li>
<li>Setters/intervals not cleared</li>
<li>Large objects cached indefinitely</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-javascript">class LeakyComponent extends HTMLElement {
  connectedCallback() {
    // ❌ Memory leak: handler never removed
    window.addEventListener(&#039;resize&#039;, this.onResize);

    // ❌ Memory leak: interval never cleared
    this.intervalId = setInterval(() =&gt; this.update(), 1000);

    // ❌ Memory leak: cache grows forever
    this.cache = new Map();
  }
}

class FixedComponent extends HTMLElement {
  connectedCallback() {
    // ✅ Store handler reference
    this.onResize = () =&gt; this.handleResize();
    window.addEventListener(&#039;resize&#039;, this.onResize);

    // ✅ Store interval ID
    this.intervalId = setInterval(() =&gt; this.update(), 1000);

    // ✅ Use LRU cache with size limit
    this.cache = new Map();
    this.maxCacheSize = 100;
  }

  disconnectedCallback() {
    // ✅ Clean up listener
    window.removeEventListener(&#039;resize&#039;, this.onResize);

    // ✅ Clear interval
    clearInterval(this.intervalId);

    // ✅ Clear cache
    this.cache.clear();
  }

  addToCache(key, value) {
    if (this.cache.size &gt;= this.maxCacheSize) {
      // Remove oldest entry
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}</code></pre>
<p>Use browser DevTools to detect leaks:
<li>Open Performance Monitor (Cmd/Ctrl + Shift + P → "Performance Monitor")</li>
<li>Watch JS heap size over time</li>
<li>Take heap snapshots to find retained objects</li></p>
<h3>Problem 2: Slow Initial Render</h3>
<strong>Symptoms</strong>: Long time before page shows content, poor LCP score.
<strong>Common causes</strong>:
<ul><li>Loading too much JavaScript upfront</li>
<li>Synchronous data fetching</li>
<li>Rendering everything at once</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-javascript">// ❌ Bad: Wait for everything
class SlowApp extends HTMLElement {
  async connectedCallback() {
    const data = await fetch(&#039;/api/data&#039;).then(r =&gt; r.json());
    this.render(data);
  }
}

// ✅ Good: Progressive rendering
class FastApp extends HTMLElement {
  connectedCallback() {
    // 1. Show shell immediately
    this.innerHTML = &#039;&lt;div class=&quot;shell&quot;&gt;Loading...&lt;/div&gt;&#039;;

    // 2. Load data asynchronously
    this.loadData();
  }

  async loadData() {
    try {
      const data = await fetch(&#039;/api/data&#039;).then(r =&gt; r.json());
      this.render(data);
    } catch (error) {
      this.renderError(error);
    }
  }
}</code></pre>
<h3>Problem 3: Large Bundle Size</h3>
<strong>Symptoms</strong>: Slow initial load, poor First Contentful Paint.
<strong>Diagnosis</strong>:
<pre><code class="language-javascript">// Analyze what&#039;s in your bundle
console.table(
  performance.getEntriesByType(&#039;resource&#039;)
    .filter(r =&gt; r.initiatorType === &#039;script&#039;)
    .map(r =&gt; ({
      name: r.name.split(&#039;/&#039;).pop(),
      size: `${(r.transferSize / 1024).toFixed(2)} KB`,
      time: `${r.duration.toFixed(2)}ms`
    }))
);</code></pre>
<strong>Solutions</strong>:
<ul><li>Use import maps to share dependencies</li>
<li>Lazy load non-critical features</li>
<li>Use native APIs instead of libraries</li>
<li>Tree-shake unused code</li>
</ul>
<h3>Problem 4: Layout Thrashing</h3>
<strong>Symptoms</strong>: Janky scrolling, slow animations, poor FPS.
<strong>Cause</strong>: Reading and writing DOM in the same frame.
<pre><code class="language-javascript">// ❌ Bad: Forces multiple reflows
items.forEach(item =&gt; {
  const height = item.offsetHeight;  // Read (reflow)
  item.style.height = height * 2 + &#039;px&#039;;  // Write (reflow)
});

// ✅ Good: Batch reads and writes
const heights = items.map(item =&gt; item.offsetHeight);  // Batch reads
items.forEach((item, i) =&gt; {
  item.style.height = heights[i] * 2 + &#039;px&#039;;  // Batch writes
});

// ✅ Better: Use requestAnimationFrame
function updateLayout() {
  // All reads first
  const measurements = elements.map(el =&gt; ({
    width: el.offsetWidth,
    height: el.offsetHeight
  }));

  // Then all writes
  elements.forEach((el, i) =&gt; {
    el.style.width = measurements[i].width * 2 + &#039;px&#039;;
    el.style.height = measurements[i].height * 2 + &#039;px&#039;;
  });
}

requestAnimationFrame(updateLayout);</code></pre>
<h2>Performance Best Practices</h2>
<li><strong>Load Critical Resources First</strong>: Prioritize above-the-fold content and user-interactive elements.</li>
<li><strong>Lazy Load Everything Else</strong>: Use Intersection Observer for images, components, and heavy features.</li>
<li><strong>Cache Aggressively</strong>: Use service workers, HTTP caching, and in-memory caches appropriately.</li>
<li><strong>Measure Real Users</strong>: Track Web Vitals for actual user experiences, not just lab tests.</li>
<li><strong>Debounce User Input</strong>: Don't make API calls on every keystroke—wait for users to finish typing.</li>
<li><strong>Virtualize Long Lists</strong>: Never render more than ~50-100 items at once.</li>
<li><strong>Code Split by Route</strong>: Load only the JavaScript needed for the current page.</li>
<li><strong>Optimize Images</strong>: Use modern formats (WebP, AVIF), lazy loading, and responsive images.</li>
<li><strong>Clean Up Resources</strong>: Always remove event listeners and clear intervals in <code>disconnectedCallback</code>.</li>
<li><strong>Profile Before Optimizing</strong>: Use DevTools to find actual bottlenecks—don't guess.</li>
<h2>Hands-On Exercises</h2>
<h3>Exercise 1: Optimize an Image Gallery</h3>
<p>Create an image gallery that:</p>
<ul><li>Lazy loads images as they scroll into view</li>
<li>Uses Intersection Observer</li>
<li>Shows a loading placeholder</li>
<li>Tracks LCP for the first visible image</li>
</ul>
<strong>Bonus</strong>: Add a "Load All" button that prefetches remaining images.
<h3>Exercise 2: Build a Virtual List</h3>
<p>Implement a virtual list component that:</p>
<ul><li>Renders only visible items</li>
<li>Handles variable-height items</li>
<li>Supports smooth scrolling</li>
<li>Works with 10,000+ items</li>
</ul>
<strong>Bonus</strong>: Add keyboard navigation and accessibility.
<h3>Exercise 3: Implement Request Deduplication</h3>
<p>Create a data service that:</p>
<ul><li>Prevents duplicate API calls for the same resource</li>
<li>Shares pending requests between components</li>
<li>Caches responses for 1 minute</li>
<li>Provides a cache invalidation API</li>
</ul>
<strong>Bonus</strong>: Add optimistic updates with rollback on error.
<h3>Exercise 4: Performance Dashboard</h3>
<p>Build a performance monitoring dashboard that:</p>
<ul><li>Tracks all Core Web Vitals</li>
<li>Shows performance over time</li>
<li>Highlights performance regressions</li>
<li>Exports data to CSV</li>
</ul>
<strong>Bonus</strong>: Add alerts when metrics exceed thresholds.
<h2>Summary</h2>
<p>Performance optimization is about making smart tradeoffs:</p>
<ul><li><strong>Load less</strong>: Code split, lazy load, tree shake</li>
<li><strong>Cache more</strong>: Service workers, HTTP cache, memory cache</li>
<li><strong>Render efficiently</strong>: Virtual lists, debouncing, memoization</li>
<li><strong>Measure everything</strong>: Web Vitals, Performance API, DevTools</li>
</ul>
Start with the low-hanging fruit (lazy loading, caching) and use DevTools to find the real bottlenecks. Remember: premature optimization is the root of all evil—measure first, then optimize.
<h2>Further Reading</h2>
<ul><li><strong>Building with LARC - Chapter 17 (Performance)</strong>: Deep dive into LARC-specific optimization techniques</li>
<li><strong>Building with LARC - Chapter 8 (Lifecycle)</strong>: Component cleanup and resource management</li>
<li><strong>Building with LARC - Chapter 11 (Best Practices)</strong>: Performance patterns and anti-patterns</li>
</ul>
<div class="pagebreak"></div>
<h1>Deployment</h1>
<p>Deploying LARC applications is refreshingly simple. No build artifacts to manage, no complex CI/CD pipelines required. Just static files that any web server can handle.</p>
<h2>Static Hosting Options</h2>
<p>LARC apps are static files. Host them anywhere:</p>
<h3>GitHub Pages</h3>
<p>Free hosting for public repositories:</p>
<pre><code class="language-yaml"># .github/workflows/deploy.yml
name: Deploy to GitHub Pages

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public</code></pre>
<h3>Netlify</h3>
<p>Drag and drop deployment or connect to Git:</p>
<pre><code class="language-toml"># netlify.toml
[build]
  publish = &quot;public&quot;

[[redirects]]
  from = &quot;/*&quot;
  to = &quot;/index.html&quot;
  status = 200</code></pre>
<h3>Vercel</h3>
<p>Zero-config deployment:</p>
<pre><code class="language-json">{
  &quot;rewrites&quot;: [
    { &quot;source&quot;: &quot;/(.*)&quot;, &quot;destination&quot;: &quot;/index.html&quot; }
  ]
}</code></pre>
<h2>CDN Configuration</h2>
<p>Serve assets from a CDN for faster global delivery:</p>
<pre><code class="language-html">&lt;!-- Use CDN for LARC core --&gt;
&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;@aspect/pan-client&quot;: &quot;https://cdn.jsdelivr.net/npm/@aspect/pan-client@latest/pan-client.mjs&quot;
  }
}
&lt;/script&gt;</code></pre>
<p>Set proper cache headers:</p>
<pre><code class="language-plaintext"># .htaccess for Apache
&lt;IfModule mod_expires.c&gt;
  ExpiresActive On

  # HTML - no cache (or short cache)
  ExpiresByType text/html &quot;access plus 0 seconds&quot;

  # CSS and JS - long cache (use versioned filenames)
  ExpiresByType text/css &quot;access plus 1 year&quot;
  ExpiresByType application/javascript &quot;access plus 1 year&quot;

  # Images - long cache
  ExpiresByType image/png &quot;access plus 1 year&quot;
  ExpiresByType image/jpeg &quot;access plus 1 year&quot;
  ExpiresByType image/svg+xml &quot;access plus 1 year&quot;
&lt;/IfModule&gt;</code></pre>
<h2>Environment Variables</h2>
<p>Manage configuration across environments:</p>
<pre><code class="language-javascript">// config.js
const configs = {
  development: {
    apiUrl: &#039;http://localhost:3000/api&#039;,
    debug: true
  },
  production: {
    apiUrl: &#039;https://api.example.com&#039;,
    debug: false
  }
};

const env = window.location.hostname === &#039;localhost&#039; ? &#039;development&#039; : &#039;production&#039;;
export const config = configs[env];</code></pre>
<p>Or use a build-time approach:</p>
<pre><code class="language-html">&lt;!-- Injected by server/build --&gt;
&lt;script&gt;
  window.CONFIG = {
    apiUrl: &#039;%%API_URL%%&#039;,
    version: &#039;%%VERSION%%&#039;
  };
&lt;/script&gt;</code></pre>
<h2>Pre-Deployment Checklist</h2>
<p>Before deploying to production:</p>
<ul><li>[ ] Test in all target browsers</li>
<li>[ ] Verify all API endpoints use HTTPS</li>
<li>[ ] Check for console errors</li>
<li>[ ] Validate accessibility (keyboard navigation, screen readers)</li>
<li>[ ] Test on slow network (Chrome DevTools throttling)</li>
<li>[ ] Verify error handling works</li>
<li>[ ] Check mobile responsiveness</li>
<li>[ ] Set up error monitoring (Sentry, LogRocket)</li>
<li>[ ] Configure analytics</li>
<li>[ ] Enable HTTPS</li>
<li>[ ] Set security headers</li>
</ul>
<h2>Monitoring</h2>
<p>Track errors in production:</p>
<pre><code class="language-javascript">// error-tracking.js
window.addEventListener(&#039;error&#039;, (event) =&gt; {
  fetch(&#039;/api/errors&#039;, {
    method: &#039;POST&#039;,
    headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
    body: JSON.stringify({
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      userAgent: navigator.userAgent,
      url: window.location.href
    })
  });
});

window.addEventListener(&#039;unhandledrejection&#039;, (event) =&gt; {
  fetch(&#039;/api/errors&#039;, {
    method: &#039;POST&#039;,
    headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
    body: JSON.stringify({
      message: event.reason?.message || &#039;Unhandled promise rejection&#039;,
      stack: event.reason?.stack,
      userAgent: navigator.userAgent,
      url: window.location.href
    })
  });
});</code></pre>
<h2>Netlify Deployment Walkthrough</h2>
<p>Let's deploy a LARC app to Netlify step-by-step:</p>
<strong>1. Prepare your project:</strong>
<pre><code class="language-bash"># Project structure
my-larc-app/
├── public/
│   ├── index.html
│   ├── app.js
│   ├── components/
│   └── styles/
├── netlify.toml
└── package.json</code></pre>
<strong>2. Create <code>netlify.toml</code>:</strong>
<pre><code class="language-toml">[build]
  publish = &quot;public&quot;

[build.environment]
  NODE_VERSION = &quot;18&quot;

[[redirects]]
  from = &quot;/*&quot;
  to = &quot;/index.html&quot;
  status = 200

[[headers]]
  for = &quot;/*.js&quot;
  [headers.values]
    Cache-Control = &quot;public, max-age=31536000, immutable&quot;

[[headers]]
  for = &quot;/*.css&quot;
  [headers.values]
    Cache-Control = &quot;public, max-age=31536000, immutable&quot;

[[headers]]
  for = &quot;/index.html&quot;
  [headers.values]
    Cache-Control = &quot;public, max-age=0, must-revalidate&quot;
    X-Frame-Options = &quot;DENY&quot;
    X-Content-Type-Options = &quot;nosniff&quot;
    Referrer-Policy = &quot;strict-origin-when-cross-origin&quot;
    Permissions-Policy = &quot;geolocation=(), microphone=(), camera=()&quot;</code></pre>
<strong>3. Deploy via Netlify CLI:</strong>
<pre><code class="language-bash"># Install Netlify CLI
npm install -g netlify-cli

# Login
netlify login

# Initialize site
netlify init

# Deploy
netlify deploy --prod</code></pre>
<strong>4. Set environment variables:</strong>
<pre><code class="language-bash"># Via CLI
netlify env:set API_URL &quot;https://api.example.com&quot;
netlify env:set SENTRY_DSN &quot;https://...&quot;

# Or in Netlify UI: Site Settings → Environment Variables</code></pre>
<strong>5. Access in your app:</strong>
<pre><code class="language-javascript">// Access Netlify environment variables
const config = {
  apiUrl: window.ENV?.API_URL || &#039;http://localhost:3000&#039;,
  sentryDsn: window.ENV?.SENTRY_DSN
};</code></pre>
<h2>Vercel Deployment Walkthrough</h2>
<p>Deploy to Vercel with zero configuration:</p>
<strong>1. Install Vercel CLI:</strong>
<pre><code class="language-bash">npm install -g vercel</code></pre>
<strong>2. Create <code>vercel.json</code>:</strong>
<pre><code class="language-json">{
  &quot;version&quot;: 2,
  &quot;builds&quot;: [
    {
      &quot;src&quot;: &quot;public/**&quot;,
      &quot;use&quot;: &quot;@vercel/static&quot;
    }
  ],
  &quot;routes&quot;: [
    {
      &quot;src&quot;: &quot;/(.*)&quot;,
      &quot;dest&quot;: &quot;/public/$1&quot;
    },
    {
      &quot;src&quot;: &quot;/.*&quot;,
      &quot;dest&quot;: &quot;/public/index.html&quot;
    }
  ],
  &quot;headers&quot;: [
    {
      &quot;source&quot;: &quot;/public/(.*\\.js|.*\\.css)&quot;,
      &quot;headers&quot;: [
        {
          &quot;key&quot;: &quot;Cache-Control&quot;,
          &quot;value&quot;: &quot;public, max-age=31536000, immutable&quot;
        }
      ]
    }
  ],
  &quot;env&quot;: {
    &quot;API_URL&quot;: &quot;@api-url&quot;,
    &quot;NODE_ENV&quot;: &quot;production&quot;
  }
}</code></pre>
<strong>3. Deploy:</strong>
<pre><code class="language-bash"># First deployment
vercel

# Production deployment
vercel --prod

# Set secrets
vercel secrets add api-url &quot;https://api.example.com&quot;</code></pre>
<strong>4. Configure custom domain:</strong>
<pre><code class="language-bash">vercel domains add www.example.com
vercel alias deployment-url.vercel.app www.example.com</code></pre>
<h2>GitHub Pages Deployment</h2>
<p>Deploy directly from your GitHub repository:</p>
<strong>1. Create GitHub Actions workflow:</strong>
<pre><code class="language-yaml"># .github/workflows/deploy.yml
name: Deploy to GitHub Pages

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: &quot;pages&quot;
  cancel-in-progress: true

jobs:
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: &#039;./public&#039;

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4</code></pre>
<strong>2. Configure repository:</strong>
<li>Go to Settings → Pages</li>
<li>Source: "GitHub Actions"</li>
<li>Your site will be available at <code>https://username.github.io/repo-name/</code></li>
<strong>3. Handle base path:</strong>
<pre><code class="language-javascript">// config.js - Handle GitHub Pages subdirectory
const basePath = window.location.pathname.includes(&#039;repo-name&#039;)
  ? &#039;/repo-name&#039;
  : &#039;&#039;;

export const config = {
  basePath,
  apiUrl: `${basePath}/api`
};

// Use in router
pan.publish(&#039;router.navigate&#039;, {
  path: `${config.basePath}/about`
});</code></pre>
<h2>CI/CD Pipeline Example</h2>
<p>Complete GitHub Actions workflow with testing and deployment:</p>
<pre><code class="language-yaml"># .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: &#039;18&#039;

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: &#039;npm&#039;

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Run tests
        run: npm test

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: test-results/

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Create build info
        run: |
          echo &quot;Build: ${{ github.sha }}&quot; &gt; public/build.txt
          echo &quot;Date: $(date)&quot; &gt;&gt; public/build.txt

      - name: Upload build artifact
        uses: actions/upload-artifact@v3
        with:
          name: public
          path: public/

  deploy-staging:
    needs: build
    if: github.ref == &#039;refs/heads/develop&#039;
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.example.com
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: public
          path: public/

      - name: Deploy to staging
        uses: netlify/actions/cli@master
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_STAGING_SITE_ID }}
        with:
          args: deploy --dir=public --prod

  deploy-production:
    needs: build
    if: github.ref == &#039;refs/heads/main&#039;
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: public
          path: public/

      - name: Deploy to production
        uses: netlify/actions/cli@master
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_PROD_SITE_ID }}
        with:
          args: deploy --dir=public --prod

      - name: Notify deployment
        run: |
          curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
            -H &#039;Content-Type: application/json&#039; \
            -d &#039;{&quot;text&quot;:&quot;✅ Deployed to production: ${{ github.sha }}&quot;}&#039;</code></pre>
<h2>Docker Deployment</h2>
<p>Package your app with Nginx for containerized deployment:</p>
<strong>Dockerfile:</strong>
<pre><code class="language-dockerfile"># Use Nginx as base
FROM nginx:alpine

# Copy app files
COPY public/ /usr/share/nginx/html/

# Copy custom Nginx config
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port
EXPOSE 80

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget --quiet --tries=1 --spider http://localhost/health || exit 1

CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></pre>
<strong>nginx.conf:</strong>
<pre><code class="language-nginx">server {
  listen 80;
  server_name _;
  root /usr/share/nginx/html;
  index index.html;

  # Security headers
  add_header X-Frame-Options &quot;DENY&quot; always;
  add_header X-Content-Type-Options &quot;nosniff&quot; always;
  add_header X-XSS-Protection &quot;1; mode=block&quot; always;
  add_header Referrer-Policy &quot;strict-origin-when-cross-origin&quot; always;

  # Gzip compression
  gzip on;
  gzip_vary on;
  gzip_types text/css application/javascript application/json image/svg+xml;
  gzip_min_length 1024;

  # Cache static assets
  location ~* \.(js|css|png|jpg|jpeg|gif|svg|ico|woff|woff2)$ {
    expires 1y;
    add_header Cache-Control &quot;public, immutable&quot;;
  }

  # No cache for HTML
  location ~* \.html$ {
    expires -1;
    add_header Cache-Control &quot;no-store, no-cache, must-revalidate, proxy-revalidate&quot;;
  }

  # SPA fallback
  location / {
    try_files $uri $uri/ /index.html;
  }

  # Health check endpoint
  location /health {
    access_log off;
    return 200 &quot;healthy\n&quot;;
    add_header Content-Type text/plain;
  }
}</code></pre>
<strong>Build and run:</strong>
<pre><code class="language-bash"># Build image
docker build -t my-larc-app:latest .

# Run locally
docker run -p 8080:80 my-larc-app:latest

# Push to registry
docker tag my-larc-app:latest registry.example.com/my-larc-app:latest
docker push registry.example.com/my-larc-app:latest

# Deploy with docker-compose
cat &gt; docker-compose.yml &lt;&lt; EOF
version: &#039;3.8&#039;
services:
  app:
    image: my-larc-app:latest
    ports:
      - &quot;80:80&quot;
    environment:
      - NODE_ENV=production
    restart: unless-stopped
EOF

docker-compose up -d</code></pre>
<h2>Security Headers</h2>
<p>Protect your app with proper HTTP headers:</p>
<pre><code class="language-javascript">// For Netlify (_headers file)
/*
  X-Frame-Options: DENY
  X-Content-Type-Options: nosniff
  X-XSS-Protection: 1; mode=block
  Referrer-Policy: strict-origin-when-cross-origin
  Permissions-Policy: geolocation=(), microphone=(), camera=()
  Content-Security-Policy: default-src &#039;self&#039;; script-src &#039;self&#039; &#039;unsafe-inline&#039; https://cdn.jsdelivr.net; style-src &#039;self&#039; &#039;unsafe-inline&#039;; img-src &#039;self&#039; data: https:; font-src &#039;self&#039; data:; connect-src &#039;self&#039; https://api.example.com

/*.js
  Cache-Control: public, max-age=31536000, immutable

/*.css
  Cache-Control: public, max-age=31536000, immutable

/index.html
  Cache-Control: public, max-age=0, must-revalidate</code></pre>
<p>Test security headers:</p>
<pre><code class="language-bash">curl -I https://your-site.com | grep -E &quot;X-Frame-Options|X-Content-Type&quot;</code></pre>
<p>Or use online tools:</p>
<ul><li>https://securityheaders.com</li>
<li>https://observatory.mozilla.org</li>
</ul>
<h2>Performance Optimization for Production</h2>
<strong>1. Enable compression:</strong>
<pre><code class="language-nginx"># Nginx
gzip on;
gzip_vary on;
gzip_min_length 1024;
gzip_types text/plain text/css text/xml text/javascript
           application/x-javascript application/xml+rss
           application/javascript application/json image/svg+xml;</code></pre>
<strong>2. Set cache headers:</strong>
<pre><code class="language-javascript">// For Cloudflare Workers
export default {
  async fetch(request) {
    const url = new URL(request.url);
    const response = await fetch(request);

    // Clone response so we can modify headers
    const newResponse = new Response(response.body, response);

    if (url.pathname.match(/\.(js|css|png|jpg|jpeg|svg|woff2?)$/)) {
      newResponse.headers.set(&#039;Cache-Control&#039;, &#039;public, max-age=31536000, immutable&#039;);
    } else if (url.pathname.endsWith(&#039;.html&#039;)) {
      newResponse.headers.set(&#039;Cache-Control&#039;, &#039;public, max-age=0, must-revalidate&#039;);
    }

    return newResponse;
  }
};</code></pre>
<strong>3. Preload critical resources:</strong>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;!-- Preload critical resources --&gt;
  &lt;link rel=&quot;preload&quot; href=&quot;/app.js&quot; as=&quot;script&quot;&gt;
  &lt;link rel=&quot;preload&quot; href=&quot;/styles/main.css&quot; as=&quot;style&quot;&gt;

  &lt;!-- Preconnect to external domains --&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://api.example.com&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.jsdelivr.net&quot;&gt;

  &lt;!-- DNS prefetch for third-party domains --&gt;
  &lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://analytics.example.com&quot;&gt;
&lt;/head&gt;
&lt;/html&gt;</code></pre>
<h2>Rollback Strategies</h2>
<p>Prepare for when deployments go wrong:</p>
<strong>1. Keep previous versions:</strong>
<pre><code class="language-bash"># With Netlify CLI
netlify deploy --prod  # Deploys new version

# Rollback to previous deploy
netlify rollback

# Or via UI: Deploys tab → Click on previous deploy → &quot;Publish deploy&quot;</code></pre>
<strong>2. Blue-green deployment:</strong>
<pre><code class="language-yaml"># Deploy to staging (green), then swap with production (blue)
name: Blue-Green Deployment

on:
  workflow_dispatch:

jobs:
  deploy-green:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to green environment
        run: |
          netlify deploy --site=${{ secrets.GREEN_SITE_ID }} --prod

      - name: Run smoke tests
        run: npm run test:smoke -- --url=https://green.example.com

      - name: Swap blue and green
        if: success()
        run: |
          # Update DNS or load balancer to point to green
          # This is provider-specific
          echo &quot;Swapping environments...&quot;</code></pre>
<strong>3. Feature flags for gradual rollout:</strong>
<pre><code class="language-javascript">// feature-flags.js
class FeatureFlags {
  constructor() {
    this.flags = {};
    this.loadFlags();
  }

  async loadFlags() {
    try {
      const response = await fetch(&#039;/api/feature-flags&#039;);
      this.flags = await response.json();
    } catch (error) {
      console.error(&#039;Failed to load feature flags:&#039;, error);
    }
  }

  isEnabled(feature, userId = null) {
    const flag = this.flags[feature];
    if (!flag) return false;

    // Global enable/disable
    if (flag.enabled === false) return false;

    // Percentage rollout
    if (flag.percentage &amp;&amp; userId) {
      const hash = this.hashUserId(userId);
      return (hash % 100) &lt; flag.percentage;
    }

    // Whitelist
    if (flag.whitelist &amp;&amp; userId) {
      return flag.whitelist.includes(userId);
    }

    return flag.enabled;
  }

  hashUserId(userId) {
    // Simple hash for percentage rollout
    let hash = 0;
    for (let i = 0; i &lt; userId.length; i++) {
      hash = ((hash &lt;&lt; 5) - hash) + userId.charCodeAt(i);
      hash = hash &amp; hash;
    }
    return Math.abs(hash);
  }
}

export const featureFlags = new FeatureFlags();

// Usage
if (featureFlags.isEnabled(&#039;new-dashboard&#039;, user.id)) {
  await import(&#039;./components/new-dashboard.js&#039;);
} else {
  await import(&#039;./components/old-dashboard.js&#039;);
}</code></pre>
<h2>Complete Deployment Example</h2>
<p>Let's deploy a complete app with monitoring and error tracking:</p>
<strong>1. Project structure:</strong>
<pre><code class="language-plaintext">my-app/
├── public/
│   ├── index.html
│   ├── app.js
│   ├── config.js
│   └── components/
├── scripts/
│   └── deploy.sh
├── .github/workflows/
│   └── deploy.yml
├── netlify.toml
└── package.json</code></pre>
<strong>2. Environment-aware config:</strong>
<pre><code class="language-javascript">// public/config.js
const environments = {
  local: {
    apiUrl: &#039;http://localhost:3000&#039;,
    sentryDsn: null,
    analytics: null
  },
  staging: {
    apiUrl: &#039;https://staging-api.example.com&#039;,
    sentryDsn: &#039;https://...@sentry.io/staging&#039;,
    analytics: &#039;UA-STAGING&#039;
  },
  production: {
    apiUrl: &#039;https://api.example.com&#039;,
    sentryDsn: &#039;https://...@sentry.io/prod&#039;,
    analytics: &#039;UA-PROD&#039;
  }
};

function detectEnvironment() {
  const hostname = window.location.hostname;
  if (hostname === &#039;localhost&#039; || hostname === &#039;127.0.0.1&#039;) {
    return &#039;local&#039;;
  }
  if (hostname.includes(&#039;staging&#039;)) {
    return &#039;staging&#039;;
  }
  return &#039;production&#039;;
}

export const config = environments[detectEnvironment()];</code></pre>
<strong>3. Error tracking setup:</strong>
<pre><code class="language-javascript">// public/monitoring.js
import { config } from &#039;./config.js&#039;;

class ErrorTracker {
  constructor() {
    if (config.sentryDsn) {
      this.initSentry();
    }
    this.setupErrorHandlers();
  }

  async initSentry() {
    const Sentry = await import(&#039;https://cdn.jsdelivr.net/npm/@sentry/browser@7/+esm&#039;);

    Sentry.init({
      dsn: config.sentryDsn,
      environment: config.environment,
      beforeSend(event) {
        // Filter out noise
        if (event.message?.includes(&#039;ResizeObserver&#039;)) {
          return null;
        }
        return event;
      }
    });
  }

  setupErrorHandlers() {
    window.addEventListener(&#039;error&#039;, (event) =&gt; {
      this.captureError(event.error, {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
      });
    });

    window.addEventListener(&#039;unhandledrejection&#039;, (event) =&gt; {
      this.captureError(event.reason, {
        type: &#039;unhandledrejection&#039;
      });
    });
  }

  captureError(error, context = {}) {
    console.error(&#039;Error captured:&#039;, error, context);

    // Send to your error tracking service
    if (config.sentryDsn &amp;&amp; window.Sentry) {
      window.Sentry.captureException(error, { extra: context });
    }
  }
}

export const errorTracker = new ErrorTracker();</code></pre>
<strong>4. Deployment script:</strong>
<pre><code class="language-bash">#!/bin/bash
# scripts/deploy.sh

set -e

ENV=${1:-staging}

echo &quot;🚀 Deploying to $ENV...&quot;

# Run tests
echo &quot;🧪 Running tests...&quot;
npm test

# Check for uncommitted changes
if [[ -n $(git status -s) ]]; then
  echo &quot;❌ Uncommitted changes detected. Commit or stash them first.&quot;
  exit 1
fi

# Get current version
VERSION=$(git rev-parse --short HEAD)
echo &quot;📦 Version: $VERSION&quot;

# Create build info
cat &gt; public/build-info.json &lt;&lt; EOF
{
  &quot;version&quot;: &quot;$VERSION&quot;,
  &quot;environment&quot;: &quot;$ENV&quot;,
  &quot;buildDate&quot;: &quot;$(date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot;)&quot;,
  &quot;branch&quot;: &quot;$(git rev-parse --abbrev-ref HEAD)&quot;
}
EOF

# Deploy based on environment
if [ &quot;$ENV&quot; = &quot;production&quot; ]; then
  echo &quot;🌍 Deploying to production...&quot;
  netlify deploy --prod --site=$NETLIFY_PROD_SITE_ID
elif [ &quot;$ENV&quot; = &quot;staging&quot; ]; then
  echo &quot;🔧 Deploying to staging...&quot;
  netlify deploy --prod --site=$NETLIFY_STAGING_SITE_ID
fi

echo &quot;✅ Deployment complete!&quot;
echo &quot;🔗 Check deployment: https://$ENV.example.com&quot;</code></pre>
<h2>Troubleshooting Deployment Issues</h2>
<h3>Problem 1: 404 on Refresh (SPA Routing)</h3>
<strong>Symptoms</strong>: Navigating directly to <code>/about</code> returns 404, but clicking links works.
<strong>Cause</strong>: Server doesn't know about client-side routes.
<strong>Solution</strong>:
<pre><code class="language-toml"># netlify.toml
[[redirects]]
  from = &quot;/*&quot;
  to = &quot;/index.html&quot;
  status = 200

# vercel.json
{
  &quot;rewrites&quot;: [
    { &quot;source&quot;: &quot;/(.*)&quot;, &quot;destination&quot;: &quot;/index.html&quot; }
  ]
}

# Apache .htaccess
&lt;IfModule mod_rewrite.c&gt;
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
&lt;/IfModule&gt;</code></pre>
<h3>Problem 2: CORS Errors in Production</h3>
<strong>Symptoms</strong>: API calls work locally but fail in production with CORS errors.
<strong>Cause</strong>: API server not configured to allow your production domain.
<strong>Solution</strong>:
<pre><code class="language-javascript">// Backend CORS configuration
app.use(cors({
  origin: [
    &#039;https://example.com&#039;,
    &#039;https://www.example.com&#039;,
    &#039;https://staging.example.com&#039;
  ],
  credentials: true
}));

// Or use environment variable
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(&#039;,&#039;),
  credentials: true
}));</code></pre>
<strong>Alternative</strong>: Use a proxy in your deployment config:
<pre><code class="language-toml"># netlify.toml
[[redirects]]
  from = &quot;/api/*&quot;
  to = &quot;https://api.example.com/:splat&quot;
  status = 200
  force = true</code></pre>
<h3>Problem 3: Environment Variables Not Working</h3>
<strong>Symptoms</strong>: App can't read environment variables, falls back to defaults.
<strong>Cause</strong>: Build-time vs. runtime configuration confusion.
<strong>Solution</strong>:
<p>For runtime configuration, inject variables into HTML:</p>
<pre><code class="language-html">&lt;!-- Injected by build process or server --&gt;
&lt;script&gt;
  window.ENV = {
    API_URL: &quot;%%API_URL%%&quot;,
    SENTRY_DSN: &quot;%%SENTRY_DSN%%&quot;
  };
&lt;/script&gt;</code></pre>
<p>Or load from a config endpoint:</p>
<pre><code class="language-javascript">async function loadConfig() {
  try {
    const response = await fetch(&#039;/config.json&#039;);
    return await response.json();
  } catch (error) {
    console.error(&#039;Failed to load config:&#039;, error);
    return {
      apiUrl: &#039;http://localhost:3000&#039;,
      // fallback values
    };
  }
}

export const config = await loadConfig();</code></pre>
<h3>Problem 4: Slow Initial Load</h3>
<strong>Symptoms</strong>: First visit takes several seconds to show content.
<strong>Diagnosis</strong>:
<pre><code class="language-javascript">// Add timing to index.html
&lt;script&gt;
  window.perfMetrics = {
    navigationStart: performance.timing.navigationStart,
    fetchStart: performance.timing.fetchStart,
    domainLookupEnd: performance.timing.domainLookupEnd,
    connectEnd: performance.timing.connectEnd,
    responseEnd: performance.timing.responseEnd,
    domContentLoadedEventEnd: performance.timing.domContentLoadedEventEnd,
    loadEventEnd: performance.timing.loadEventEnd
  };

  window.addEventListener(&#039;load&#039;, () =&gt; {
    const metrics = window.perfMetrics;
    console.log(&#039;DNS lookup:&#039;, metrics.domainLookupEnd - metrics.fetchStart);
    console.log(&#039;TCP connection:&#039;, metrics.connectEnd - metrics.domainLookupEnd);
    console.log(&#039;Response time:&#039;, metrics.responseEnd - metrics.connectEnd);
    console.log(&#039;DOM processing:&#039;, metrics.domContentLoadedEventEnd - metrics.responseEnd);
    console.log(&#039;Total load time:&#039;, metrics.loadEventEnd - metrics.navigationStart);
  });
&lt;/script&gt;</code></pre>
<strong>Solutions</strong>:
<ul><li>Enable compression (gzip/brotli)</li>
<li>Use CDN for static assets</li>
<li>Preload critical resources</li>
<li>Lazy load non-critical components</li>
<li>Optimize images</li>
<li>Minify JavaScript and CSS</li>
</ul>
<h2>Deployment Best Practices</h2>
<li><strong>Automate Everything</strong>: Use CI/CD pipelines for consistent, reliable deployments.</li>
<li><strong>Test Before Deploying</strong>: Run linters, unit tests, and E2E tests in your pipeline.</li>
<li><strong>Use Staging Environments</strong>: Test production builds in a staging environment first.</li>
<li><strong>Monitor Deployments</strong>: Track errors, performance, and user behavior after each deploy.</li>
<li><strong>Enable Rollbacks</strong>: Keep previous versions and be ready to rollback quickly.</li>
<li><strong>Version Your Releases</strong>: Tag releases in Git and track which version is deployed where.</li>
<li><strong>Secure Your Secrets</strong>: Never commit API keys or secrets. Use environment variables or secret managers.</li>
<li><strong>Set Cache Headers Properly</strong>: Long cache for assets (with versioned filenames), no cache for HTML.</li>
<li><strong>Use Health Checks</strong>: Implement <code>/health</code> endpoints to verify deployments succeeded.</li>
<li><strong>Document Your Process</strong>: Maintain runbooks for common deployment scenarios and troubleshooting.</li>
<h2>Hands-On Exercises</h2>
<h3>Exercise 1: Deploy to Netlify</h3>
<p>Deploy your LARC app to Netlify:</p>
<ul><li>Set up a free Netlify account</li>
<li>Connect your Git repository</li>
<li>Configure build settings and environment variables</li>
<li>Set up a custom domain (or use Netlify subdomain)</li>
<li>Configure security headers</li>
</ul>
<strong>Bonus</strong>: Set up preview deployments for pull requests.
<h3>Exercise 2: Create a CI/CD Pipeline</h3>
<p>Build a complete GitHub Actions workflow that:</p>
<ul><li>Runs tests on every push</li>
<li>Deploys to staging on merge to <code>develop</code></li>
<li>Deploys to production on merge to <code>main</code></li>
<li>Sends notifications on deployment success/failure</li>
</ul>
<strong>Bonus</strong>: Add automated performance testing with Lighthouse CI.
<h3>Exercise 3: Implement Feature Flags</h3>
<p>Create a feature flag system that:</p>
<ul><li>Loads flags from a remote config</li>
<li>Supports percentage-based rollouts</li>
<li>Allows user whitelisting</li>
<li>Caches flags locally</li>
<li>Has a UI to toggle features</li>
</ul>
<strong>Bonus</strong>: Add A/B testing with analytics integration.
<h3>Exercise 4: Set Up Error Tracking</h3>
<p>Implement production error tracking:</p>
<ul><li>Integrate Sentry or similar service</li>
<li>Capture unhandled errors and promise rejections</li>
<li>Track custom errors with context</li>
<li>Filter out noise (ResizeObserver, etc.)</li>
<li>Set up alerts for critical errors</li>
</ul>
<strong>Bonus</strong>: Add user session replay for debugging.
<h2>Summary</h2>
<p>Deploying LARC applications is straightforward—no build process means fewer things to go wrong. Key takeaways:</p>
<ul><li><strong>Static hosting is simple</strong>: Use Netlify, Vercel, GitHub Pages, or any static host</li>
<li><strong>Automate with CI/CD</strong>: Let GitHub Actions handle testing and deployment</li>
<li><strong>Security matters</strong>: Set proper headers, use HTTPS, configure CSP</li>
<li><strong>Monitor production</strong>: Track errors, performance, and user experience</li>
<li><strong>Be ready to rollback</strong>: Keep previous versions and have a rollback plan</li>
</ul>
Start with simple deployments and add sophistication as needed. The beauty of LARC's no-build approach is that deployment remains simple even as your app grows.
<h2>Further Reading</h2>
<ul><li><strong>Building with LARC - Chapter 18 (Deployment)</strong>: Advanced deployment patterns and strategies</li>
<li><strong>Building with LARC - Chapter 19 (Performance)</strong>: Production optimization techniques</li>
<li><strong>Building with LARC - Chapter 11 (Best Practices)</strong>: Security and reliability patterns</li>
</ul>
<div class="pagebreak"></div>
<h1>Component Library</h1>
<p>As your application grows, you'll accumulate reusable components. A well-organized component library accelerates development and ensures consistency.</p>
<h2>Organizing Components</h2>
<p>Structure your library logically:</p>
<pre><code class="language-plaintext">components/
├── core/
│   ├── pan-button.js
│   ├── pan-input.js
│   └── pan-card.js
├── layout/
│   ├── pan-header.js
│   ├── pan-sidebar.js
│   └── pan-grid.js
├── data/
│   ├── pan-table.js
│   ├── pan-list.js
│   └── pan-pagination.js
└── index.js</code></pre>
<p>Export from a single entry point:</p>
<pre><code class="language-javascript">// components/index.js
export * from &#039;./core/pan-button.js&#039;;
export * from &#039;./core/pan-input.js&#039;;
export * from &#039;./core/pan-card.js&#039;;
export * from &#039;./layout/pan-header.js&#039;;
// ...</code></pre>
<h2>Documentation</h2>
<p>Document every component:</p>
<pre><code class="language-javascript">/**
 * A customizable button component.
 *
 * @element pan-button
 *
 * @attr {string} variant - Button style: &quot;primary&quot;, &quot;secondary&quot;, &quot;danger&quot;
 * @attr {boolean} disabled - Disables the button
 * @attr {string} size - Button size: &quot;small&quot;, &quot;medium&quot;, &quot;large&quot;
 *
 * @fires click - Fired when button is clicked
 *
 * @slot - Button content
 *
 * @example
 * &lt;pan-button variant=&quot;primary&quot;&gt;Click me&lt;/pan-button&gt;
 *
 * @example
 * &lt;pan-button variant=&quot;danger&quot; disabled&gt;Delete&lt;/pan-button&gt;
 */
class PanButton extends HTMLElement {
  // ...
}</code></pre>
<p>Generate documentation automatically with tools like <code>web-component-analyzer</code>:</p>
<pre><code class="language-bash">npx web-component-analyzer analyze components/**/*.js --outFile docs.json</code></pre>
<h2>Design Tokens</h2>
<p>Use CSS custom properties for theming:</p>
<pre><code class="language-css">/* tokens.css */
:root {
  /* Colors */
  --color-primary: #0066cc;
  --color-secondary: #6c757d;
  --color-success: #28a745;
  --color-danger: #dc3545;

  /* Spacing */
  --space-xs: 4px;
  --space-sm: 8px;
  --space-md: 16px;
  --space-lg: 24px;
  --space-xl: 32px;

  /* Typography */
  --font-family: -apple-system, BlinkMacSystemFont, &#039;Segoe UI&#039;, Roboto, sans-serif;
  --font-size-sm: 0.875rem;
  --font-size-md: 1rem;
  --font-size-lg: 1.25rem;

  /* Borders */
  --border-radius: 4px;
  --border-width: 1px;
  --border-color: #dee2e6;
}</code></pre>
<p>Components use these tokens:</p>
<pre><code class="language-javascript">class PanButton extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: inline-block;
        }

        button {
          font-family: var(--font-family);
          font-size: var(--font-size-md);
          padding: var(--space-sm) var(--space-md);
          border-radius: var(--border-radius);
          border: var(--border-width) solid transparent;
          cursor: pointer;
        }

        :host([variant=&quot;primary&quot;]) button {
          background: var(--color-primary);
          color: white;
        }

        :host([variant=&quot;secondary&quot;]) button {
          background: var(--color-secondary);
          color: white;
        }

        :host([disabled]) button {
          opacity: 0.5;
          cursor: not-allowed;
        }
      &lt;/style&gt;
      &lt;button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;
    `;
  }
}</code></pre>
<h2>Versioning and Publishing</h2>
<p>Use semantic versioning. Publish to npm or a private registry:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;@myorg/components&quot;,
  &quot;version&quot;: &quot;1.2.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;exports&quot;: {
    &quot;.&quot;: &quot;./index.js&quot;,
    &quot;./button&quot;: &quot;./core/pan-button.js&quot;,
    &quot;./card&quot;: &quot;./core/pan-card.js&quot;
  }
}</code></pre>
<pre><code class="language-bash">npm publish --access public</code></pre>
<h2>Building a Complete Component</h2>
<p>Let's build a production-ready dialog component from scratch:</p>
<pre><code class="language-javascript">// components/core/pan-dialog.js

/**
 * A modal dialog component with accessibility support.
 *
 * @element pan-dialog
 *
 * @attr {boolean} open - Controls dialog visibility
 * @attr {string} title - Dialog title
 * @attr {boolean} modal - Whether dialog is modal (blocks background)
 * @attr {boolean} close-on-escape - Close on Escape key (default: true)
 * @attr {boolean} close-on-backdrop - Close on backdrop click (default: true)
 *
 * @fires open - Fired when dialog opens
 * @fires close - Fired when dialog closes
 * @fires cancel - Fired when user tries to close (cancelable)
 *
 * @slot - Main dialog content
 * @slot header - Custom header content
 * @slot footer - Custom footer content
 *
 * @csspart dialog - The dialog container
 * @csspart header - The header section
 * @csspart body - The body section
 * @csspart footer - The footer section
 *
 * @cssprop --dialog-width - Dialog width (default: 500px)
 * @cssprop --dialog-max-width - Maximum dialog width (default: 90vw)
 * @cssprop --dialog-backdrop - Backdrop color (default: rgba(0,0,0,0.5))
 *
 * @example
 * &lt;pan-dialog open title=&quot;Confirm Delete&quot;&gt;
 *   &lt;p&gt;Are you sure you want to delete this item?&lt;/p&gt;
 *   &lt;div slot=&quot;footer&quot;&gt;
 *     &lt;button&gt;Cancel&lt;/button&gt;
 *     &lt;button&gt;Delete&lt;/button&gt;
 *   &lt;/div&gt;
 * &lt;/pan-dialog&gt;
 */
class PanDialog extends HTMLElement {
  static observedAttributes = [&#039;open&#039;, &#039;title&#039;];

  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this._previouslyFocused = null;
  }

  connectedCallback() {
    this.render();
    this.setupAccessibility();
    this.setupEventListeners();
  }

  disconnectedCallback() {
    this.removeEventListeners();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    if (name === &#039;open&#039;) {
      newValue !== null ? this.show() : this.hide();
    } else if (name === &#039;title&#039;) {
      this.updateTitle();
    }
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 1000;
        }

        :host([open]) {
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .backdrop {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: var(--dialog-backdrop, rgba(0, 0, 0, 0.5));
          animation: fadeIn 0.2s ease-out;
        }

        .dialog {
          position: relative;
          width: var(--dialog-width, 500px);
          max-width: var(--dialog-max-width, 90vw);
          max-height: 90vh;
          background: var(--dialog-bg, white);
          border-radius: var(--border-radius, 8px);
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
          display: flex;
          flex-direction: column;
          animation: slideUp 0.3s ease-out;
        }

        .header {
          padding: var(--space-md, 16px);
          border-bottom: 1px solid var(--border-color, #e0e0e0);
          display: flex;
          align-items: center;
          justify-content: space-between;
        }

        .title {
          font-size: var(--font-size-lg, 1.25rem);
          font-weight: 600;
          margin: 0;
        }

        .close-button {
          background: none;
          border: none;
          font-size: 1.5rem;
          cursor: pointer;
          padding: 4px 8px;
          border-radius: 4px;
          color: var(--color-text-secondary, #666);
        }

        .close-button:hover {
          background: var(--color-hover, #f0f0f0);
        }

        .body {
          padding: var(--space-md, 16px);
          overflow-y: auto;
          flex: 1;
        }

        .footer {
          padding: var(--space-md, 16px);
          border-top: 1px solid var(--border-color, #e0e0e0);
          display: flex;
          justify-content: flex-end;
          gap: var(--space-sm, 8px);
        }

        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        @keyframes slideUp {
          from {
            transform: translateY(20px);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }
      &lt;/style&gt;

      &lt;div class=&quot;backdrop&quot; part=&quot;backdrop&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;dialog&quot; part=&quot;dialog&quot; role=&quot;dialog&quot; aria-modal=&quot;true&quot;&gt;
        &lt;div class=&quot;header&quot; part=&quot;header&quot;&gt;
          &lt;slot name=&quot;header&quot;&gt;
            &lt;h2 class=&quot;title&quot; id=&quot;dialog-title&quot;&gt;${this.getAttribute(&#039;title&#039;) || &#039;&#039;}&lt;/h2&gt;
          &lt;/slot&gt;
          &lt;button class=&quot;close-button&quot; aria-label=&quot;Close dialog&quot; type=&quot;button&quot;&gt;
            ×
          &lt;/button&gt;
        &lt;/div&gt;
        &lt;div class=&quot;body&quot; part=&quot;body&quot;&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div class=&quot;footer&quot; part=&quot;footer&quot;&gt;
          &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }

  setupAccessibility() {
    const dialog = this.shadowRoot.querySelector(&#039;.dialog&#039;);
    dialog.setAttribute(&#039;aria-labelledby&#039;, &#039;dialog-title&#039;);

    // Set focus trap
    const focusableElements = dialog.querySelectorAll(
      &#039;button, [href], input, select, textarea, [tabindex]:not([tabindex=&quot;-1&quot;])&#039;
    );

    this._firstFocusable = focusableElements[0];
    this._lastFocusable = focusableElements[focusableElements.length - 1];
  }

  setupEventListeners() {
    // Close button
    this.shadowRoot.querySelector(&#039;.close-button&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.close();
    });

    // Backdrop click
    if (this.hasAttribute(&#039;close-on-backdrop&#039;) || !this.hasAttribute(&#039;close-on-backdrop&#039;)) {
      this.shadowRoot.querySelector(&#039;.backdrop&#039;).addEventListener(&#039;click&#039;, () =&gt; {
        this.close();
      });
    }

    // Escape key
    this._keydownHandler = (e) =&gt; {
      if (e.key === &#039;Escape&#039; &amp;&amp; (this.hasAttribute(&#039;close-on-escape&#039;) || !this.hasAttribute(&#039;close-on-escape&#039;))) {
        this.close();
      }

      // Focus trap
      if (e.key === &#039;Tab&#039; &amp;&amp; this.hasAttribute(&#039;open&#039;)) {
        if (e.shiftKey) {
          if (document.activeElement === this._firstFocusable) {
            e.preventDefault();
            this._lastFocusable?.focus();
          }
        } else {
          if (document.activeElement === this._lastFocusable) {
            e.preventDefault();
            this._firstFocusable?.focus();
          }
        }
      }
    };

    document.addEventListener(&#039;keydown&#039;, this._keydownHandler);
  }

  removeEventListeners() {
    document.removeEventListener(&#039;keydown&#039;, this._keydownHandler);
  }

  show() {
    // Store previously focused element
    this._previouslyFocused = document.activeElement;

    // Prevent body scroll
    document.body.style.overflow = &#039;hidden&#039;;

    // Focus first focusable element
    setTimeout(() =&gt; {
      this._firstFocusable?.focus();
    }, 100);

    // Fire event
    this.dispatchEvent(new CustomEvent(&#039;open&#039;));
  }

  hide() {
    // Restore body scroll
    document.body.style.overflow = &#039;&#039;;

    // Restore focus
    this._previouslyFocused?.focus();

    // Fire event
    this.dispatchEvent(new CustomEvent(&#039;close&#039;));
  }

  close() {
    // Fire cancelable event
    const event = new CustomEvent(&#039;cancel&#039;, {
      cancelable: true
    });

    this.dispatchEvent(event);

    if (!event.defaultPrevented) {
      this.removeAttribute(&#039;open&#039;);
    }
  }

  updateTitle() {
    const titleEl = this.shadowRoot.getElementById(&#039;dialog-title&#039;);
    if (titleEl) {
      titleEl.textContent = this.getAttribute(&#039;title&#039;) || &#039;&#039;;
    }
  }
}

customElements.define(&#039;pan-dialog&#039;, PanDialog);</code></pre>
<h2>Component Showcase</h2>
<p>Build a documentation page to showcase components:</p>
<pre><code class="language-javascript">// docs/showcase.js
class ComponentShowcase extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;style&gt;
        .showcase {
          max-width: 1200px;
          margin: 0 auto;
          padding: 2rem;
        }

        .component-demo {
          margin: 2rem 0;
          padding: 2rem;
          border: 1px solid #e0e0e0;
          border-radius: 8px;
        }

        .demo-title {
          font-size: 1.5rem;
          margin-bottom: 1rem;
        }

        .demo-example {
          padding: 1rem;
          background: #f8f8f8;
          border-radius: 4px;
          margin: 1rem 0;
        }

        .demo-code {
          background: #282c34;
          color: #abb2bf;
          padding: 1rem;
          border-radius: 4px;
          overflow-x: auto;
        }

        .demo-props {
          margin-top: 1rem;
        }

        .prop-table {
          width: 100%;
          border-collapse: collapse;
        }

        .prop-table th,
        .prop-table td {
          text-align: left;
          padding: 0.5rem;
          border-bottom: 1px solid #e0e0e0;
        }
      &lt;/style&gt;

      &lt;div class=&quot;showcase&quot;&gt;
        &lt;h1&gt;Component Library&lt;/h1&gt;

        &lt;div class=&quot;component-demo&quot;&gt;
          &lt;h2 class=&quot;demo-title&quot;&gt;Dialog&lt;/h2&gt;
          &lt;p&gt;A modal dialog with accessibility features.&lt;/p&gt;

          &lt;div class=&quot;demo-example&quot;&gt;
            &lt;button id=&quot;open-dialog&quot;&gt;Open Dialog&lt;/button&gt;
            &lt;pan-dialog id=&quot;demo-dialog&quot; title=&quot;Example Dialog&quot;&gt;
              &lt;p&gt;This is a sample dialog with default settings.&lt;/p&gt;
              &lt;div slot=&quot;footer&quot;&gt;
                &lt;button id=&quot;cancel-btn&quot;&gt;Cancel&lt;/button&gt;
                &lt;button id=&quot;confirm-btn&quot; style=&quot;background: #0066cc; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;&quot;&gt;Confirm&lt;/button&gt;
              &lt;/div&gt;
            &lt;/pan-dialog&gt;
          &lt;/div&gt;

          &lt;div class=&quot;demo-code&quot;&gt;
&lt;pre&gt;&amp;lt;pan-dialog open title=&quot;Example Dialog&quot;&amp;gt;
  &amp;lt;p&amp;gt;This is a sample dialog.&amp;lt;/p&amp;gt;
  &amp;lt;div slot=&quot;footer&quot;&amp;gt;
    &amp;lt;button&amp;gt;Cancel&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;Confirm&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/pan-dialog&amp;gt;&lt;/pre&gt;
          &lt;/div&gt;

          &lt;div class=&quot;demo-props&quot;&gt;
            &lt;h3&gt;Properties&lt;/h3&gt;
            &lt;table class=&quot;prop-table&quot;&gt;
              &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th&gt;Attribute&lt;/th&gt;
                  &lt;th&gt;Type&lt;/th&gt;
                  &lt;th&gt;Default&lt;/th&gt;
                  &lt;th&gt;Description&lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;open&lt;/code&gt;&lt;/td&gt;
                  &lt;td&gt;boolean&lt;/td&gt;
                  &lt;td&gt;false&lt;/td&gt;
                  &lt;td&gt;Controls dialog visibility&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
                  &lt;td&gt;string&lt;/td&gt;
                  &lt;td&gt;&quot;&quot;&lt;/td&gt;
                  &lt;td&gt;Dialog title&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;close-on-escape&lt;/code&gt;&lt;/td&gt;
                  &lt;td&gt;boolean&lt;/td&gt;
                  &lt;td&gt;true&lt;/td&gt;
                  &lt;td&gt;Close on Escape key&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td&gt;&lt;code&gt;close-on-backdrop&lt;/code&gt;&lt;/td&gt;
                  &lt;td&gt;boolean&lt;/td&gt;
                  &lt;td&gt;true&lt;/td&gt;
                  &lt;td&gt;Close on backdrop click&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;

    // Setup demo interactivity
    this.setupDemos();
  }

  setupDemos() {
    const openBtn = this.querySelector(&#039;#open-dialog&#039;);
    const dialog = this.querySelector(&#039;#demo-dialog&#039;);
    const cancelBtn = this.querySelector(&#039;#cancel-btn&#039;);
    const confirmBtn = this.querySelector(&#039;#confirm-btn&#039;);

    openBtn.addEventListener(&#039;click&#039;, () =&gt; {
      dialog.setAttribute(&#039;open&#039;, &#039;&#039;);
    });

    cancelBtn.addEventListener(&#039;click&#039;, () =&gt; {
      dialog.removeAttribute(&#039;open&#039;);
    });

    confirmBtn.addEventListener(&#039;click&#039;, () =&gt; {
      alert(&#039;Confirmed!&#039;);
      dialog.removeAttribute(&#039;open&#039;);
    });
  }
}

customElements.define(&#039;component-showcase&#039;, ComponentShowcase);</code></pre>
<h2>Testing Components</h2>
<p>Write comprehensive tests for your components:</p>
<pre><code class="language-javascript">// components/core/pan-dialog.test.js
import { expect, fixture, html, oneEvent } from &#039;@open-wc/testing&#039;;
import &#039;./pan-dialog.js&#039;;

describe(&#039;PanDialog&#039;, () =&gt; {
  it(&#039;should render with default attributes&#039;, async () =&gt; {
    const el = await fixture(html`&lt;pan-dialog&gt;&lt;/pan-dialog&gt;`);
    expect(el).to.exist;
    expect(el.hasAttribute(&#039;open&#039;)).to.be.false;
  });

  it(&#039;should show when open attribute is set&#039;, async () =&gt; {
    const el = await fixture(html`&lt;pan-dialog open&gt;&lt;/pan-dialog&gt;`);
    const computedStyle = window.getComputedStyle(el);
    expect(computedStyle.display).to.equal(&#039;flex&#039;);
  });

  it(&#039;should hide when open attribute is removed&#039;, async () =&gt; {
    const el = await fixture(html`&lt;pan-dialog open&gt;&lt;/pan-dialog&gt;`);
    el.removeAttribute(&#039;open&#039;);
    await el.updateComplete;
    const computedStyle = window.getComputedStyle(el);
    expect(computedStyle.display).to.equal(&#039;none&#039;);
  });

  it(&#039;should fire open event when opened&#039;, async () =&gt; {
    const el = await fixture(html`&lt;pan-dialog&gt;&lt;/pan-dialog&gt;`);
    setTimeout(() =&gt; el.setAttribute(&#039;open&#039;, &#039;&#039;));
    const { detail } = await oneEvent(el, &#039;open&#039;);
    expect(detail).to.exist;
  });

  it(&#039;should fire close event when closed&#039;, async () =&gt; {
    const el = await fixture(html`&lt;pan-dialog open&gt;&lt;/pan-dialog&gt;`);
    setTimeout(() =&gt; el.removeAttribute(&#039;open&#039;));
    const { detail } = await oneEvent(el, &#039;close&#039;);
    expect(detail).to.exist;
  });

  it(&#039;should close on backdrop click&#039;, async () =&gt; {
    const el = await fixture(html`&lt;pan-dialog open close-on-backdrop&gt;&lt;/pan-dialog&gt;`);
    const backdrop = el.shadowRoot.querySelector(&#039;.backdrop&#039;);

    setTimeout(() =&gt; backdrop.click());
    await oneEvent(el, &#039;cancel&#039;);

    expect(el.hasAttribute(&#039;open&#039;)).to.be.false;
  });

  it(&#039;should close on Escape key&#039;, async () =&gt; {
    const el = await fixture(html`&lt;pan-dialog open close-on-escape&gt;&lt;/pan-dialog&gt;`);

    setTimeout(() =&gt; {
      const event = new KeyboardEvent(&#039;keydown&#039;, { key: &#039;Escape&#039; });
      document.dispatchEvent(event);
    });

    await oneEvent(el, &#039;cancel&#039;);
    expect(el.hasAttribute(&#039;open&#039;)).to.be.false;
  });

  it(&#039;should trap focus within dialog&#039;, async () =&gt; {
    const el = await fixture(html`
      &lt;pan-dialog open&gt;
        &lt;button id=&quot;btn1&quot;&gt;Button 1&lt;/button&gt;
        &lt;button id=&quot;btn2&quot;&gt;Button 2&lt;/button&gt;
      &lt;/pan-dialog&gt;
    `);

    const btn1 = el.querySelector(&#039;#btn1&#039;);
    const btn2 = el.querySelector(&#039;#btn2&#039;);

    btn2.focus();
    expect(document.activeElement).to.equal(btn2);

    // Simulate Tab key on last focusable element
    const tabEvent = new KeyboardEvent(&#039;keydown&#039;, { key: &#039;Tab&#039;, bubbles: true });
    document.dispatchEvent(tabEvent);

    // Should wrap to first focusable element
    expect(document.activeElement).to.equal(btn1);
  });

  it(&#039;should support custom CSS parts&#039;, async () =&gt; {
    const el = await fixture(html`&lt;pan-dialog open&gt;&lt;/pan-dialog&gt;`);
    const dialog = el.shadowRoot.querySelector(&#039;[part=&quot;dialog&quot;]&#039;);
    const header = el.shadowRoot.querySelector(&#039;[part=&quot;header&quot;]&#039;);
    const body = el.shadowRoot.querySelector(&#039;[part=&quot;body&quot;]&#039;);

    expect(dialog).to.exist;
    expect(header).to.exist;
    expect(body).to.exist;
  });

  it(&#039;should render slotted content&#039;, async () =&gt; {
    const el = await fixture(html`
      &lt;pan-dialog open&gt;
        &lt;p&gt;Custom content&lt;/p&gt;
        &lt;button slot=&quot;footer&quot;&gt;Action&lt;/button&gt;
      &lt;/pan-dialog&gt;
    `);

    const paragraph = el.querySelector(&#039;p&#039;);
    const footerButton = el.querySelector(&#039;[slot=&quot;footer&quot;]&#039;);

    expect(paragraph.textContent).to.equal(&#039;Custom content&#039;);
    expect(footerButton.textContent).to.equal(&#039;Action&#039;);
  });
});</code></pre>
<h2>Theming System</h2>
<p>Create a comprehensive theming system:</p>
<pre><code class="language-javascript">// themes/theme-manager.js
class ThemeManager {
  constructor() {
    this.themes = new Map();
    this.currentTheme = &#039;default&#039;;
  }

  registerTheme(name, tokens) {
    this.themes.set(name, tokens);
  }

  applyTheme(name) {
    const theme = this.themes.get(name);
    if (!theme) {
      console.warn(`Theme &quot;${name}&quot; not found`);
      return;
    }

    // Apply CSS custom properties to :root
    Object.entries(theme).forEach(([key, value]) =&gt; {
      document.documentElement.style.setProperty(key, value);
    });

    this.currentTheme = name;

    // Store preference
    localStorage.setItem(&#039;theme&#039;, name);

    // Dispatch event
    window.dispatchEvent(new CustomEvent(&#039;theme-changed&#039;, {
      detail: { theme: name }
    }));
  }

  getCurrentTheme() {
    return this.currentTheme;
  }

  getAvailableThemes() {
    return Array.from(this.themes.keys());
  }
}

export const themeManager = new ThemeManager();

// Register default theme
themeManager.registerTheme(&#039;default&#039;, {
  &#039;--color-primary&#039;: &#039;#0066cc&#039;,
  &#039;--color-secondary&#039;: &#039;#6c757d&#039;,
  &#039;--color-success&#039;: &#039;#28a745&#039;,
  &#039;--color-danger&#039;: &#039;#dc3545&#039;,
  &#039;--color-warning&#039;: &#039;#ffc107&#039;,
  &#039;--color-info&#039;: &#039;#17a2b8&#039;,

  &#039;--color-text&#039;: &#039;#212529&#039;,
  &#039;--color-text-secondary&#039;: &#039;#6c757d&#039;,
  &#039;--color-bg&#039;: &#039;#ffffff&#039;,
  &#039;--color-bg-secondary&#039;: &#039;#f8f9fa&#039;,

  &#039;--space-xs&#039;: &#039;4px&#039;,
  &#039;--space-sm&#039;: &#039;8px&#039;,
  &#039;--space-md&#039;: &#039;16px&#039;,
  &#039;--space-lg&#039;: &#039;24px&#039;,
  &#039;--space-xl&#039;: &#039;32px&#039;,

  &#039;--font-family&#039;: &#039;-apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, sans-serif&#039;,
  &#039;--font-size-sm&#039;: &#039;0.875rem&#039;,
  &#039;--font-size-md&#039;: &#039;1rem&#039;,
  &#039;--font-size-lg&#039;: &#039;1.25rem&#039;,
  &#039;--font-size-xl&#039;: &#039;1.5rem&#039;,

  &#039;--border-radius&#039;: &#039;4px&#039;,
  &#039;--border-radius-lg&#039;: &#039;8px&#039;,
  &#039;--border-width&#039;: &#039;1px&#039;,
  &#039;--border-color&#039;: &#039;#dee2e6&#039;,

  &#039;--shadow-sm&#039;: &#039;0 1px 2px rgba(0, 0, 0, 0.05)&#039;,
  &#039;--shadow-md&#039;: &#039;0 4px 6px rgba(0, 0, 0, 0.1)&#039;,
  &#039;--shadow-lg&#039;: &#039;0 10px 15px rgba(0, 0, 0, 0.1)&#039;,
});

// Register dark theme
themeManager.registerTheme(&#039;dark&#039;, {
  &#039;--color-primary&#039;: &#039;#4d9fff&#039;,
  &#039;--color-secondary&#039;: &#039;#6c757d&#039;,
  &#039;--color-success&#039;: &#039;#28a745&#039;,
  &#039;--color-danger&#039;: &#039;#dc3545&#039;,
  &#039;--color-warning&#039;: &#039;#ffc107&#039;,
  &#039;--color-info&#039;: &#039;#17a2b8&#039;,

  &#039;--color-text&#039;: &#039;#e9ecef&#039;,
  &#039;--color-text-secondary&#039;: &#039;#adb5bd&#039;,
  &#039;--color-bg&#039;: &#039;#212529&#039;,
  &#039;--color-bg-secondary&#039;: &#039;#343a40&#039;,

  &#039;--border-color&#039;: &#039;#495057&#039;,

  &#039;--shadow-sm&#039;: &#039;0 1px 2px rgba(0, 0, 0, 0.3)&#039;,
  &#039;--shadow-md&#039;: &#039;0 4px 6px rgba(0, 0, 0, 0.4)&#039;,
  &#039;--shadow-lg&#039;: &#039;0 10px 15px rgba(0, 0, 0, 0.4)&#039;,
});

// Apply saved theme or default
const savedTheme = localStorage.getItem(&#039;theme&#039;) || &#039;default&#039;;
themeManager.applyTheme(savedTheme);</code></pre>
<strong>Theme switcher component:</strong>
<pre><code class="language-javascript">class ThemeSwitcher extends HTMLElement {
  connectedCallback() {
    import(&#039;./theme-manager.js&#039;).then(({ themeManager }) =&gt; {
      this.themeManager = themeManager;
      this.render();
    });
  }

  render() {
    const themes = this.themeManager.getAvailableThemes();
    const current = this.themeManager.getCurrentTheme();

    this.innerHTML = `
      &lt;style&gt;
        .theme-switcher {
          display: inline-flex;
          gap: 0.5rem;
        }

        .theme-button {
          padding: 0.5rem 1rem;
          border: 1px solid var(--border-color);
          border-radius: var(--border-radius);
          background: var(--color-bg);
          color: var(--color-text);
          cursor: pointer;
        }

        .theme-button.active {
          background: var(--color-primary);
          color: white;
          border-color: var(--color-primary);
        }
      &lt;/style&gt;

      &lt;div class=&quot;theme-switcher&quot;&gt;
        ${themes.map(theme =&gt; `
          &lt;button
            class=&quot;theme-button ${theme === current ? &#039;active&#039; : &#039;&#039;}&quot;
            data-theme=&quot;${theme}&quot;
          &gt;
            ${theme}
          &lt;/button&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;
    `;

    // Add event listeners
    this.querySelectorAll(&#039;.theme-button&#039;).forEach(btn =&gt; {
      btn.addEventListener(&#039;click&#039;, () =&gt; {
        const theme = btn.dataset.theme;
        this.themeManager.applyTheme(theme);
        this.render();
      });
    });
  }
}

customElements.define(&#039;theme-switcher&#039;, ThemeSwitcher);</code></pre>
<h2>Publishing to npm</h2>
<p>Prepare your library for npm:</p>
<strong>1. package.json configuration:</strong>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;@myorg/larc-components&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;LARC component library&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;main&quot;: &quot;./index.js&quot;,
  &quot;exports&quot;: {
    &quot;.&quot;: {
      &quot;import&quot;: &quot;./index.js&quot;,
      &quot;types&quot;: &quot;./index.d.ts&quot;
    },
    &quot;./dialog&quot;: {
      &quot;import&quot;: &quot;./components/core/pan-dialog.js&quot;,
      &quot;types&quot;: &quot;./components/core/pan-dialog.d.ts&quot;
    },
    &quot;./button&quot;: {
      &quot;import&quot;: &quot;./components/core/pan-button.js&quot;
    },
    &quot;./themes/*&quot;: &quot;./themes/*&quot;
  },
  &quot;files&quot;: [
    &quot;components/&quot;,
    &quot;themes/&quot;,
    &quot;index.js&quot;,
    &quot;README.md&quot;
  ],
  &quot;keywords&quot;: [
    &quot;web-components&quot;,
    &quot;larc&quot;,
    &quot;components&quot;,
    &quot;ui&quot;
  ],
  &quot;customElements&quot;: &quot;custom-elements.json&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;web-test-runner \&quot;components/**/*.test.js\&quot;&quot;,
    &quot;analyze&quot;: &quot;wca analyze \&quot;components/**/*.js\&quot; --outFile custom-elements.json&quot;,
    &quot;prepublishOnly&quot;: &quot;npm test &amp;&amp; npm run analyze&quot;
  },
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/myorg/larc-components&quot;
  },
  &quot;license&quot;: &quot;MIT&quot;
}</code></pre>
<strong>2. Create README.md:</strong>
<pre><code class="language-markdown"># @myorg/larc-components

A collection of accessible, themeable web components built with LARC.

## Installation</code></pre>bash
npm install @myorg/larc-components
<pre><code class="language-plaintext">## Usage

### Import all components</code></pre>javascript
import '@myorg/larc-components';
<pre><code class="language-plaintext">### Import specific components</code></pre>javascript
import '@myorg/larc-components/dialog';
import '@myorg/larc-components/button';
<pre><code class="language-plaintext">### Use in HTML</code></pre>html
<pan-dialog open title="Example">
  <p>Dialog content</p>
</pan-dialog>
<pre><code class="language-plaintext">## Theming</code></pre>javascript
import { themeManager } from '@myorg/larc-components/themes/theme-manager.js';
<p>// Apply dark theme
themeManager.applyTheme('dark');</p>
<p>// Register custom theme
themeManager.registerTheme('custom', {
  '--color-primary': '#ff0000',
  // ...more tokens
});
<pre><code class="language-plaintext">## Components

- `&lt;pan-dialog&gt;` - Modal dialog
- `&lt;pan-button&gt;` - Button component
- `&lt;pan-card&gt;` - Card container
- More coming soon...

## License

MIT</code></pre></p>
<strong>3. Publish:</strong>
<pre><code class="language-bash"># Login to npm
npm login

# Publish (first time)
npm publish --access public

# Publish update
npm version patch  # or minor, major
npm publish</code></pre>
<h2>Version Management</h2>
<p>Follow semantic versioning and maintain a changelog:</p>
<pre><code class="language-markdown"># Changelog

All notable changes to this project will be documented in this file.

## [1.2.0] - 2024-01-15

### Added
- New `&lt;pan-dialog&gt;` component with full accessibility support
- Dark theme support
- CSS parts for style customization

### Changed
- Improved button component focus styles
- Updated default theme colors

### Fixed
- Fixed focus trap in dialog component
- Fixed memory leak in theme manager

## [1.1.0] - 2024-01-01

### Added
- New `&lt;pan-card&gt;` component
- Theme switcher component

### Changed
- Breaking: Renamed `variant` to `type` in button component

### Migration Guide

Update button variant attribute:</code></pre>html
<!-- Before -->
<pan-button variant="primary">Click</pan-button>
<!-- After -->
<pan-button type="primary">Click</pan-button>
<pre><code class="language-plaintext">## [1.0.0] - 2023-12-01

- Initial release</code></pre>
<h2>Component API Design Patterns</h2>
<p>Design consistent, predictable component APIs:</p>
<strong>1. Boolean attributes:</strong>
<pre><code class="language-javascript">// ✅ Good: Use presence/absence
&lt;pan-dialog open&gt;&lt;/pan-dialog&gt;
&lt;pan-button disabled&gt;&lt;/pan-button&gt;

// ❌ Bad: Use string values
&lt;pan-dialog open=&quot;true&quot;&gt;&lt;/pan-dialog&gt;</code></pre>
<strong>2. Enum attributes:</strong>
<pre><code class="language-javascript">// ✅ Good: Use lowercase, hyphenated
&lt;pan-button variant=&quot;primary&quot;&gt;&lt;/pan-button&gt;
&lt;pan-input type=&quot;email&quot;&gt;&lt;/pan-input&gt;

// ❌ Bad: Use camelCase or weird casing
&lt;pan-button variant=&quot;Primary&quot;&gt;&lt;/pan-button&gt;</code></pre>
<strong>3. Event naming:</strong>
<pre><code class="language-javascript">// ✅ Good: Use present tense for state changes
element.addEventListener(&#039;open&#039;, () =&gt; {});
element.addEventListener(&#039;close&#039;, () =&gt; {});

// ✅ Good: Use past tense for completed actions
element.addEventListener(&#039;loaded&#039;, () =&gt; {});
element.addEventListener(&#039;changed&#039;, () =&gt; {});</code></pre>
<strong>4. CSS custom properties:</strong>
<pre><code class="language-javascript">// ✅ Good: Namespace and descriptive
--dialog-width
--button-primary-bg
--card-border-radius

// ❌ Bad: Generic or unclear
--width
--bg
--radius</code></pre>
<strong>5. Slots:</strong>
<pre><code class="language-javascript">// ✅ Good: Named slots for specific content
&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
&lt;slot&gt;&lt;/slot&gt;  // default slot

// ❌ Bad: Too many unnamed slots</code></pre>
<h2>Troubleshooting Component Libraries</h2>
<h3>Problem 1: Styles Bleeding Between Components</h3>
<strong>Symptoms</strong>: Components inherit unwanted styles from global CSS or other components.
<strong>Cause</strong>: Not using Shadow DOM or improperly scoped styles.
<strong>Solution</strong>:
<pre><code class="language-javascript">// ✅ Always use Shadow DOM for encapsulation
class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });  // ← Critical!
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        /* These styles won&#039;t leak out */
        :host {
          display: block;
        }
      &lt;/style&gt;
      &lt;div class=&quot;content&quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h3>Problem 2: Components Not Updating When Attributes Change</h3>
<strong>Symptoms</strong>: Changing attributes doesn't update the component.
<strong>Cause</strong>: Not implementing <code>observedAttributes</code> or <code>attributeChangedCallback</code>.
<strong>Solution</strong>:
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  // ✅ Declare which attributes to watch
  static observedAttributes = [&#039;value&#039;, &#039;disabled&#039;];

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    // Handle attribute change
    if (name === &#039;value&#039;) {
      this.updateValue(newValue);
    } else if (name === &#039;disabled&#039;) {
      this.updateDisabledState(newValue !== null);
    }
  }
}</code></pre>
<h3>Problem 3: Memory Leaks in Components</h3>
<strong>Symptoms</strong>: Memory usage grows over time, especially when components are added/removed.
<strong>Cause</strong>: Event listeners not cleaned up.
<strong>Solution</strong>:
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  connectedCallback() {
    // Store handler reference
    this._resizeHandler = () =&gt; this.handleResize();
    window.addEventListener(&#039;resize&#039;, this._resizeHandler);

    this._panSubscriptionId = pan.subscribe(&#039;data.updated&#039;, () =&gt; {
      this.refresh();
    });
  }

  disconnectedCallback() {
    // ✅ Clean up everything
    window.removeEventListener(&#039;resize&#039;, this._resizeHandler);

    if (this._panSubscriptionId) {
      pan.unsubscribe(this._panSubscriptionId);
    }
  }
}</code></pre>
<h3>Problem 4: Slow Component Registration</h3>
<strong>Symptoms</strong>: Initial page load is slow when many components are imported.
<strong>Cause</strong>: Importing all components upfront.
<strong>Solution</strong>:
<pre><code class="language-javascript">// ❌ Bad: Import everything upfront
import &#039;./components/dialog.js&#039;;
import &#039;./components/button.js&#039;;
import &#039;./components/card.js&#039;;
// ... 50 more imports

// ✅ Good: Lazy load on demand
const componentRegistry = new Map([
  [&#039;pan-dialog&#039;, () =&gt; import(&#039;./components/dialog.js&#039;)],
  [&#039;pan-button&#039;, () =&gt; import(&#039;./components/button.js&#039;)],
  [&#039;pan-card&#039;, () =&gt; import(&#039;./components/card.js&#039;)]
]);

// Auto-load when component is used
const observer = new MutationObserver((mutations) =&gt; {
  mutations.forEach(mutation =&gt; {
    mutation.addedNodes.forEach(node =&gt; {
      if (node.nodeType === 1) {
        const tagName = node.tagName.toLowerCase();
        if (componentRegistry.has(tagName)) {
          componentRegistry.get(tagName)();
          componentRegistry.delete(tagName);  // Load once
        }
      }
    });
  });
});

observer.observe(document.body, {
  childList: true,
  subtree: true
});</code></pre>
<h2>Component Library Best Practices</h2>
<li><strong>Always Use Shadow DOM</strong>: Encapsulate styles and prevent leakage.</li>
<li><strong>Document Everything</strong>: Use JSDoc comments for all public APIs.</li>
<li><strong>Test Thoroughly</strong>: Unit tests, accessibility tests, and visual regression tests.</li>
<li><strong>Follow Web Standards</strong>: Use standard HTML attributes and patterns when possible.</li>
<li><strong>Make Components Composable</strong>: Small, focused components that work well together.</li>
<li><strong>Provide Customization</strong>: CSS parts, custom properties, and slots for flexibility.</li>
<li><strong>Accessibility First</strong>: Always include ARIA attributes, keyboard navigation, and focus management.</li>
<li><strong>Version Carefully</strong>: Follow semantic versioning and provide migration guides for breaking changes.</li>
<li><strong>Optimize Performance</strong>: Lazy load components, clean up resources, avoid unnecessary re-renders.</li>
<li><strong>Maintain Consistency</strong>: Use consistent naming, patterns, and behaviors across all components.</li>
<h2>Hands-On Exercises</h2>
<h3>Exercise 1: Build a Toast Notification Component</h3>
<p>Create a <code><pan-toast></code> component that:</p>
<ul><li>Shows temporary notifications</li>
<li>Supports different types (success, error, warning, info)</li>
<li>Auto-dismisses after a timeout</li>
<li>Stacks multiple toasts</li>
<li>Has accessible announcements (aria-live)</li>
</ul>
<strong>Bonus</strong>: Add slide-in animations and a queue system.
<h3>Exercise 2: Create a Component Documentation Site</h3>
<p>Build an interactive documentation site for your components that:</p>
<ul><li>Shows live examples with editable code</li>
<li>Displays component API (props, events, slots)</li>
<li>Includes accessibility information</li>
<li>Has a theme switcher</li>
<li>Provides copy-paste code snippets</li>
</ul>
<strong>Bonus</strong>: Generate documentation from JSDoc comments automatically.
<h3>Exercise 3: Implement a Component Testing Suite</h3>
<p>Set up comprehensive testing for a component:</p>
<ul><li>Unit tests for all functionality</li>
<li>Accessibility tests (keyboard nav, screen readers)</li>
<li>Visual regression tests with screenshots</li>
<li>Performance tests (render time)</li>
<li>Cross-browser testing</li>
</ul>
<strong>Bonus</strong>: Integrate tests into CI/CD pipeline.
<h3>Exercise 4: Publish a Component Package</h3>
<p>Package and publish a component library:</p>
<ul><li>Set up proper package.json with exports</li>
<li>Create comprehensive README</li>
<li>Write CHANGELOG.md</li>
<li>Publish to npm</li>
<li>Set up automated versioning and releases</li>
</ul>
<strong>Bonus</strong>: Create a landing page with examples and documentation.
<h2>Summary</h2>
<p>Building a component library is about more than just writing components—it's about creating a sustainable system:</p>
<ul><li><strong>Organize logically</strong>: Group related components, use consistent naming</li>
<li><strong>Document thoroughly</strong>: Every component, prop, event, and slot</li>
<li><strong>Test comprehensively</strong>: Unit, integration, accessibility, visual</li>
<li><strong>Theme consistently</strong>: Design tokens and CSS custom properties</li>
<li><strong>Version carefully</strong>: Semantic versioning with clear changelogs</li>
<li><strong>Distribute effectively</strong>: npm, CDN, or monorepo</li>
</ul>
A well-maintained component library accelerates development and ensures consistency across your applications.
<h2>Further Reading</h2>
<ul><li><strong>Building with LARC - Chapter 15 (Component Patterns)</strong>: Advanced component architecture</li>
<li><strong>Building with LARC - Chapter 5 (Shadow DOM)</strong>: Deep dive into encapsulation</li>
<li><strong>Building with LARC - Chapter 10 (Accessibility)</strong>: Making components accessible</li>
</ul>
<div class="pagebreak"></div>
<h1>Tooling</h1>
<p>While LARC doesn't require a build step, the right tools make development faster and more enjoyable.</p>
<h2>Development Server</h2>
<p>A simple development server with live reload:</p>
<pre><code class="language-javascript">// dev-server.js
const http = require(&#039;http&#039;);
const fs = require(&#039;fs&#039;);
const path = require(&#039;path&#039;);
const WebSocket = require(&#039;ws&#039;);

const PORT = 3000;
const PUBLIC_DIR = &#039;./public&#039;;

// HTTP Server
const server = http.createServer((req, res) =&gt; {
  let filePath = path.join(PUBLIC_DIR, req.url === &#039;/&#039; ? &#039;index.html&#039; : req.url);

  const ext = path.extname(filePath);
  const contentTypes = {
    &#039;.html&#039;: &#039;text/html&#039;,
    &#039;.js&#039;: &#039;application/javascript&#039;,
    &#039;.mjs&#039;: &#039;application/javascript&#039;,
    &#039;.css&#039;: &#039;text/css&#039;,
    &#039;.json&#039;: &#039;application/json&#039;
  };

  fs.readFile(filePath, (err, content) =&gt; {
    if (err) {
      res.writeHead(404);
      res.end(&#039;Not found&#039;);
      return;
    }

    res.writeHead(200, { &#039;Content-Type&#039;: contentTypes[ext] || &#039;text/plain&#039; });
    res.end(content);
  });
});

// WebSocket for live reload
const wss = new WebSocket.Server({ server });

fs.watch(PUBLIC_DIR, { recursive: true }, () =&gt; {
  wss.clients.forEach(client =&gt; {
    if (client.readyState === WebSocket.OPEN) {
      client.send(&#039;reload&#039;);
    }
  });
});

server.listen(PORT, () =&gt; console.log(`Dev server at http://localhost:${PORT}`));</code></pre>
<p>Add live reload to your HTML:</p>
<pre><code class="language-html">&lt;script&gt;
  const ws = new WebSocket(&#039;ws://localhost:3000&#039;);
  ws.onmessage = () =&gt; location.reload();
&lt;/script&gt;</code></pre>
<h2>VS Code Configuration</h2>
<p>Enhance your editor experience:</p>
<pre><code class="language-json">// .vscode/settings.json
{
  &quot;editor.formatOnSave&quot;: true,
  &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,
  &quot;emmet.includeLanguages&quot;: {
    &quot;javascript&quot;: &quot;html&quot;
  },
  &quot;files.associations&quot;: {
    &quot;*.mjs&quot;: &quot;javascript&quot;
  }
}</code></pre>
<p>Useful snippets:</p>
<pre><code class="language-json">// .vscode/snippets/larc.code-snippets
{
  &quot;LARC Component&quot;: {
    &quot;prefix&quot;: &quot;larc&quot;,
    &quot;body&quot;: [
      &quot;class ${1:ComponentName} extends HTMLElement {&quot;,
      &quot;  constructor() {&quot;,
      &quot;    super();&quot;,
      &quot;    this.attachShadow({ mode: &#039;open&#039; });&quot;,
      &quot;  }&quot;,
      &quot;&quot;,
      &quot;  connectedCallback() {&quot;,
      &quot;    this.render();&quot;,
      &quot;  }&quot;,
      &quot;&quot;,
      &quot;  render() {&quot;,
      &quot;    this.shadowRoot.innerHTML = `&quot;,
      &quot;      &lt;style&gt;&quot;,
      &quot;        :host { display: block; }&quot;,
      &quot;      &lt;/style&gt;&quot;,
      &quot;      &lt;div&gt;$2&lt;/div&gt;&quot;,
      &quot;    `;&quot;,
      &quot;  }&quot;,
      &quot;}&quot;,
      &quot;&quot;,
      &quot;customElements.define(&#039;${3:component-name}&#039;, ${1:ComponentName});&quot;
    ]
  }
}</code></pre>
<h2>ESLint Configuration</h2>
<p>Lint your code for consistency:</p>
<pre><code class="language-javascript">// eslint.config.js
export default [
  {
    files: [&#039;**/*.js&#039;, &#039;**/*.mjs&#039;],
    rules: {
      &#039;no-unused-vars&#039;: &#039;warn&#039;,
      &#039;no-console&#039;: [&#039;warn&#039;, { allow: [&#039;warn&#039;, &#039;error&#039;] }],
      &#039;prefer-const&#039;: &#039;error&#039;,
      &#039;no-var&#039;: &#039;error&#039;
    }
  }
];</code></pre>
<h2>Browser DevTools</h2>
<p>Chrome DevTools has excellent Web Component support:</p>
<ul><li><strong>Elements panel</strong>: Inspect shadow DOM by clicking the <code>#shadow-root</code> toggle</li>
<li><strong>Console</strong>: Access element's shadow root with <code>$0.shadowRoot</code></li>
<li><strong>Network panel</strong>: Monitor fetch requests and WebSocket connections</li>
<li><strong>Performance panel</strong>: Profile render performance</li>
<li><strong>Application panel</strong>: Inspect localStorage, sessionStorage, IndexedDB</li>
</ul>
<h2>Debugging PAN Bus</h2>
<p>Add a debug utility:</p>
<pre><code class="language-javascript">// pan-debug.js
pan.subscribe(&#039;*&#039;, (data, topic) =&gt; {
  console.log(`[PAN] ${topic}`, data);
});</code></pre>
<p>Or use the LARC DevTools extension for a visual message inspector.</p>
<h2>Complete Development Environment Setup</h2>
<p>Let's set up a full-featured development environment:</p>
<strong>1. Project structure:</strong>
<pre><code class="language-plaintext">my-larc-project/
├── public/
│   ├── index.html
│   ├── app.js
│   ├── components/
│   └── styles/
├── tests/
│   ├── unit/
│   └── e2e/
├── .vscode/
│   ├── settings.json
│   ├── extensions.json
│   └── snippets/
├── .eslintrc.js
├── .prettierrc
├── package.json
└── dev-server.js</code></pre>
<strong>2. Package.json with dev scripts:</strong>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;my-larc-app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;node dev-server.js&quot;,
    &quot;test&quot;: &quot;web-test-runner \&quot;tests/**/*.test.js\&quot;&quot;,
    &quot;test:watch&quot;: &quot;npm test -- --watch&quot;,
    &quot;lint&quot;: &quot;eslint &#039;**/*.{js,mjs}&#039;&quot;,
    &quot;lint:fix&quot;: &quot;eslint &#039;**/*.{js,mjs}&#039; --fix&quot;,
    &quot;format&quot;: &quot;prettier --write &#039;**/*.{js,mjs,html,css,json,md}&#039;&quot;,
    &quot;format:check&quot;: &quot;prettier --check &#039;**/*.{js,mjs,html,css,json,md}&#039;&quot;,
    &quot;analyze&quot;: &quot;wca analyze &#039;public/components/**/*.js&#039; --outFile custom-elements.json&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@open-wc/testing&quot;: &quot;^4.0.0&quot;,
    &quot;@web/dev-server&quot;: &quot;^0.4.0&quot;,
    &quot;@web/test-runner&quot;: &quot;^0.18.0&quot;,
    &quot;eslint&quot;: &quot;^8.0.0&quot;,
    &quot;prettier&quot;: &quot;^3.0.0&quot;,
    &quot;web-component-analyzer&quot;: &quot;^2.0.0&quot;,
    &quot;ws&quot;: &quot;^8.0.0&quot;
  }
}</code></pre>
<strong>3. Complete dev server with HMR:</strong>
<pre><code class="language-javascript">// dev-server.js
import { createServer } from &#039;http&#039;;
import { readFile } from &#039;fs/promises&#039;;
import { watch } from &#039;fs&#039;;
import { join, extname } from &#039;path&#039;;
import { WebSocketServer } from &#039;ws&#039;;

const PORT = 3000;
const PUBLIC_DIR = &#039;./public&#039;;

const contentTypes = {
  &#039;.html&#039;: &#039;text/html; charset=utf-8&#039;,
  &#039;.js&#039;: &#039;application/javascript; charset=utf-8&#039;,
  &#039;.mjs&#039;: &#039;application/javascript; charset=utf-8&#039;,
  &#039;.css&#039;: &#039;text/css; charset=utf-8&#039;,
  &#039;.json&#039;: &#039;application/json; charset=utf-8&#039;,
  &#039;.png&#039;: &#039;image/png&#039;,
  &#039;.jpg&#039;: &#039;image/jpeg&#039;,
  &#039;.svg&#039;: &#039;image/svg+xml&#039;,
  &#039;.ico&#039;: &#039;image/x-icon&#039;
};

// HTTP Server
const server = createServer(async (req, res) =&gt; {
  try {
    // Handle SPA routing - serve index.html for non-file routes
    let filePath = join(PUBLIC_DIR, req.url === &#039;/&#039; ? &#039;index.html&#039; : req.url);

    // Try to read the file
    let content;
    try {
      content = await readFile(filePath);
    } catch (err) {
      // If file not found and URL doesn&#039;t have extension, serve index.html
      if (!extname(req.url)) {
        filePath = join(PUBLIC_DIR, &#039;index.html&#039;);
        content = await readFile(filePath);
      } else {
        throw err;
      }
    }

    const ext = extname(filePath);
    const contentType = contentTypes[ext] || &#039;application/octet-stream&#039;;

    // Inject live reload script for HTML files
    if (ext === &#039;.html&#039;) {
      const liveReloadScript = `
        &lt;script&gt;
          (function() {
            const ws = new WebSocket(&#039;ws://localhost:${PORT}&#039;);
            ws.onmessage = (event) =&gt; {
              if (event.data === &#039;reload&#039;) {
                console.log(&#039;[Dev Server] Reloading...&#039;);
                location.reload();
              } else if (event.data.startsWith(&#039;hmr:&#039;)) {
                const module = event.data.substring(4);
                console.log(&#039;[Dev Server] Hot reload:&#039;, module);
                // Implement HMR logic here
              }
            };
            ws.onerror = () =&gt; console.error(&#039;[Dev Server] WebSocket error&#039;);
            ws.onclose = () =&gt; console.log(&#039;[Dev Server] Disconnected&#039;);
          })();
        &lt;/script&gt;
      `;
      content = Buffer.from(
        content.toString().replace(&#039;&lt;/body&gt;&#039;, `${liveReloadScript}&lt;/body&gt;`)
      );
    }

    res.writeHead(200, {
      &#039;Content-Type&#039;: contentType,
      &#039;Cache-Control&#039;: &#039;no-cache&#039;,
      &#039;Access-Control-Allow-Origin&#039;: &#039;*&#039;
    });
    res.end(content);
  } catch (err) {
    console.error(&#039;Server error:&#039;, err);
    res.writeHead(404, { &#039;Content-Type&#039;: &#039;text/html&#039; });
    res.end(`
      &lt;!DOCTYPE html&gt;
      &lt;html&gt;
        &lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;h1&gt;404 - Not Found&lt;/h1&gt;
          &lt;p&gt;${req.url}&lt;/p&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    `);
  }
});

// WebSocket for live reload
const wss = new WebSocketServer({ server });

wss.on(&#039;connection&#039;, (ws) =&gt; {
  console.log(&#039;Client connected&#039;);
  ws.on(&#039;close&#039;, () =&gt; console.log(&#039;Client disconnected&#039;));
});

// File watcher
watch(PUBLIC_DIR, { recursive: true }, (eventType, filename) =&gt; {
  if (filename) {
    console.log(`File changed: ${filename}`);

    // Notify all connected clients
    wss.clients.forEach(client =&gt; {
      if (client.readyState === 1) { // WebSocket.OPEN
        if (filename.endsWith(&#039;.js&#039;) || filename.endsWith(&#039;.mjs&#039;)) {
          client.send(`hmr:${filename}`);
        } else {
          client.send(&#039;reload&#039;);
        }
      }
    });
  }
});

server.listen(PORT, () =&gt; {
  console.log(`
🚀 Dev server running at http://localhost:${PORT}
📁 Serving: ${PUBLIC_DIR}
🔥 Live reload enabled
  `);
});</code></pre>
<h2>Advanced VS Code Configuration</h2>
<strong>Complete settings.json:</strong>
<pre><code class="language-json">{
  &quot;editor.formatOnSave&quot;: true,
  &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,
  &quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll.eslint&quot;: &quot;explicit&quot;
  },
  &quot;editor.quickSuggestions&quot;: {
    &quot;strings&quot;: true
  },
  &quot;emmet.includeLanguages&quot;: {
    &quot;javascript&quot;: &quot;html&quot;
  },
  &quot;files.associations&quot;: {
    &quot;*.mjs&quot;: &quot;javascript&quot;
  },
  &quot;files.exclude&quot;: {
    &quot;**/.git&quot;: true,
    &quot;**/node_modules&quot;: true,
    &quot;**/.DS_Store&quot;: true
  },
  &quot;search.exclude&quot;: {
    &quot;**/node_modules&quot;: true,
    &quot;**/dist&quot;: true,
    &quot;**/.git&quot;: true
  },
  &quot;javascript.preferences.quoteStyle&quot;: &quot;single&quot;,
  &quot;javascript.suggest.autoImports&quot;: true,
  &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,
  &quot;css.lint.unknownAtRules&quot;: &quot;ignore&quot;
}</code></pre>
<strong>Recommended extensions:</strong>
<pre><code class="language-json">// .vscode/extensions.json
{
  &quot;recommendations&quot;: [
    &quot;dbaeumer.vscode-eslint&quot;,
    &quot;esbenp.prettier-vscode&quot;,
    &quot;bradlc.vscode-tailwindcss&quot;,
    &quot;ritwickdey.liveserver&quot;,
    &quot;christian-kohler.path-intellisense&quot;,
    &quot;zignd.html-css-class-completion&quot;,
    &quot;formulahendry.auto-rename-tag&quot;
  ]
}</code></pre>
<strong>Custom snippets:</strong>
<pre><code class="language-json">// .vscode/snippets/larc.code-snippets
{
  &quot;LARC Component with Shadow DOM&quot;: {
    &quot;prefix&quot;: &quot;larc-component&quot;,
    &quot;body&quot;: [
      &quot;/**&quot;,
      &quot; * ${1:ComponentName} - ${2:Component description}&quot;,
      &quot; * @element ${3:component-name}&quot;,
      &quot; */&quot;,
      &quot;class ${1:ComponentName} extends HTMLElement {&quot;,
      &quot;  constructor() {&quot;,
      &quot;    super();&quot;,
      &quot;    this.attachShadow({ mode: &#039;open&#039; });&quot;,
      &quot;  }&quot;,
      &quot;&quot;,
      &quot;  connectedCallback() {&quot;,
      &quot;    this.render();&quot;,
      &quot;  }&quot;,
      &quot;&quot;,
      &quot;  disconnectedCallback() {&quot;,
      &quot;    // Clean up&quot;,
      &quot;  }&quot;,
      &quot;&quot;,
      &quot;  render() {&quot;,
      &quot;    this.shadowRoot.innerHTML = `&quot;,
      &quot;      &lt;style&gt;&quot;,
      &quot;        :host {&quot;,
      &quot;          display: block;&quot;,
      &quot;        }&quot;,
      &quot;      &lt;/style&gt;&quot;,
      &quot;      &lt;div class=\&quot;${3:component-name}\&quot;&gt;&quot;,
      &quot;        $4&quot;,
      &quot;      &lt;/div&gt;&quot;,
      &quot;    `;&quot;,
      &quot;  }&quot;,
      &quot;}&quot;,
      &quot;&quot;,
      &quot;customElements.define(&#039;${3:component-name}&#039;, ${1:ComponentName});&quot;
    ],
    &quot;description&quot;: &quot;Create a LARC component with Shadow DOM&quot;
  },
  &quot;PAN Subscribe&quot;: {
    &quot;prefix&quot;: &quot;pan-sub&quot;,
    &quot;body&quot;: [
      &quot;this.subscription = pan.subscribe(&#039;${1:topic}&#039;, (data) =&gt; {&quot;,
      &quot;  $2&quot;,
      &quot;});&quot;
    ],
    &quot;description&quot;: &quot;Subscribe to PAN topic&quot;
  },
  &quot;PAN Publish&quot;: {
    &quot;prefix&quot;: &quot;pan-pub&quot;,
    &quot;body&quot;: [
      &quot;pan.publish(&#039;${1:topic}&#039;, {&quot;,
      &quot;  $2&quot;,
      &quot;});&quot;
    ],
    &quot;description&quot;: &quot;Publish to PAN topic&quot;
  }
}</code></pre>
<h2>ESLint and Prettier Configuration</h2>
<strong>Complete ESLint config:</strong>
<pre><code class="language-javascript">// eslint.config.js
export default [
  {
    files: [&#039;**/*.{js,mjs}&#039;],
    languageOptions: {
      ecmaVersion: 2022,
      sourceType: &#039;module&#039;,
      globals: {
        window: &#039;readonly&#039;,
        document: &#039;readonly&#039;,
        customElements: &#039;readonly&#039;,
        HTMLElement: &#039;readonly&#039;,
        console: &#039;readonly&#039;,
        fetch: &#039;readonly&#039;,
        localStorage: &#039;readonly&#039;,
        sessionStorage: &#039;readonly&#039;,
        navigator: &#039;readonly&#039;,
        URL: &#039;readonly&#039;,
        URLSearchParams: &#039;readonly&#039;
      }
    },
    rules: {
      // Best practices
      &#039;no-unused-vars&#039;: [&#039;warn&#039;, { argsIgnorePattern: &#039;^_&#039; }],
      &#039;no-console&#039;: [&#039;warn&#039;, { allow: [&#039;warn&#039;, &#039;error&#039;, &#039;info&#039;] }],
      &#039;prefer-const&#039;: &#039;error&#039;,
      &#039;no-var&#039;: &#039;error&#039;,
      &#039;eqeqeq&#039;: [&#039;error&#039;, &#039;always&#039;],
      &#039;no-eval&#039;: &#039;error&#039;,
      &#039;no-implied-eval&#039;: &#039;error&#039;,

      // Formatting (let Prettier handle most)
      &#039;semi&#039;: [&#039;error&#039;, &#039;always&#039;],
      &#039;quotes&#039;: [&#039;error&#039;, &#039;single&#039;, { avoidEscape: true }],
      &#039;comma-dangle&#039;: [&#039;error&#039;, &#039;never&#039;],

      // ES6+
      &#039;arrow-spacing&#039;: &#039;error&#039;,
      &#039;prefer-arrow-callback&#039;: &#039;warn&#039;,
      &#039;prefer-template&#039;: &#039;warn&#039;,
      &#039;template-curly-spacing&#039;: &#039;error&#039;,
      &#039;object-shorthand&#039;: &#039;warn&#039;,

      // Async
      &#039;no-async-promise-executor&#039;: &#039;error&#039;,
      &#039;require-await&#039;: &#039;warn&#039;,

      // Custom Elements
      &#039;no-constructor-return&#039;: &#039;error&#039;
    }
  },
  {
    files: [&#039;**/*.test.{js,mjs}&#039;],
    languageOptions: {
      globals: {
        describe: &#039;readonly&#039;,
        it: &#039;readonly&#039;,
        expect: &#039;readonly&#039;,
        beforeEach: &#039;readonly&#039;,
        afterEach: &#039;readonly&#039;
      }
    }
  }
];</code></pre>
<strong>Prettier configuration:</strong>
<pre><code class="language-json">// .prettierrc
{
  &quot;semi&quot;: true,
  &quot;singleQuote&quot;: true,
  &quot;trailingComma&quot;: &quot;none&quot;,
  &quot;printWidth&quot;: 100,
  &quot;tabWidth&quot;: 2,
  &quot;useTabs&quot;: false,
  &quot;arrowParens&quot;: &quot;avoid&quot;,
  &quot;endOfLine&quot;: &quot;lf&quot;
}</code></pre>
<strong>Ignore files:</strong>
<pre><code class="language-plaintext"># .prettierignore
node_modules
dist
build
coverage
*.min.js
package-lock.json</code></pre>
<h2>Advanced Debugging Techniques</h2>
<strong>1. Source maps for debugging:</strong>
<p>Although LARC doesn't need transpilation, you can still use source maps for development:</p>
<pre><code class="language-javascript">// Add inline source maps during development
if (import.meta.env?.MODE === &#039;development&#039;) {
  Error.stackTraceLimit = Infinity;
}</code></pre>
<strong>2. Component debugger:</strong>
<pre><code class="language-javascript">// debug-component.js
export function debugComponent(ComponentClass) {
  const originalConnected = ComponentClass.prototype.connectedCallback;
  const originalDisconnected = ComponentClass.prototype.disconnectedCallback;
  const originalAttributeChanged = ComponentClass.prototype.attributeChangedCallback;

  ComponentClass.prototype.connectedCallback = function(...args) {
    console.log(`[Connected] &lt;${this.tagName.toLowerCase()}&gt;`, this);
    return originalConnected?.apply(this, args);
  };

  ComponentClass.prototype.disconnectedCallback = function(...args) {
    console.log(`[Disconnected] &lt;${this.tagName.toLowerCase()}&gt;`, this);
    return originalDisconnected?.apply(this, args);
  };

  ComponentClass.prototype.attributeChangedCallback = function(name, old, val) {
    console.log(`[Attribute] &lt;${this.tagName.toLowerCase()}&gt; ${name}: ${old} → ${val}`);
    return originalAttributeChanged?.call(this, name, old, val);
  };

  return ComponentClass;
}

// Usage
@debugComponent
class MyComponent extends HTMLElement {
  // ...
}</code></pre>
<strong>3. Performance profiling:</strong>
<pre><code class="language-javascript">// performance-tracker.js
class PerformanceTracker {
  constructor(name) {
    this.name = name;
    this.marks = new Map();
  }

  start(label) {
    const markName = `${this.name}:${label}:start`;
    performance.mark(markName);
    this.marks.set(label, markName);
  }

  end(label) {
    const startMark = this.marks.get(label);
    if (!startMark) {
      console.warn(`No start mark for ${label}`);
      return;
    }

    const endMark = `${this.name}:${label}:end`;
    performance.mark(endMark);

    const measureName = `${this.name}:${label}`;
    performance.measure(measureName, startMark, endMark);

    const measure = performance.getEntriesByName(measureName)[0];
    console.log(`⏱ ${measureName}: ${measure.duration.toFixed(2)}ms`);

    // Clean up
    performance.clearMarks(startMark);
    performance.clearMarks(endMark);
    performance.clearMeasures(measureName);
    this.marks.delete(label);
  }
}

// Usage in component
class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.perf = new PerformanceTracker(&#039;MyComponent&#039;);
  }

  connectedCallback() {
    this.perf.start(&#039;render&#039;);
    this.render();
    this.perf.end(&#039;render&#039;);
  }
}</code></pre>
<strong>4. Network debugging:</strong>
<pre><code class="language-javascript">// network-debugger.js
const originalFetch = window.fetch;

window.fetch = function(...args) {
  const startTime = performance.now();
  const [url, options] = args;

  console.log(`[Fetch] →`, {
    url,
    method: options?.method || &#039;GET&#039;,
    headers: options?.headers,
    body: options?.body
  });

  return originalFetch.apply(this, args)
    .then(response =&gt; {
      const duration = performance.now() - startTime;
      console.log(`[Fetch] ← ${response.status} (${duration.toFixed(0)}ms)`, url);
      return response;
    })
    .catch(error =&gt; {
      const duration = performance.now() - startTime;
      console.error(`[Fetch] ✗ (${duration.toFixed(0)}ms)`, url, error);
      throw error;
    });
};</code></pre>
<h2>PAN Bus DevTools</h2>
<p>Build a visual inspector for PAN messages:</p>
<pre><code class="language-javascript">// pan-devtools.js
class PanDevTools extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.messages = [];
    this.maxMessages = 100;
    this.filter = &#039;&#039;;
  }

  connectedCallback() {
    this.render();
    this.setupPanMonitoring();
  }

  setupPanMonitoring() {
    // Subscribe to all topics
    pan.subscribe(&#039;*&#039;, (data, topic) =&gt; {
      this.logMessage({
        timestamp: new Date(),
        topic,
        data,
        type: &#039;received&#039;
      });
    });

    // Intercept publishes (if PAN client supports it)
    const originalPublish = pan.publish;
    pan.publish = (topic, data) =&gt; {
      this.logMessage({
        timestamp: new Date(),
        topic,
        data,
        type: &#039;sent&#039;
      });
      return originalPublish.call(pan, topic, data);
    };
  }

  logMessage(message) {
    this.messages.unshift(message);
    if (this.messages.length &gt; this.maxMessages) {
      this.messages.pop();
    }
    this.renderMessages();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        :host {
          position: fixed;
          bottom: 0;
          right: 0;
          width: 400px;
          max-height: 600px;
          background: #1e1e1e;
          color: #d4d4d4;
          font-family: &#039;Monaco&#039;, &#039;Courier New&#039;, monospace;
          font-size: 12px;
          box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
          display: flex;
          flex-direction: column;
          z-index: 10000;
        }

        .header {
          padding: 8px;
          background: #252526;
          border-bottom: 1px solid #3e3e42;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }

        .title {
          font-weight: bold;
          color: #4ec9b0;
        }

        .controls {
          display: flex;
          gap: 8px;
        }

        button {
          background: #3e3e42;
          border: none;
          color: #d4d4d4;
          padding: 4px 8px;
          border-radius: 3px;
          cursor: pointer;
          font-size: 11px;
        }

        button:hover {
          background: #4e4e52;
        }

        .filter {
          padding: 8px;
          border-bottom: 1px solid #3e3e42;
        }

        input {
          width: 100%;
          padding: 4px 8px;
          background: #3c3c3c;
          border: 1px solid #3e3e42;
          color: #d4d4d4;
          border-radius: 3px;
          font-size: 11px;
        }

        .messages {
          flex: 1;
          overflow-y: auto;
          padding: 8px;
        }

        .message {
          margin-bottom: 8px;
          padding: 8px;
          background: #252526;
          border-left: 3px solid #4ec9b0;
          border-radius: 3px;
        }

        .message.sent {
          border-left-color: #569cd6;
        }

        .message-header {
          display: flex;
          justify-content: space-between;
          margin-bottom: 4px;
        }

        .topic {
          color: #4ec9b0;
          font-weight: bold;
        }

        .timestamp {
          color: #858585;
          font-size: 10px;
        }

        .data {
          color: #ce9178;
          white-space: pre-wrap;
          word-break: break-all;
        }

        .type {
          display: inline-block;
          padding: 2px 6px;
          border-radius: 3px;
          font-size: 10px;
          margin-left: 8px;
        }

        .type.sent {
          background: #569cd6;
        }

        .type.received {
          background: #4ec9b0;
        }
      &lt;/style&gt;

      &lt;div class=&quot;header&quot;&gt;
        &lt;span class=&quot;title&quot;&gt;PAN DevTools&lt;/span&gt;
        &lt;div class=&quot;controls&quot;&gt;
          &lt;button id=&quot;clear-btn&quot;&gt;Clear&lt;/button&gt;
          &lt;button id=&quot;close-btn&quot;&gt;Close&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;filter&quot;&gt;
        &lt;input type=&quot;text&quot; id=&quot;filter-input&quot; placeholder=&quot;Filter by topic...&quot;&gt;
      &lt;/div&gt;

      &lt;div class=&quot;messages&quot; id=&quot;messages&quot;&gt;&lt;/div&gt;
    `;

    // Setup event listeners
    this.shadowRoot.getElementById(&#039;clear-btn&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.messages = [];
      this.renderMessages();
    });

    this.shadowRoot.getElementById(&#039;close-btn&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.remove();
    });

    this.shadowRoot.getElementById(&#039;filter-input&#039;).addEventListener(&#039;input&#039;, (e) =&gt; {
      this.filter = e.target.value.toLowerCase();
      this.renderMessages();
    });
  }

  renderMessages() {
    const messagesEl = this.shadowRoot.getElementById(&#039;messages&#039;);
    if (!messagesEl) return;

    const filtered = this.filter
      ? this.messages.filter(m =&gt; m.topic.toLowerCase().includes(this.filter))
      : this.messages;

    messagesEl.innerHTML = filtered.map(msg =&gt; `
      &lt;div class=&quot;message ${msg.type}&quot;&gt;
        &lt;div class=&quot;message-header&quot;&gt;
          &lt;span class=&quot;topic&quot;&gt;${msg.topic}&lt;/span&gt;
          &lt;span class=&quot;timestamp&quot;&gt;${msg.timestamp.toLocaleTimeString()}.${msg.timestamp.getMilliseconds()}&lt;/span&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;span class=&quot;type ${msg.type}&quot;&gt;${msg.type}&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;data&quot;&gt;${JSON.stringify(msg.data, null, 2)}&lt;/div&gt;
      &lt;/div&gt;
    `).join(&#039;&#039;);
  }
}

customElements.define(&#039;pan-devtools&#039;, PanDevTools);

// Add to page with keyboard shortcut
document.addEventListener(&#039;keydown&#039;, (e) =&gt; {
  if (e.ctrlKey &amp;&amp; e.shiftKey &amp;&amp; e.key === &#039;P&#039;) {
    if (!document.querySelector(&#039;pan-devtools&#039;)) {
      document.body.appendChild(document.createElement(&#039;pan-devtools&#039;));
    }
  }
});</code></pre>
<h2>Optional Build Tools</h2>
<p>While LARC doesn't need a build step, sometimes you want to bundle for production:</p>
<strong>Using esbuild for optimization:</strong>
<pre><code class="language-javascript">// build.js
import * as esbuild from &#039;esbuild&#039;;

await esbuild.build({
  entryPoints: [&#039;public/app.js&#039;],
  bundle: true,
  minify: true,
  sourcemap: true,
  target: [&#039;es2020&#039;],
  outfile: &#039;dist/app.min.js&#039;,
  format: &#039;esm&#039;,
  splitting: false,
  treeShaking: true
});

console.log(&#039;✅ Build complete&#039;);</code></pre>
<strong>Using Rollup:</strong>
<pre><code class="language-javascript">// rollup.config.js
import { terser } from &#039;rollup-plugin-terser&#039;;
import resolve from &#039;@rollup/plugin-node-resolve&#039;;

export default {
  input: &#039;public/app.js&#039;,
  output: {
    file: &#039;dist/app.min.js&#039;,
    format: &#039;esm&#039;,
    sourcemap: true
  },
  plugins: [
    resolve(),
    terser()
  ]
};</code></pre>
<h2>Troubleshooting Tooling Issues</h2>
<h3>Problem 1: Live Reload Not Working</h3>
<strong>Symptoms</strong>: Changes aren't reflected after saving files.
<strong>Diagnosis</strong>:
<pre><code class="language-bash"># Check if dev server is running
ps aux | grep node

# Check WebSocket connection in browser console
# Should see WebSocket connected message</code></pre>
<strong>Solution</strong>:
<pre><code class="language-javascript">// Ensure WebSocket script is injected
// Check browser console for WebSocket errors
// Verify port 3000 is not blocked by firewall

// Alternative: Use browser extension like LiveReload</code></pre>
<h3>Problem 2: ESLint Errors in VS Code</h3>
<strong>Symptoms</strong>: Red squiggly lines everywhere, but code works fine.
<strong>Cause</strong>: ESLint configuration mismatch.
<strong>Solution</strong>:
<pre><code class="language-bash"># Reinstall ESLint
npm install --save-dev eslint

# Restart VS Code ESLint server
# Cmd+Shift+P → &quot;ESLint: Restart ESLint Server&quot;

# Check ESLint output panel
# View → Output → Select &quot;ESLint&quot; from dropdown</code></pre>
<h3>Problem 3: Import Paths Not Resolving</h3>
<strong>Symptoms</strong>: VS Code shows import errors, but browser loads fine.
<strong>Cause</strong>: VS Code doesn't understand import maps.
<strong>Solution</strong>:
<pre><code class="language-json">// jsconfig.json - Help VS Code understand paths
{
  &quot;compilerOptions&quot;: {
    &quot;module&quot;: &quot;esnext&quot;,
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;baseUrl&quot;: &quot;./public&quot;,
    &quot;paths&quot;: {
      &quot;@components/*&quot;: [&quot;components/*&quot;],
      &quot;@utils/*&quot;: [&quot;utils/*&quot;]
    }
  },
  &quot;include&quot;: [&quot;public/**/*&quot;],
  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;]
}</code></pre>
<h3>Problem 4: Shadow DOM Not Visible in DevTools</h3>
<strong>Symptoms</strong>: Can't inspect Shadow DOM elements.
<strong>Cause</strong>: Shadow DOM panel not enabled.
<strong>Solution</strong>:
<li>Open Chrome DevTools</li>
<li>Go to Settings (gear icon)</li>
<li>Preferences → Elements → Enable "Show user agent shadow DOM"</li>
<li>Now you can see <code>#shadow-root</code> in Elements panel</li>
<h2>Tooling Best Practices</h2>
<li><strong>Use a Dev Server</strong>: Never open HTML files directly—use a local server for proper CORS and module loading.</li>
<li><strong>Enable Live Reload</strong>: Instant feedback speeds up development significantly.</li>
<li><strong>Configure Your Editor</strong>: Proper linting, formatting, and snippets save hours of work.</li>
<li><strong>Debug with DevTools</strong>: Master the Elements, Console, Network, and Performance panels.</li>
<li><strong>Monitor PAN Messages</strong>: Use a visual inspector to understand message flow.</li>
<li><strong>Profile Performance</strong>: Use Performance API and DevTools to find bottlenecks.</li>
<li><strong>Automate Formatting</strong>: Let Prettier handle code style—focus on logic.</li>
<li><strong>Test Continuously</strong>: Run tests in watch mode during development.</li>
<li><strong>Document As You Go</strong>: JSDoc comments help VS Code provide better autocomplete.</li>
<li><strong>Keep It Simple</strong>: Don't over-tool. Start minimal and add tools as needed.</li>
<h2>Hands-On Exercises</h2>
<h3>Exercise 1: Set Up Complete Dev Environment</h3>
<p>Configure a full development environment with:</p>
<ul><li>Dev server with live reload</li>
<li>VS Code with all recommended extensions</li>
<li>ESLint and Prettier configured</li>
<li>Custom snippets for LARC components</li>
<li>Git hooks for pre-commit linting</li>
</ul>
<strong>Bonus</strong>: Add automated testing on file save.
<h3>Exercise 2: Build a PAN Message Inspector</h3>
<p>Create a browser extension or dev panel that:</p>
<ul><li>Shows all PAN messages in real-time</li>
<li>Filters messages by topic pattern</li>
<li>Records and exports message history</li>
<li>Shows message timing and frequency</li>
<li>Highlights retained vs. transient messages</li>
</ul>
<strong>Bonus</strong>: Add ability to publish test messages.
<h3>Exercise 3: Create Custom VS Code Extension</h3>
<p>Build a VS Code extension that:</p>
<ul><li>Generates LARC component boilerplate</li>
<li>Validates component structure</li>
<li>Provides autocomplete for PAN topics</li>
<li>Shows component documentation on hover</li>
<li>Refactors component names across files</li>
</ul>
<strong>Bonus</strong>: Publish to VS Code marketplace.
<h3>Exercise 4: Implement Advanced Debugging</h3>
<p>Set up comprehensive debugging tools:</p>
<ul><li>Component lifecycle logger</li>
<li>Performance profiler for renders</li>
<li>Network request interceptor</li>
<li>Error boundary with stack traces</li>
<li>State inspector for component properties</li>
</ul>
<strong>Bonus</strong>: Create a dashboard showing all metrics.
<h2>Summary</h2>
<p>Good tooling makes LARC development faster and more enjoyable:</p>
<ul><li><strong>Dev server</strong>: Live reload and hot module replacement</li>
<li><strong>Editor setup</strong>: VS Code configuration, extensions, snippets</li>
<li><strong>Linting</strong>: ESLint for code quality, Prettier for formatting</li>
<li><strong>Debugging</strong>: DevTools mastery, PAN inspector, performance tracking</li>
<li><strong>Automation</strong>: npm scripts, git hooks, CI integration</li>
</ul>
Start simple and add tools as your project grows. The beauty of LARC is you can be productive with just a text editor and a browser—everything else is optional.
<h2>Further Reading</h2>
<ul><li><strong>Building with LARC - Chapter 20 (DevTools)</strong>: Advanced debugging techniques</li>
<li><strong>Building with LARC - Chapter 11 (Best Practices)</strong>: Development workflow patterns</li>
<li><strong>Building with LARC - Chapter 14 (Testing)</strong>: Testing infrastructure setup</li>
</ul>
<div class="pagebreak"></div>
<h1>Real-World Applications</h1>
<p>Theory only takes you so far. Let's examine how LARC principles apply to real applications.</p>
<h2>Case Study: E-Commerce Platform</h2>
<p>An online store built with LARC demonstrates the architecture at scale.</p>
<h3>Architecture Overview</h3>
<pre><code class="language-plaintext">store/
├── index.html
├── components/
│   ├── product-card.js
│   ├── product-grid.js
│   ├── shopping-cart.js
│   ├── cart-item.js
│   ├── checkout-form.js
│   └── order-confirmation.js
├── services/
│   ├── cart-service.js
│   ├── product-service.js
│   └── order-service.js
└── styles/
    └── main.css</code></pre>
<h3>Product Catalog</h3>
<p>The product grid loads data and renders cards:</p>
<pre><code class="language-javascript">// product-grid.js
class ProductGrid extends HTMLElement {
  async connectedCallback() {
    this.innerHTML = &#039;&lt;p&gt;Loading products...&lt;/p&gt;&#039;;

    try {
      const products = await productService.getAll();
      this.render(products);
    } catch (error) {
      this.innerHTML = `&lt;p class=&quot;error&quot;&gt;Failed to load products&lt;/p&gt;`;
    }
  }

  render(products) {
    this.innerHTML = `
      &lt;div class=&quot;grid&quot;&gt;
        ${products.map(p =&gt; `
          &lt;product-card
            product-id=&quot;${p.id}&quot;
            name=&quot;${p.name}&quot;
            price=&quot;${p.price}&quot;
            image=&quot;${p.image}&quot;&gt;
          &lt;/product-card&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h3>Shopping Cart</h3>
<p>The cart subscribes to add-to-cart events and persists state:</p>
<pre><code class="language-javascript">// shopping-cart.js
class ShoppingCart extends HTMLElement {
  constructor() {
    super();
    this.items = JSON.parse(localStorage.getItem(&#039;cart&#039;)) || [];
  }

  connectedCallback() {
    pan.subscribe(&#039;cart.add&#039;, ({ product }) =&gt; {
      this.addItem(product);
    });

    pan.subscribe(&#039;cart.remove&#039;, ({ productId }) =&gt; {
      this.removeItem(productId);
    });

    this.render();
  }

  addItem(product) {
    const existing = this.items.find(i =&gt; i.id === product.id);
    if (existing) {
      existing.quantity++;
    } else {
      this.items.push({ ...product, quantity: 1 });
    }
    this.save();
    this.render();
  }

  removeItem(productId) {
    this.items = this.items.filter(i =&gt; i.id !== productId);
    this.save();
    this.render();
  }

  save() {
    localStorage.setItem(&#039;cart&#039;, JSON.stringify(this.items));
    pan.publish(&#039;cart.updated&#039;, { items: this.items, total: this.total });
  }

  get total() {
    return this.items.reduce((sum, i) =&gt; sum + i.price * i.quantity, 0);
  }

  render() {
    this.innerHTML = `
      &lt;h2&gt;Cart (${this.items.length} items)&lt;/h2&gt;
      ${this.items.map(item =&gt; `
        &lt;cart-item
          product-id=&quot;${item.id}&quot;
          name=&quot;${item.name}&quot;
          price=&quot;${item.price}&quot;
          quantity=&quot;${item.quantity}&quot;&gt;
        &lt;/cart-item&gt;
      `).join(&#039;&#039;)}
      &lt;p class=&quot;total&quot;&gt;Total: $${this.total.toFixed(2)}&lt;/p&gt;
      &lt;button class=&quot;checkout-btn&quot;&gt;Checkout&lt;/button&gt;
    `;
  }
}</code></pre>
<h2>Case Study: Dashboard Application</h2>
<p>A data dashboard shows real-time metrics with role-based access.</p>
<h3>Real-Time Updates</h3>
<p>WebSocket messages update charts automatically:</p>
<pre><code class="language-javascript">// metrics-chart.js
class MetricsChart extends HTMLElement {
  connectedCallback() {
    this.data = [];

    pan.subscribe(&#039;ws.message.metrics&#039;, ({ value, timestamp }) =&gt; {
      this.data.push({ value, timestamp });
      if (this.data.length &gt; 100) this.data.shift();
      this.render();
    });

    this.render();
  }

  render() {
    // Render chart using canvas or SVG
    const canvas = this.querySelector(&#039;canvas&#039;) || document.createElement(&#039;canvas&#039;);
    if (!this.contains(canvas)) this.appendChild(canvas);

    const ctx = canvas.getContext(&#039;2d&#039;);
    // ... draw chart
  }
}</code></pre>
<h3>Role-Based Views</h3>
<p>Different users see different widgets:</p>
<pre><code class="language-javascript">// dashboard-page.js
class DashboardPage extends HTMLElement {
  connectedCallback() {
    const user = auth.getCurrentUser();

    this.innerHTML = `
      &lt;h1&gt;Dashboard&lt;/h1&gt;

      &lt;div class=&quot;widgets&quot;&gt;
        &lt;metrics-chart&gt;&lt;/metrics-chart&gt;
        &lt;recent-activity&gt;&lt;/recent-activity&gt;

        ${rbac.can(user, &#039;view-analytics&#039;) ? `
          &lt;analytics-panel&gt;&lt;/analytics-panel&gt;
        ` : &#039;&#039;}

        ${rbac.can(user, &#039;manage-users&#039;) ? `
          &lt;user-management&gt;&lt;/user-management&gt;
        ` : &#039;&#039;}
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h2>Lessons Learned</h2>
<p>Building real applications with LARC teaches valuable lessons:</p>
<li><strong>Start simple</strong>: Begin with basic components and add complexity as needed.</li>
<li><strong>Use the PAN bus liberally</strong>: It's cheap and powerful. When in doubt, publish an event.</li>
<li><strong>Embrace the platform</strong>: Native APIs are well-optimized. Use fetch, not axios. Use template literals, not a template library.</li>
<li><strong>Think in components</strong>: Small, focused components are easier to test, reuse, and understand.</li>
<li><strong>Test early</strong>: Writing tests as you build prevents painful debugging later.</li>
<li><strong>Profile before optimizing</strong>: Measure performance before assuming where bottlenecks are.</li>
<li><strong>Document as you go</strong>: Future you will thank present you.</li>
<li><strong>Progressive enhancement</strong>: Build core functionality first, then enhance for modern browsers.</li>
<h3>Complete Checkout Flow</h3>
<p>Let's implement the full checkout process:</p>
<pre><code class="language-javascript">// checkout-form.js
class CheckoutForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
  }

  connectedCallback() {
    this.render();
    this.setupEventListeners();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        form {
          max-width: 600px;
          margin: 0 auto;
        }

        .section {
          margin-bottom: 2rem;
          padding: 1.5rem;
          border: 1px solid #e0e0e0;
          border-radius: 8px;
        }

        .field {
          margin-bottom: 1rem;
        }

        label {
          display: block;
          margin-bottom: 0.5rem;
          font-weight: 600;
        }

        input, select {
          width: 100%;
          padding: 0.5rem;
          border: 1px solid #ccc;
          border-radius: 4px;
        }

        .error {
          color: #dc3545;
          font-size: 0.875rem;
          margin-top: 0.25rem;
        }

        button {
          width: 100%;
          padding: 1rem;
          background: #0066cc;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 1rem;
          cursor: pointer;
        }

        button:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
      &lt;/style&gt;

      &lt;form id=&quot;checkout-form&quot;&gt;
        &lt;div class=&quot;section&quot;&gt;
          &lt;h2&gt;Shipping Information&lt;/h2&gt;
          &lt;div class=&quot;field&quot;&gt;
            &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;
            &lt;input type=&quot;email&quot; id=&quot;email&quot; required&gt;
            &lt;div class=&quot;error&quot; id=&quot;email-error&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;field&quot;&gt;
            &lt;label for=&quot;name&quot;&gt;Full Name&lt;/label&gt;
            &lt;input type=&quot;text&quot; id=&quot;name&quot; required&gt;
          &lt;/div&gt;
          &lt;div class=&quot;field&quot;&gt;
            &lt;label for=&quot;address&quot;&gt;Address&lt;/label&gt;
            &lt;input type=&quot;text&quot; id=&quot;address&quot; required&gt;
          &lt;/div&gt;
          &lt;div class=&quot;field&quot;&gt;
            &lt;label for=&quot;city&quot;&gt;City&lt;/label&gt;
            &lt;input type=&quot;text&quot; id=&quot;city&quot; required&gt;
          &lt;/div&gt;
          &lt;div class=&quot;field&quot;&gt;
            &lt;label for=&quot;zip&quot;&gt;ZIP Code&lt;/label&gt;
            &lt;input type=&quot;text&quot; id=&quot;zip&quot; pattern=&quot;[0-9]{5}&quot; required&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;section&quot;&gt;
          &lt;h2&gt;Payment Information&lt;/h2&gt;
          &lt;div class=&quot;field&quot;&gt;
            &lt;label for=&quot;card-number&quot;&gt;Card Number&lt;/label&gt;
            &lt;input type=&quot;text&quot; id=&quot;card-number&quot; pattern=&quot;[0-9]{16}&quot; required&gt;
          &lt;/div&gt;
          &lt;div class=&quot;field&quot;&gt;
            &lt;label for=&quot;expiry&quot;&gt;Expiry Date&lt;/label&gt;
            &lt;input type=&quot;text&quot; id=&quot;expiry&quot; placeholder=&quot;MM/YY&quot; required&gt;
          &lt;/div&gt;
          &lt;div class=&quot;field&quot;&gt;
            &lt;label for=&quot;cvv&quot;&gt;CVV&lt;/label&gt;
            &lt;input type=&quot;text&quot; id=&quot;cvv&quot; pattern=&quot;[0-9]{3}&quot; required&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;button type=&quot;submit&quot; id=&quot;submit-btn&quot;&gt;Place Order&lt;/button&gt;
      &lt;/form&gt;
    `;
  }

  setupEventListeners() {
    const form = this.shadowRoot.getElementById(&#039;checkout-form&#039;);
    const submitBtn = this.shadowRoot.getElementById(&#039;submit-btn&#039;);

    form.addEventListener(&#039;submit&#039;, async (e) =&gt; {
      e.preventDefault();

      if (!this.validate()) {
        return;
      }

      submitBtn.disabled = true;
      submitBtn.textContent = &#039;Processing...&#039;;

      try {
        const order = this.getFormData();
        const result = await orderService.submit(order);

        pan.publish(&#039;order.completed&#039;, { orderId: result.id });
        pan.publish(&#039;router.navigate&#039;, { path: `/order-confirmation/${result.id}` });
      } catch (error) {
        alert(&#039;Order failed: &#039; + error.message);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = &#039;Place Order&#039;;
      }
    });
  }

  validate() {
    // Implement validation logic
    return true;
  }

  getFormData() {
    const form = this.shadowRoot.getElementById(&#039;checkout-form&#039;);
    return {
      email: form.email.value,
      name: form.name.value,
      address: form.address.value,
      city: form.city.value,
      zip: form.zip.value,
      payment: {
        cardNumber: form[&#039;card-number&#039;].value,
        expiry: form.expiry.value,
        cvv: form.cvv.value
      }
    };
  }
}

customElements.define(&#039;checkout-form&#039;, CheckoutForm);</code></pre>
<h3>Inventory Management</h3>
<p>Admin panel for managing products:</p>
<pre><code class="language-javascript">// admin-inventory.js
class AdminInventory extends HTMLElement {
  async connectedCallback() {
    this.products = await productService.getAll();
    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;admin-panel&quot;&gt;
        &lt;h1&gt;Inventory Management&lt;/h1&gt;
        &lt;button class=&quot;add-product-btn&quot;&gt;Add New Product&lt;/button&gt;

        &lt;table class=&quot;inventory-table&quot;&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;ID&lt;/th&gt;
              &lt;th&gt;Name&lt;/th&gt;
              &lt;th&gt;Price&lt;/th&gt;
              &lt;th&gt;Stock&lt;/th&gt;
              &lt;th&gt;Status&lt;/th&gt;
              &lt;th&gt;Actions&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            ${this.products.map(p =&gt; `
              &lt;tr&gt;
                &lt;td&gt;${p.id}&lt;/td&gt;
                &lt;td&gt;${p.name}&lt;/td&gt;
                &lt;td&gt;$${p.price}&lt;/td&gt;
                &lt;td&gt;${p.stock}&lt;/td&gt;
                &lt;td&gt;
                  &lt;span class=&quot;badge ${p.stock &gt; 0 ? &#039;in-stock&#039; : &#039;out-of-stock&#039;}&quot;&gt;
                    ${p.stock &gt; 0 ? &#039;In Stock&#039; : &#039;Out of Stock&#039;}
                  &lt;/span&gt;
                &lt;/td&gt;
                &lt;td&gt;
                  &lt;button onclick=&quot;this.getRootNode().host.editProduct(${p.id})&quot;&gt;
                    Edit
                  &lt;/button&gt;
                  &lt;button onclick=&quot;this.getRootNode().host.deleteProduct(${p.id})&quot;&gt;
                    Delete
                  &lt;/button&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
            `).join(&#039;&#039;)}
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/div&gt;
    `;
  }

  async editProduct(id) {
    const product = this.products.find(p =&gt; p.id === id);
    // Show edit dialog
    pan.publish(&#039;dialog.open&#039;, {
      component: &#039;product-edit-form&#039;,
      data: product
    });
  }

  async deleteProduct(id) {
    if (!confirm(&#039;Are you sure?&#039;)) return;

    await productService.delete(id);
    this.products = this.products.filter(p =&gt; p.id !== id);
    this.render();
  }
}

customElements.define(&#039;admin-inventory&#039;, AdminInventory);</code></pre>
<h2>Case Study: Blog/CMS Application</h2>
<p>A content management system demonstrates LARC's flexibility for content-heavy applications.</p>
<h3>Architecture</h3>
<pre><code class="language-plaintext">blog/
├── index.html
├── components/
│   ├── article-editor.js
│   ├── article-list.js
│   ├── article-card.js
│   ├── markdown-renderer.js
│   └── tag-selector.js
├── services/
│   ├── content-service.js
│   └── media-service.js
└── admin/
    ├── dashboard.js
    ├── editor.js
    └── settings.js</code></pre>
<h3>Rich Text Editor</h3>
<pre><code class="language-javascript">// article-editor.js
class ArticleEditor extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: &#039;open&#039; });
    this.article = { title: &#039;&#039;, content: &#039;&#039;, tags: [] };
  }

  connectedCallback() {
    pan.subscribe(&#039;article.load&#039;, ({ article }) =&gt; {
      this.article = article;
      this.render();
    });

    this.render();
    this.setupAutoSave();
  }

  render() {
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
        .editor {
          max-width: 900px;
          margin: 0 auto;
          padding: 2rem;
        }

        .title-input {
          width: 100%;
          font-size: 2rem;
          font-weight: bold;
          border: none;
          border-bottom: 2px solid #e0e0e0;
          padding: 0.5rem 0;
          margin-bottom: 2rem;
        }

        .content-editor {
          min-height: 400px;
          border: 1px solid #e0e0e0;
          border-radius: 4px;
          padding: 1rem;
          font-family: monospace;
        }

        .toolbar {
          display: flex;
          gap: 0.5rem;
          margin-bottom: 1rem;
          padding: 0.5rem;
          background: #f5f5f5;
          border-radius: 4px;
        }

        .toolbar button {
          padding: 0.5rem 1rem;
          background: white;
          border: 1px solid #ccc;
          border-radius: 4px;
          cursor: pointer;
        }

        .save-status {
          text-align: right;
          color: #666;
          font-size: 0.875rem;
          margin-top: 1rem;
        }
      &lt;/style&gt;

      &lt;div class=&quot;editor&quot;&gt;
        &lt;input
          type=&quot;text&quot;
          class=&quot;title-input&quot;
          placeholder=&quot;Article Title&quot;
          value=&quot;${this.article.title}&quot;
        &gt;

        &lt;div class=&quot;toolbar&quot;&gt;
          &lt;button data-action=&quot;bold&quot;&gt;Bold&lt;/button&gt;
          &lt;button data-action=&quot;italic&quot;&gt;Italic&lt;/button&gt;
          &lt;button data-action=&quot;link&quot;&gt;Link&lt;/button&gt;
          &lt;button data-action=&quot;image&quot;&gt;Image&lt;/button&gt;
          &lt;button data-action=&quot;code&quot;&gt;Code Block&lt;/button&gt;
        &lt;/div&gt;

        &lt;textarea
          class=&quot;content-editor&quot;
          placeholder=&quot;Write your article in Markdown...&quot;
        &gt;${this.article.content}&lt;/textarea&gt;

        &lt;div class=&quot;save-status&quot;&gt;
          &lt;span class=&quot;status-text&quot;&gt;All changes saved&lt;/span&gt;
        &lt;/div&gt;

        &lt;div class=&quot;actions&quot;&gt;
          &lt;button class=&quot;preview-btn&quot;&gt;Preview&lt;/button&gt;
          &lt;button class=&quot;publish-btn&quot;&gt;Publish&lt;/button&gt;
          &lt;button class=&quot;save-draft-btn&quot;&gt;Save Draft&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;

    this.setupEditorEvents();
  }

  setupEditorEvents() {
    const titleInput = this.shadowRoot.querySelector(&#039;.title-input&#039;);
    const contentEditor = this.shadowRoot.querySelector(&#039;.content-editor&#039;);

    titleInput.addEventListener(&#039;input&#039;, (e) =&gt; {
      this.article.title = e.target.value;
      this.markDirty();
    });

    contentEditor.addEventListener(&#039;input&#039;, (e) =&gt; {
      this.article.content = e.target.value;
      this.markDirty();
    });

    // Toolbar actions
    this.shadowRoot.querySelectorAll(&#039;[data-action]&#039;).forEach(btn =&gt; {
      btn.addEventListener(&#039;click&#039;, () =&gt; {
        this.applyFormatting(btn.dataset.action);
      });
    });
  }

  setupAutoSave() {
    setInterval(() =&gt; {
      if (this.dirty) {
        this.save();
      }
    }, 10000); // Auto-save every 10 seconds
  }

  markDirty() {
    this.dirty = true;
    this.shadowRoot.querySelector(&#039;.status-text&#039;).textContent = &#039;Unsaved changes&#039;;
  }

  async save() {
    try {
      await contentService.save(this.article);
      this.dirty = false;
      this.shadowRoot.querySelector(&#039;.status-text&#039;).textContent = &#039;All changes saved&#039;;
    } catch (error) {
      this.shadowRoot.querySelector(&#039;.status-text&#039;).textContent = &#039;Save failed&#039;;
    }
  }

  applyFormatting(action) {
    const textarea = this.shadowRoot.querySelector(&#039;.content-editor&#039;);
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = textarea.value.substring(start, end);

    let formattedText;
    switch (action) {
      case &#039;bold&#039;:
        formattedText = `**${selectedText}**`;
        break;
      case &#039;italic&#039;:
        formattedText = `*${selectedText}*`;
        break;
      case &#039;code&#039;:
        formattedText = `\`\`\`\n${selectedText}\n\`\`\``;
        break;
      case &#039;link&#039;:
        formattedText = `[${selectedText}](url)`;
        break;
      case &#039;image&#039;:
        formattedText = `![${selectedText}](image-url)`;
        break;
    }

    textarea.value =
      textarea.value.substring(0, start) +
      formattedText +
      textarea.value.substring(end);

    this.article.content = textarea.value;
    this.markDirty();
  }
}

customElements.define(&#039;article-editor&#039;, ArticleEditor);</code></pre>
<h3>Content Preview</h3>
<pre><code class="language-javascript">// markdown-renderer.js
class MarkdownRenderer extends HTMLElement {
  static observedAttributes = [&#039;content&#039;];

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === &#039;content&#039; &amp;&amp; oldValue !== newValue) {
      this.render();
    }
  }

  async render() {
    const markdown = this.getAttribute(&#039;content&#039;) || &#039;&#039;;

    // Use marked.js for markdown parsing
    const { marked } = await import(&#039;https://cdn.jsdelivr.net/npm/marked@12/+esm&#039;);

    this.innerHTML = `
      &lt;div class=&quot;markdown-content&quot;&gt;
        ${marked.parse(markdown)}
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;markdown-renderer&#039;, MarkdownRenderer);</code></pre>
<h2>Architecture Decisions and Tradeoffs</h2>
<h3>When to Use LARC</h3>
<strong>✅ Great for:</strong>
<ul><li>Progressive web apps</li>
<li>Content-heavy sites (blogs, documentation)</li>
<li>Dashboards and admin panels</li>
<li>Internal tools</li>
<li>Prototypes and MVPs</li>
<li>Projects with long maintenance horizons</li>
</ul>
<strong>❌ Consider alternatives for:</strong>
<ul><li>Apps requiring server-side rendering for SEO</li>
<li>Highly interactive games (use Canvas/WebGL directly)</li>
<li>Apps requiring React Native for mobile</li>
<li>Teams deeply invested in React/Vue ecosystem</li>
</ul>
<h3>State Management Patterns</h3>
<strong>Local State (Component Properties):</strong>
<pre><code class="language-javascript">class Counter extends HTMLElement {
  constructor() {
    super();
    this.count = 0; // Local state
  }

  increment() {
    this.count++;
    this.render();
  }
}</code></pre>
<strong>Shared State (PAN Bus):</strong>
<pre><code class="language-javascript">// One component publishes
pan.publish(&#039;user.login&#039;, { userId, name });

// Many components subscribe
pan.subscribe(&#039;user.login&#039;, ({ name }) =&gt; {
  this.userName = name;
  this.render();
});</code></pre>
<strong>Persistent State (LocalStorage + PAN):</strong>
<pre><code class="language-javascript">class AppState {
  constructor() {
    this.state = JSON.parse(localStorage.getItem(&#039;app-state&#039;)) || {};

    pan.subscribe(&#039;state.*&#039;, (data, topic) =&gt; {
      const key = topic.split(&#039;.&#039;)[1];
      this.state[key] = data;
      localStorage.setItem(&#039;app-state&#039;, JSON.stringify(this.state));
    });
  }

  get(key) {
    return this.state[key];
  }

  set(key, value) {
    pan.publish(`state.${key}`, value);
  }
}

export const appState = new AppState();</code></pre>
<h3>Scaling Considerations</h3>
<strong>Code Organization:</strong>
<pre><code class="language-plaintext">large-app/
├── index.html
├── app.js
├── features/
│   ├── auth/
│   │   ├── components/
│   │   ├── services/
│   │   └── index.js
│   ├── products/
│   │   ├── components/
│   │   ├── services/
│   │   └── index.js
│   └── checkout/
│       ├── components/
│       ├── services/
│       └── index.js
├── shared/
│   ├── components/
│   ├── services/
│   └── utils/
└── config/
    ├── router.js
    └── pan.js</code></pre>
<strong>Lazy Loading Features:</strong>
<pre><code class="language-javascript">// app.js - Load features on demand
const features = {
  &#039;auth&#039;: () =&gt; import(&#039;./features/auth/index.js&#039;),
  &#039;products&#039;: () =&gt; import(&#039;./features/products/index.js&#039;),
  &#039;checkout&#039;: () =&gt; import(&#039;./features/checkout/index.js&#039;)
};

pan.subscribe(&#039;feature.load&#039;, async ({ name }) =&gt; {
  if (features[name]) {
    await features[name]();
    pan.publish(&#039;feature.loaded&#039;, { name });
  }
});

// Auto-load on route change
pan.subscribe(&#039;router.navigate&#039;, ({ path }) =&gt; {
  const feature = path.split(&#039;/&#039;)[1];
  pan.publish(&#039;feature.load&#039;, { name: feature });
});</code></pre>
<h3>Performance at Scale</h3>
<strong>Virtual Scrolling for Large Lists:</strong>
<pre><code class="language-javascript">class VirtualList extends HTMLElement {
  constructor() {
    super();
    this.items = [];
    this.itemHeight = 50;
    this.visibleCount = 20;
    this.scrollTop = 0;
  }

  set data(items) {
    this.items = items;
    this.render();
  }

  connectedCallback() {
    this.addEventListener(&#039;scroll&#039;, () =&gt; {
      this.scrollTop = this.scrollTop;
      requestAnimationFrame(() =&gt; this.render());
    });
  }

  render() {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.min(startIndex + this.visibleCount, this.items.length);
    const visibleItems = this.items.slice(startIndex, endIndex);

    this.innerHTML = `
      &lt;div style=&quot;height: ${this.items.length * this.itemHeight}px; position: relative;&quot;&gt;
        ${visibleItems.map((item, i) =&gt; `
          &lt;div style=&quot;
            position: absolute;
            top: ${(startIndex + i) * this.itemHeight}px;
            height: ${this.itemHeight}px;
            width: 100%;
          &quot;&gt;
            ${item.name}
          &lt;/div&gt;
        `).join(&#039;&#039;)}
      &lt;/div&gt;
    `;
  }
}</code></pre>
<strong>Memoization and Caching:</strong>
<pre><code class="language-javascript">class ProductCatalog extends HTMLElement {
  constructor() {
    super();
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
  }

  async getProducts(category) {
    const cacheKey = `products-${category}`;
    const cached = this.cache.get(cacheKey);

    if (cached &amp;&amp; Date.now() - cached.timestamp &lt; this.cacheTimeout) {
      return cached.data;
    }

    const data = await productService.getByCategory(category);

    this.cache.set(cacheKey, {
      data,
      timestamp: Date.now()
    });

    return data;
  }
}</code></pre>
<h2>Maintenance and Evolution</h2>
<h3>Versioning Components</h3>
<pre><code class="language-javascript">// v1/button.js
class ButtonV1 extends HTMLElement {
  // Original implementation
}
customElements.define(&#039;app-button-v1&#039;, ButtonV1);

// v2/button.js
class ButtonV2 extends HTMLElement {
  // New implementation with breaking changes
}
customElements.define(&#039;app-button&#039;, ButtonV2);

// Migration path: Both versions coexist
// Old code uses app-button-v1
// New code uses app-button
// Gradual migration over time</code></pre>
<h3>Feature Flags</h3>
<pre><code class="language-javascript">// feature-flags.js
class FeatureFlags {
  constructor() {
    this.flags = {
      &#039;new-checkout&#039;: false,
      &#039;beta-dashboard&#039;: true,
      &#039;experimental-editor&#039;: false
    };
  }

  isEnabled(feature) {
    return this.flags[feature] ?? false;
  }

  enable(feature) {
    this.flags[feature] = true;
    pan.publish(&#039;feature-flag.changed&#039;, { feature, enabled: true });
  }
}

export const featureFlags = new FeatureFlags();

// Usage in component
class Checkout extends HTMLElement {
  connectedCallback() {
    if (featureFlags.isEnabled(&#039;new-checkout&#039;)) {
      this.innerHTML = &#039;&lt;new-checkout-flow&gt;&lt;/new-checkout-flow&gt;&#039;;
    } else {
      this.innerHTML = &#039;&lt;legacy-checkout-flow&gt;&lt;/legacy-checkout-flow&gt;&#039;;
    }
  }
}</code></pre>
<h3>Migration from React</h3>
<p>Here's how to migrate a React app to LARC:</p>
<strong>React Component:</strong>
<pre><code class="language-javascript">function TodoItem({ todo, onComplete }) {
  return (
    &lt;div className=&quot;todo-item&quot;&gt;
      &lt;input
        type=&quot;checkbox&quot;
        checked={todo.completed}
        onChange={() =&gt; onComplete(todo.id)}
      /&gt;
      &lt;span&gt;{todo.text}&lt;/span&gt;
    &lt;/div&gt;
  );
}</code></pre>
<strong>LARC Equivalent:</strong>
<pre><code class="language-javascript">class TodoItem extends HTMLElement {
  static observedAttributes = [&#039;completed&#039;];

  connectedCallback() {
    this.render();
  }

  attributeChangedCallback() {
    this.render();
  }

  render() {
    const completed = this.hasAttribute(&#039;completed&#039;);
    const text = this.getAttribute(&#039;text&#039;) || &#039;&#039;;

    this.innerHTML = `
      &lt;div class=&quot;todo-item&quot;&gt;
        &lt;input
          type=&quot;checkbox&quot;
          ${completed ? &#039;checked&#039; : &#039;&#039;}
        &gt;
        &lt;span&gt;${text}&lt;/span&gt;
      &lt;/div&gt;
    `;

    this.querySelector(&#039;input&#039;).addEventListener(&#039;change&#039;, () =&gt; {
      pan.publish(&#039;todo.complete&#039;, { id: this.getAttribute(&#039;todo-id&#039;) });
    });
  }
}

customElements.define(&#039;todo-item&#039;, TodoItem);</code></pre>
<h3>Migration from Vue</h3>
<strong>Vue Component:</strong>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;user-card&quot;&gt;
    &lt;img :src=&quot;user.avatar&quot; :alt=&quot;user.name&quot;&gt;
    &lt;h3&gt;{{ user.name }}&lt;/h3&gt;
    &lt;p&gt;{{ user.email }}&lt;/p&gt;
    &lt;button @click=&quot;viewProfile&quot;&gt;View Profile&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: [&#039;user&#039;],
  methods: {
    viewProfile() {
      this.$router.push(`/user/${this.user.id}`);
    }
  }
}
&lt;/script&gt;</code></pre>
<strong>LARC Equivalent:</strong>
<pre><code class="language-javascript">class UserCard extends HTMLElement {
  static observedAttributes = [&#039;user-id&#039;];

  async connectedCallback() {
    const userId = this.getAttribute(&#039;user-id&#039;);
    this.user = await userService.get(userId);
    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;user-card&quot;&gt;
        &lt;img src=&quot;${this.user.avatar}&quot; alt=&quot;${this.user.name}&quot;&gt;
        &lt;h3&gt;${this.user.name}&lt;/h3&gt;
        &lt;p&gt;${this.user.email}&lt;/p&gt;
        &lt;button class=&quot;view-btn&quot;&gt;View Profile&lt;/button&gt;
      &lt;/div&gt;
    `;

    this.querySelector(&#039;.view-btn&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      pan.publish(&#039;router.navigate&#039;, { path: `/user/${this.user.id}` });
    });
  }
}

customElements.define(&#039;user-card&#039;, UserCard);</code></pre>
<h2>Real-World Challenges and Solutions</h2>
<h3>Challenge 1: SEO for Content Sites</h3>
<strong>Problem</strong>: Client-side rendering isn't indexed by search engines.
<strong>Solution</strong>: Pre-render static content
<pre><code class="language-javascript">// build-static.js - Pre-render pages at build time
import { JSDOM } from &#039;jsdom&#039;;
import { writeFileSync } from &#039;fs&#039;;

async function prerender(url, outputPath) {
  const dom = new JSDOM(html);
  global.window = dom.window;
  global.document = dom.window.document;

  // Load and execute components
  await import(&#039;./components/article-page.js&#039;);

  // Wait for async content to load
  await new Promise(resolve =&gt; setTimeout(resolve, 1000));

  // Write rendered HTML
  writeFileSync(outputPath, dom.serialize());
}

// Pre-render all blog posts
const posts = await contentService.getAllPosts();
for (const post of posts) {
  await prerender(`/blog/${post.slug}`, `dist/blog/${post.slug}.html`);
}</code></pre>
<h3>Challenge 2: Complex State Synchronization</h3>
<strong>Problem</strong>: Multiple components need to stay in sync with complex state.
<strong>Solution</strong>: Centralized state manager
<pre><code class="language-javascript">// state-manager.js
class StateManager {
  constructor() {
    this.state = {};
    this.subscribers = new Map();
  }

  get(path) {
    return path.split(&#039;.&#039;).reduce((obj, key) =&gt; obj?.[key], this.state);
  }

  set(path, value) {
    const keys = path.split(&#039;.&#039;);
    const lastKey = keys.pop();
    const target = keys.reduce((obj, key) =&gt; {
      if (!obj[key]) obj[key] = {};
      return obj[key];
    }, this.state);

    target[lastKey] = value;

    // Notify subscribers
    pan.publish(`state.${path}`, value);
  }

  subscribe(path, callback) {
    return pan.subscribe(`state.${path}`, callback);
  }
}

export const state = new StateManager();</code></pre>
<h3>Challenge 3: Testing Async Component Behavior</h3>
<strong>Problem</strong>: Components with async data loading are hard to test.
<strong>Solution</strong>: Dependency injection and mocking
<pre><code class="language-javascript">// product-list.test.js
import { fixture, html } from &#039;@open-wc/testing&#039;;
import &#039;./product-list.js&#039;;

// Mock service
const mockProductService = {
  getAll: () =&gt; Promise.resolve([
    { id: 1, name: &#039;Product 1&#039;, price: 10 },
    { id: 2, name: &#039;Product 2&#039;, price: 20 }
  ])
};

describe(&#039;ProductList&#039;, () =&gt; {
  it(&#039;renders products after loading&#039;, async () =&gt; {
    // Inject mock
    window.productService = mockProductService;

    const el = await fixture(html`&lt;product-list&gt;&lt;/product-list&gt;`);

    // Wait for async render
    await new Promise(resolve =&gt; setTimeout(resolve, 100));

    const products = el.querySelectorAll(&#039;product-card&#039;);
    expect(products.length).to.equal(2);
  });
});</code></pre>
<h2>Team Practices and Workflows</h2>
<h3>Code Review Checklist</h3>
<ul><li>[ ] Component follows single responsibility principle</li>
<li>[ ] Shadow DOM used for encapsulation</li>
<li>[ ] Event listeners cleaned up in <code>disconnectedCallback</code></li>
<li>[ ] Attributes declared in <code>observedAttributes</code></li>
<li>[ ] JSDoc comments for public API</li>
<li>[ ] Tests cover happy path and error cases</li>
<li>[ ] Accessible (keyboard navigation, ARIA)</li>
<li>[ ] Performance profiled (if rendering > 100 items)</li>
</ul>
<h3>Component Design Guidelines</h3>
<li><strong>Keep components small</strong>: If a component is > 200 lines, split it</li>
<li><strong>Prefer composition</strong>: Use slots and nested components</li>
<li><strong>Clear naming</strong>: <code><user-profile-card></code> not <code><component-5></code></li>
<li><strong>Consistent patterns</strong>: All similar components follow same structure</li>
<li><strong>Document props</strong>: JSDoc with type information</li>
<li><strong>Handle errors gracefully</strong>: Show user-friendly error messages</li>
<h3>Development Workflow</h3>
<pre><code class="language-bash"># 1. Create feature branch
git checkout -b feature/user-authentication

# 2. Write component with tests
npm run test:watch

# 3. Run linter
npm run lint

# 4. Create PR
git push origin feature/user-authentication

# 5. CI runs tests and linter
# 6. Code review
# 7. Merge to main
# 8. Deploy to production
npm run deploy</code></pre>
<h2>Troubleshooting Real-World Applications</h2>
<h3>Problem 1: Component State Gets Out of Sync</h3>
<strong>Symptoms</strong>: UI shows stale data, actions don't reflect in other parts of the app
<strong>Cause</strong>: Multiple sources of truth, missed PAN bus updates
<strong>Solution</strong>:
<pre><code class="language-javascript">// Bad: Duplicated state
class ProductCard extends HTMLElement {
  constructor() {
    super();
    this.product = null;  // Local copy
  }
}

// Good: Single source of truth
class ProductCard extends HTMLElement {
  connectedCallback() {
    // Subscribe to state changes
    this.unsub = pan.subscribe(&#039;products.*.updated&#039;, (data, topic) =&gt; {
      const productId = topic.split(&#039;.&#039;)[1];
      if (productId === this.productId) {
        this.render();
      }
    });
  }
}</code></pre>
<h3>Problem 2: Memory Leaks in Long-Running Apps</h3>
<strong>Symptoms</strong>: App slows down over time, browser tab uses increasing memory
<strong>Cause</strong>: Event listeners not cleaned up, retained references
<strong>Solution</strong>:
<pre><code class="language-javascript">class Dashboard extends HTMLElement {
  connectedCallback() {
    // Track subscriptions for cleanup
    this.subscriptions = [
      pan.subscribe(&#039;metrics.updated&#039;, this.handleMetrics),
      pan.subscribe(&#039;alerts.new&#039;, this.handleAlert)
    ];

    // Track intervals
    this.updateInterval = setInterval(() =&gt; this.fetchUpdates(), 5000);
  }

  disconnectedCallback() {
    // Clean up all subscriptions
    this.subscriptions.forEach(unsub =&gt; unsub());
    this.subscriptions = [];

    // Clear intervals
    clearInterval(this.updateInterval);
  }
}</code></pre>
<h3>Problem 3: Performance Degrades with Large Datasets</h3>
<strong>Symptoms</strong>: Slow rendering, laggy interactions when displaying many items
<strong>Cause</strong>: Rendering all items at once, no virtualization
<strong>Solution</strong>:
<pre><code class="language-javascript">// Use virtual scrolling for large lists
class VirtualProductList extends HTMLElement {
  render() {
    const viewportHeight = this.clientHeight;
    const scrollTop = this.scrollTop;
    const itemHeight = 100;

    // Calculate visible range
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.ceil((scrollTop + viewportHeight) / itemHeight);

    // Only render visible items
    const visibleItems = this.products.slice(startIndex, endIndex + 1);

    this.innerHTML = `
      &lt;div style=&quot;height: ${this.products.length * itemHeight}px&quot;&gt;
        &lt;div style=&quot;transform: translateY(${startIndex * itemHeight}px)&quot;&gt;
          ${visibleItems.map(product =&gt; this.renderItem(product)).join(&#039;&#039;)}
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }
}</code></pre>
<h3>Problem 4: Race Conditions with Async Operations</h3>
<strong>Symptoms</strong>: Wrong data displayed, operations complete out of order
<strong>Cause</strong>: Multiple async requests, no cancellation or ordering
<strong>Solution</strong>:
<pre><code class="language-javascript">class SearchBox extends HTMLElement {
  constructor() {
    super();
    this.abortController = null;
    this.requestId = 0;
  }

  async search(query) {
    // Cancel previous request
    if (this.abortController) {
      this.abortController.abort();
    }

    this.abortController = new AbortController();
    const currentRequestId = ++this.requestId;

    try {
      const results = await fetch(`/api/search?q=${query}`, {
        signal: this.abortController.signal
      });

      // Only update if this is still the latest request
      if (currentRequestId === this.requestId) {
        this.displayResults(await results.json());
      }
    } catch (err) {
      if (err.name !== &#039;AbortError&#039;) throw err;
    }
  }
}</code></pre>
<h2>Real-World Application Best Practices</h2>
<li><strong>Design for Scale from Day One</strong></li>
   - Plan component boundaries before coding
   - Use lazy loading for routes and heavy components
   - Profile performance early and often
<li><strong>Establish Clear State Management Patterns</strong></li>
   - Single source of truth for shared state
   - Local state for component-specific data
   - Document state flow in architecture diagrams
<li><strong>Implement Comprehensive Error Handling</strong></li>
   - Catch errors at component boundaries
   - Display user-friendly error messages
   - Log errors for debugging and monitoring
<li><strong>Write Tests for Critical Paths</strong></li>
   - Test user journeys end-to-end
   - Cover edge cases and error scenarios
   - Maintain test coverage above 80%
<li><strong>Optimize for Production</strong></li>
   - Minify and compress assets
   - Enable HTTP/2 and compression
   - Use CDN for static assets
   - Implement service worker caching
<li><strong>Monitor and Measure</strong></li>
   - Track Core Web Vitals
   - Set up error tracking (Sentry, etc.)
   - Monitor real user metrics
   - Set up alerts for performance regressions
<li><strong>Plan for Evolution</strong></li>
   - Version your components
   - Use feature flags for gradual rollouts
   - Keep dependencies up to date
   - Document breaking changes
<li><strong>Prioritize Developer Experience</strong></li>
   - Set up linting and formatting
   - Create component templates/generators
   - Document common patterns
   - Maintain example implementations
<li><strong>Focus on Accessibility</strong></li>
   - Test with screen readers
   - Support keyboard navigation
   - Follow ARIA best practices
   - Include accessibility in code review checklist
<li><strong>Build for the Long Term</strong></li>
    - Prefer web standards over frameworks
    - Keep dependencies minimal
    - Write clear, self-documenting code
    - Invest in comprehensive documentation
<h2>Hands-On Exercises</h2>
<h3>Exercise 1: Build a Multi-Page E-Commerce App</h3>
<p>Build a complete e-commerce application with:</p>
<ul><li>Product listing with filters and sorting</li>
<li>Individual product pages</li>
<li>Shopping cart with persistence</li>
<li>Checkout flow with form validation</li>
<li>Admin panel for inventory management</li>
</ul>
<strong>Requirements:</strong>
<ul><li>Use PAN bus for state management</li>
<li>Implement lazy loading for routes</li>
<li>Add comprehensive error handling</li>
<li>Include unit and E2E tests</li>
<li>Deploy to production hosting</li>
</ul>
<strong>Bonus Challenge:</strong> Add user authentication with JWT tokens and implement role-based access control for admin features.
<h3>Exercise 2: Create a Real-Time Dashboard</h3>
<p>Build a dashboard application that displays:</p>
<ul><li>Real-time metrics (using WebSocket)</li>
<li>Interactive charts and graphs</li>
<li>Data filtering and time range selection</li>
<li>Alert notifications</li>
<li>User preferences and saved views</li>
</ul>
<strong>Requirements:</strong>
<ul><li>Virtual scrolling for large datasets</li>
<li>Optimistic UI updates</li>
<li>Service worker for offline functionality</li>
<li>Performance profiled (60fps interactions)</li>
<li>Responsive design for mobile/desktop</li>
</ul>
<strong>Bonus Challenge:</strong> Implement data export (CSV, PDF), scheduled reports, and email notifications for alerts.
<h3>Exercise 3: Build a Blog CMS</h3>
<p>Create a complete content management system with:</p>
<ul><li>Rich text editor for articles</li>
<li>Draft/publish workflow</li>
<li>Tag and category management</li>
<li>SEO optimization (meta tags, sitemaps)</li>
<li>Media library for images</li>
<li>Comment moderation</li>
</ul>
<strong>Requirements:</strong>
<ul><li>Server integration (Node.js or your choice)</li>
<li>Client-side routing with SSR for SEO</li>
<li>Form validation and error handling</li>
<li>Auto-save functionality</li>
<li>Search functionality</li>
<li>User roles (admin, editor, author)</li>
</ul>
<strong>Bonus Challenge:</strong> Add markdown support with live preview, scheduled publishing, and content analytics (views, engagement).
<h3>Exercise 4: Migrate an Existing Application</h3>
<p>Take an existing React or Vue application and migrate it to LARC:</p>
<ul><li>Audit current architecture and dependencies</li>
<li>Create migration plan with phases</li>
<li>Implement hybrid approach (gradual migration)</li>
<li>Maintain feature parity during migration</li>
<li>Compare bundle sizes and performance</li>
</ul>
<strong>Requirements:</strong>
<ul><li>Document migration process</li>
<li>Create mapping guide (React/Vue → LARC)</li>
<li>Identify and solve migration challenges</li>
<li>Set up automated tests to prevent regressions</li>
<li>Deploy both versions and compare metrics</li>
</ul>
<strong>Bonus Challenge:</strong> Create a migration tool/CLI that automates conversion of common component patterns.
<h2>Summary</h2>
<p>Building real applications with LARC teaches you to:</p>
<ul><li><strong>Think in components</strong>: Break UI into small, reusable pieces</li>
<li><strong>Leverage web standards</strong>: Use what browsers provide</li>
<li><strong>Embrace simplicity</strong>: No build step means faster development</li>
<li><strong>Scale thoughtfully</strong>: Lazy load, virtualize, cache strategically</li>
<li><strong>Test continuously</strong>: Catch bugs early with comprehensive tests</li>
<li><strong>Profile performance</strong>: Measure before optimizing</li>
<li><strong>Plan for evolution</strong>: Version components, use feature flags</li>
</ul>
LARC's no-build philosophy and standards-based approach make it ideal for long-lived projects that need maintainability and performance at scale.
<h2>Further Reading</h2>
<ul><li><strong>Building with LARC - All Chapters</strong>: Complete API reference and advanced patterns</li>
<li><strong>MDN Web Components</strong>: Deep dive into the platform</li>
<li><strong>Open-wc</strong>: Testing and tooling best practices for web components</li>
</ul>
<div class="pagebreak"></div>
<h2>About the Author</h2>
<p>Christopher Robison is a veteran software engineer and architect with nearly three 
decades of experience building systems that range from biotech and online trading 
platforms to complex web applications and AI-driven tools. A lifelong maker with 
a deep appreciation for open standards, he has spent his career exploring the 
boundaries of what the web can do when you stop fighting the platform and start 
embracing it.</p>
<p>He is the creator of LARC.js and the PAN message bus, a browser-native architecture 
inspired by the elegant simplicity of the automotive CAN bus. His work blends engineering 
pragmatism with a playful curiosity that has led him to design everything from 
3D printers and robotics to interactive music systems and decentralized applications.</p>
<p>Christopher currently lives in San Francisco, where he continues to build things that 
bridge the digital and physical worlds — and occasionally sneaks off to play punk 
rock shows with his band.</p>
<div class="pagebreak"></div>
<h2>The Web Has Grown Up. It’s Time Our Apps Did Too.</h2>
<p>Modern browsers aren’t the brittle playgrounds they once were. They’re fast, secure, 
richly capable application platforms — yet most of today’s development stacks still 
treat them like dumb terminals that need layers of tooling, bundling, and framework 
magic just to function.</p>
<strong>Learning LARC</strong> shows another path.
<p>LARC embraces the browser as a mature runtime, using nothing but open standards — 
Web Components, modules, events, and message buses — to build complex, deeply 
interactive applications without build systems, without monoliths, and without 
ceremony. Through clear narrative examples and real architectural stories, this 
book teaches you how to design apps as ecosystems: small parts, clearly defined, 
communicating through a shared bus.</p>
<p>You’ll learn how to structure large systems out of tiny cooperating modules, expose 
capabilities through message patterns instead of global state, keep your interfaces 
clean, and let the platform do the heavy lifting it was built for.</p>
<p>No bundlers. No scaffolding. No twenty-layer dependency stacks.
Just the browser, finally treated like the grown-up it is.</p>
<p>Whether you’re maintaining a legacy system or starting fresh, <strong>Learning LARC</strong> will 
help you rethink how modern web apps can — and should — be built.</p>

      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/learning-larc/build/temp/learning-larc-complete.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
</body>
</html>