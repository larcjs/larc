<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Migration Guide Â· PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Migration Guide">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">backup</a> / <a href="#">building-with-larc-original-20251226</a> / <span>appendix-d-migration-guide</span>
      </div>
      <article class="docs-content">
        <h1>Migration Guide</h1>
<p>This appendix helps you upgrade LARC applications across versions, navigate breaking changes, and adopt new features while maintaining stability. Whether you're moving from an early prototype to a production release or keeping pace with framework evolution, this guide provides version-specific migration paths and practical strategies.</p>
<h2>General Migration Strategy</h2>
<p>Before diving into version-specific changes, establish a methodical upgrade process:</p>
<strong>1. Review the Changelog</strong>
Start with LARC's release notes. Note breaking changes, deprecations, and new features relevant to your application.
<strong>2. Update in Increments</strong>
Avoid jumping multiple major versions. Upgrade one major version at a time, testing thoroughly between steps.
<strong>3. Run Your Test Suite</strong>
Execute all tests before and after migration. Pay special attention to component integration tests that exercise PAN bus communication.
<strong>4. Check Dependencies</strong>
Ensure your LARC-compatible libraries (routing, state management) support the new version. Update these incrementally.
<strong>5. Use Feature Flags</strong>
When migrating large applications, use feature flags to toggle between old and new implementations during transition periods.
<h2>Version 0.x to 1.0 Migration</h2>
<p>The move to LARC 1.0 established core APIs and stabilized component architecture. Key changes:</p>
<h3>Component Registration Changes</h3>
<strong>Before (0.x):</strong>
<pre><code class="language-javascript">LARC.register(&#039;my-widget&#039;, {
  template: &#039;&lt;div&gt;Content&lt;/div&gt;&#039;,
  props: [&#039;data&#039;]
});</code></pre>
<strong>After (1.0):</strong>
<pre><code class="language-javascript">class MyWidget extends HTMLElement {
  static observedAttributes = [&#039;data&#039;];

  connectedCallback() {
    this.render();
  }

  render() {
    this.innerHTML = &#039;&lt;div&gt;Content&lt;/div&gt;&#039;;
  }
}

customElements.define(&#039;my-widget&#039;, MyWidget);</code></pre>
<strong>Migration Steps:</strong>
<li>Convert registration objects to ES6 classes extending <code>HTMLElement</code></li>
<li>Move lifecycle hooks to standard Web Components callbacks</li>
<li>Implement <code>observedAttributes</code> for reactive properties</li>
<li>Replace template strings with <code>render()</code> methods</li>
<h3>PAN Bus API Refinement</h3>
<p>Version 1.0 introduced explicit bus references rather than implicit global access.</p>
<strong>Before (0.x):</strong>
<pre><code class="language-javascript">this.emit(&#039;data-changed&#039;, { value: 42 });
this.on(&#039;user-action&#039;, handler);</code></pre>
<strong>After (1.0):</strong>
<pre><code class="language-javascript">this.pan.dispatch(&#039;data-changed&#039;, { value: 42 });
this.pan.subscribe(&#039;user-action&#039;, handler);</code></pre>
<strong>Migration Steps:</strong>
<li>Replace <code>emit()</code> with <code>pan.dispatch()</code></li>
<li>Replace <code>on()</code> with <code>pan.subscribe()</code></li>
<li>Update cleanup to use returned unsubscribe functions</li>
<li>Add explicit PAN bus initialization if using custom buses</li>
<h3>Attribute Handling</h3>
<p>Attribute parsing became more strict in 1.0.</p>
<strong>Before (0.x):</strong>
<pre><code class="language-javascript">// Automatic JSON parsing
this.getAttribute(&#039;config&#039;); // returns object</code></pre>
<strong>After (1.0):</strong>
<pre><code class="language-javascript">// Explicit parsing required
JSON.parse(this.getAttribute(&#039;config&#039;) || &#039;{}&#039;);</code></pre>
<strong>Migration Steps:</strong>
<li>Add explicit JSON parsing for complex attributes</li>
<li>Implement <code>attributeChangedCallback()</code> for reactive updates</li>
<li>Use <code>observedAttributes</code> to declare monitored attributes</li>
<h2>Version 1.x to 2.0 Migration</h2>
<p>LARC 2.0 introduced TypeScript support, improved developer experience, and performance optimizations.</p>
<h3>TypeScript Integration</h3>
<p>While JavaScript remains fully supported, TypeScript brings type safety.</p>
<strong>Migration Steps:</strong>
<li>Install TypeScript definitions: <code>npm install --save-dev @larc/types</code></li>
<li>Rename <code>.js</code> files to <code>.ts</code> incrementally</li>
<li>Add type annotations to component properties</li>
<li>Define custom event payload types</li>
<strong>Example:</strong>
<pre><code class="language-typescript">import { PANEvent } from &#039;@larc/core&#039;;

interface UserData {
  id: string;
  name: string;
}

class UserCard extends HTMLElement {
  private userData: UserData | null = null;

  connectedCallback() {
    this.pan.subscribe&lt;UserData&gt;(&#039;user-selected&#039;, (event: PANEvent&lt;UserData&gt;) =&gt; {
      this.userData = event.detail;
      this.render();
    });
  }
}</code></pre>
<h3>Shadow DOM Adoption</h3>
<p>Version 2.0 encouraged Shadow DOM for style encapsulation.</p>
<strong>Before (1.x):</strong>
<pre><code class="language-javascript">connectedCallback() {
  this.innerHTML = &#039;&lt;div class=&quot;container&quot;&gt;Content&lt;/div&gt;&#039;;
}</code></pre>
<strong>After (2.0):</strong>
<pre><code class="language-javascript">connectedCallback() {
  this.attachShadow({ mode: &#039;open&#039; });
  this.shadowRoot.innerHTML = `
    &lt;style&gt;
      .container { padding: 1rem; }
    &lt;/style&gt;
    &lt;div class=&quot;container&quot;&gt;Content&lt;/div&gt;
  `;
}</code></pre>
<strong>Migration Considerations:</strong>
<ul><li>Global styles won't penetrate Shadow DOM</li>
<li>Use CSS custom properties for theming</li>
<li>Update selectors in tests to query shadow roots</li>
<li>Consider performance impact for large component trees</li>
</ul>
<h3>Async Component Initialization</h3>
<p>Version 2.0 added first-class async support.</p>
<strong>Before (1.x):</strong>
<pre><code class="language-javascript">connectedCallback() {
  fetch(&#039;/api/data&#039;).then(data =&gt; {
    this.data = data;
    this.render();
  });
}</code></pre>
<strong>After (2.0):</strong>
<pre><code class="language-javascript">async connectedCallback() {
  await this.initialize();
}

async initialize() {
  try {
    this.data = await fetch(&#039;/api/data&#039;).then(r =&gt; r.json());
    this.render();
  } catch (error) {
    this.renderError(error);
  }
}</code></pre>
<h2>Version 2.x to 3.0 Migration</h2>
<p>LARC 3.0 focused on performance, introducing reactive primitives and optimized rendering.</p>
<h3>Reactive State Management</h3>
<p>The new reactive state system replaces manual <code>render()</code> calls.</p>
<strong>Before (2.x):</strong>
<pre><code class="language-javascript">class Counter extends HTMLElement {
  constructor() {
    super();
    this.count = 0;
  }

  increment() {
    this.count++;
    this.render();
  }
}</code></pre>
<strong>After (3.0):</strong>
<pre><code class="language-javascript">import { reactive } from &#039;@larc/core&#039;;

class Counter extends HTMLElement {
  constructor() {
    super();
    this.state = reactive({ count: 0 });
    this.state.$watch(() =&gt; this.render());
  }

  increment() {
    this.state.count++; // automatically triggers render
  }
}</code></pre>
<strong>Migration Steps:</strong>
<li>Wrap component state in <code>reactive()</code></li>
<li>Set up <code>$watch()</code> for automatic rendering</li>
<li>Remove manual <code>render()</code> calls after state changes</li>
<li>Use <code>$batch()</code> for multiple simultaneous updates</li>
<h3>PAN Bus Namespacing</h3>
<p>Version 3.0 introduced event namespacing for better organization.</p>
<strong>Before (2.x):</strong>
<pre><code class="language-javascript">this.pan.dispatch(&#039;data-loaded&#039;, data);
this.pan.dispatch(&#039;data-error&#039;, error);
this.pan.dispatch(&#039;data-cleared&#039;);</code></pre>
<strong>After (3.0):</strong>
<pre><code class="language-javascript">this.pan.dispatch(&#039;data:loaded&#039;, data);
this.pan.dispatch(&#039;data:error&#039;, error);
this.pan.dispatch(&#039;data:cleared&#039;);

// Subscribe to namespace
this.pan.subscribe(&#039;data:*&#039;, (event) =&gt; {
  console.log(`Data event: ${event.type}`);
});</code></pre>
<h3>Performance Optimizations</h3>
<p>Version 3.0 added batched updates and render scheduling.</p>
<strong>Manual Batching:</strong>
<pre><code class="language-javascript">import { batch } from &#039;@larc/core&#039;;

batch(() =&gt; {
  this.state.count++;
  this.state.name = &#039;Updated&#039;;
  this.state.timestamp = Date.now();
}); // Single render after all changes</code></pre>
<strong>Render Scheduling:</strong>
<pre><code class="language-javascript">class HeavyComponent extends HTMLElement {
  render() {
    requestIdleCallback(() =&gt; {
      // Expensive rendering during idle time
      this.updateComplexUI();
    });
  }
}</code></pre>
<h2>Deprecation Timeline</h2>
<h3>Currently Deprecated (Remove in 4.0)</h3>
<strong>Legacy Event Syntax:</strong>
<pre><code class="language-javascript">// Deprecated
this.pan.on(&#039;event-name&#039;, handler);

// Use instead
this.pan.subscribe(&#039;event-name&#039;, handler);</code></pre>
<strong>Global Bus Access:</strong>
<pre><code class="language-javascript">// Deprecated
window.PAN.dispatch(&#039;event&#039;);

// Use instead
this.pan.dispatch(&#039;event&#039;);</code></pre>
<strong>Synchronous connectedCallback with async operations:</strong>
<pre><code class="language-javascript">// Deprecated pattern
connectedCallback() {
  fetch(&#039;/data&#039;).then(d =&gt; this.data = d);
  this.render(); // Renders before data loads
}

// Preferred
async connectedCallback() {
  this.data = await fetch(&#039;/data&#039;).then(r =&gt; r.json());
  this.render();
}</code></pre>
<h3>Planned Deprecations (4.0+)</h3>
<ul><li>Direct innerHTML manipulation (prefer template literals or JSX)</li>
<li>Imperative event listener registration (favor declarative templates)</li>
<li>String-based event names (transition to strongly-typed event enums)</li>
</ul>
<h2>Breaking Changes Checklist</h2>
<p>When upgrading major versions, verify these common breaking change areas:</p>
<strong>API Surface:</strong>
<ul><li>[ ] Component registration method</li>
<li>[ ] PAN bus method names</li>
<li>[ ] Event payload structure</li>
<li>[ ] Lifecycle callback signatures</li>
</ul>
<strong>Behavior Changes:</strong>
<ul><li>[ ] Attribute parsing (automatic vs. manual)</li>
<li>[ ] Default Shadow DOM usage</li>
<li>[ ] Event bubbling and cancellation</li>
<li>[ ] Async initialization timing</li>
</ul>
<strong>Build Process:</strong>
<ul><li>[ ] Bundler configuration</li>
<li>[ ] TypeScript compiler options</li>
<li>[ ] Test framework compatibility</li>
<li>[ ] Development server setup</li>
</ul>
<strong>Dependencies:</strong>
<ul><li>[ ] Peer dependency versions</li>
<li>[ ] Polyfill requirements</li>
<li>[ ] Browser compatibility targets</li>
<li>[ ] Third-party library compatibility</li>
</ul>
<h2>Migration Tools</h2>
<h3>Automated Refactoring</h3>
<p>Use these tools to accelerate migration:</p>
<strong>AST-Based Transforms:</strong>
<pre><code class="language-bash">npx @larc/migrate --from 2.x --to 3.0 src/**/*.js</code></pre>
<strong>Codemod Scripts:</strong>
<pre><code class="language-javascript">// Example: Convert emit to dispatch
module.exports = function(fileInfo, api) {
  const j = api.jscodeshift;
  return j(fileInfo.source)
    .find(j.CallExpression, {
      callee: {
        object: { type: &#039;ThisExpression&#039; },
        property: { name: &#039;emit&#039; }
      }
    })
    .forEach(path =&gt; {
      path.value.callee.property.name = &#039;dispatch&#039;;
    })
    .toSource();
};</code></pre>
<h3>Manual Review Points</h3>
<p>Automated tools can't catch everything. Manually review:</p>
<li><strong>Business Logic:</strong> Ensure state changes behave identically</li>
<li><strong>Edge Cases:</strong> Test error handling and boundary conditions</li>
<li><strong>Performance:</strong> Profile before/after for regressions</li>
<li><strong>User Experience:</strong> Verify visual consistency and interactions</li>
<h2>Rollback Strategy</h2>
<p>If migration causes critical issues:</p>
<li><strong>Revert Version:</strong> Use git to restore previous package.json</li>
<li><strong>Isolate Changes:</strong> Create feature branches for incremental updates</li>
<li><strong>Dual Implementation:</strong> Run old and new code side-by-side with feature flags</li>
<li><strong>Gradual Rollout:</strong> Deploy to subset of users before full migration</li>
<h2>Getting Help</h2>
<p>When stuck during migration:</p>
<ul><li><strong>Documentation:</strong> Check version-specific upgrade guides at larc.dev/migrate</li>
<li><strong>Community:</strong> Ask in GitHub Discussions or Discord</li>
<li><strong>Issue Tracker:</strong> Search for similar migration problems</li>
<li><strong>Support Contracts:</strong> Enterprise users can access dedicated migration assistance</li>
</ul>
Migration is an investment in your application's future. Take time to understand changes, test thoroughly, and leverage community resources. The LARC team strives for smooth upgrade paths while continuing to evolve the framework.
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/backup/building-with-larc-original-20251226/appendix-d-migration-guide.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
</body>
</html>