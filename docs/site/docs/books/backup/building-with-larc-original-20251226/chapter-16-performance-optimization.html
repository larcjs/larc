<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- CRITICAL: Load theme BEFORE CSS to prevent flash -->
  <script src="../../../../../../playground/theme-init.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Performance Optimization · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Performance Optimization">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">backup</a> / <a href="#">building-with-larc-original-20251226</a> / <span>chapter-16-performance-optimization</span>
      </div>
      <article class="docs-content">
        <h1>Performance Optimization</h1>
<blockquote>"Premature optimization is the root of all evil. But shipping a slow application is the root of losing all your users."</blockquote>
>
<blockquote>— Donald Knuth (paraphrased by someone who's watched users abandon slow apps)</blockquote>
<p>Performance isn't about making your application fast—it's about making it feel fast. Users don't care if your message bus can handle 10,000 messages per second if clicking a button takes three seconds to respond. They don't care if your virtual DOM is optimized if the initial page load shows a blank screen for five seconds.</p>
<p>In this chapter, we'll explore performance optimization strategies specific to LARC applications: efficient message filtering and routing, component lazy loading, virtual scrolling for massive lists, debouncing and throttling high-frequency events, memory management to prevent leaks, and bundle size optimization. By the end, you'll know how to build LARC applications that are not just correct, but fast.</p>
<h2>Message Filtering and Routing Efficiency</h2>
<p>The PAN bus is central to LARC applications. Every publish triggers subscriptions, and inefficient patterns can create performance bottlenecks.</p>
<h3>Pattern: Specific Topic Subscriptions</h3>
<p>Subscribe to specific topics, not wildcards, when possible:</p>
<pre><code class="language-javascript">// Bad: too broad
subscribe(&#039;*&#039;, (msg) =&gt; {
  if (msg.topic.startsWith(&#039;user.&#039;)) {
    // Handle user messages
  }
});

// Good: specific subscription
subscribe(&#039;user.*&#039;, (msg) =&gt; {
  // Only receives user messages
});

// Better: most specific possible
subscribe(&#039;user.profile.updated&#039;, (msg) =&gt; {
  // Only receives profile updates
});</code></pre>
<p>Specific subscriptions reduce unnecessary function calls.</p>
<h3>Pattern: Early Returns</h3>
<p>Return early from subscription handlers when the message isn't relevant:</p>
<pre><code class="language-javascript">subscribe(&#039;user.data&#039;, (msg) =&gt; {
  // Early return if not our user
  if (msg.data.userId !== this.currentUserId) {
    return;
  }

  // Expensive processing only for relevant messages
  this.processUserData(msg.data);
});</code></pre>
<h3>Pattern: Unsubscribe Aggressively</h3>
<p>Unsubscribe as soon as you no longer need messages:</p>
<pre><code class="language-javascript">class TemporaryComponent extends HTMLElement {
  connectedCallback() {
    // Subscribe to one-time event
    this.unsubscribe = subscribe(&#039;data.loaded&#039;, (msg) =&gt; {
      this.render(msg.data);

      // Unsubscribe immediately after first message
      this.unsubscribe();
      this.unsubscribe = null;
    });
  }

  disconnectedCallback() {
    // Clean up if component removed before message received
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}</code></pre>
<h3>Implementing Message Throttling</h3>
<p>Throttle high-frequency messages at the source:</p>
<pre><code class="language-javascript">class MouseTracker extends HTMLElement {
  constructor() {
    super();
    this.lastPublishTime = 0;
    this.publishInterval = 50; // Publish at most every 50ms (20 FPS)
  }

  connectedCallback() {
    this.addEventListener(&#039;mousemove&#039;, this.handleMouseMove.bind(this));
  }

  handleMouseMove(event) {
    const now = Date.now();

    // Throttle: only publish if enough time has passed
    if (now - this.lastPublishTime &lt; this.publishInterval) {
      return;
    }

    this.lastPublishTime = now;

    publish(&#039;mouse.position&#039;, {
      x: event.clientX,
      y: event.clientY,
      timestamp: now
    });
  }
}

customElements.define(&#039;mouse-tracker&#039;, MouseTracker);</code></pre>
<h3>Debouncing Message Publishers</h3>
<p>For user input, debounce to reduce message frequency:</p>
<pre><code class="language-javascript">class SearchInput extends HTMLElement {
  constructor() {
    super();
    this.debounceTimer = null;
    this.debounceDelay = 300; // Wait 300ms after last keystroke
  }

  connectedCallback() {
    this.innerHTML = `
      &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot; /&gt;
    `;

    this.querySelector(&#039;input&#039;).addEventListener(&#039;input&#039;, (event) =&gt; {
      this.handleInput(event.target.value);
    });
  }

  handleInput(value) {
    // Clear previous timer
    clearTimeout(this.debounceTimer);

    // Set new timer
    this.debounceTimer = setTimeout(() =&gt; {
      publish(&#039;search.query&#039;, { query: value });
    }, this.debounceDelay);
  }
}

customElements.define(&#039;search-input&#039;, SearchInput);</code></pre>
<h3>Batching Messages</h3>
<p>When publishing multiple related messages, batch them:</p>
<pre><code class="language-javascript">class BulkUpdater extends HTMLElement {
  updateMultipleItems(items) {
    // Bad: publish once per item
    // items.forEach(item =&gt; {
    //   publish(&#039;item.updated&#039;, item);
    // });

    // Good: batch into single message
    publish(&#039;items.updated&#039;, { items });
  }
}</code></pre>
<p>Subscribers process the batch:</p>
<pre><code class="language-javascript">class ItemList extends HTMLElement {
  connectedCallback() {
    this.unsubscribe = subscribe(&#039;items.updated&#039;, (msg) =&gt; {
      // Process entire batch at once
      this.updateItems(msg.data.items);
    });
  }

  updateItems(items) {
    // Batch DOM updates
    const fragment = document.createDocumentFragment();

    items.forEach(item =&gt; {
      const li = document.createElement(&#039;li&#039;);
      li.textContent = item.name;
      fragment.appendChild(li);
    });

    this.querySelector(&#039;ul&#039;).innerHTML = &#039;&#039;;
    this.querySelector(&#039;ul&#039;).appendChild(fragment);
  }
}</code></pre>
<h2>Component Lazy Loading</h2>
<p>Load components only when needed. LARC's autoloader already does this for components near the viewport, but you can optimize further.</p>
<h3>Lazy Loading Off-Screen Components</h3>
<p>Use IntersectionObserver to load components when they approach the viewport:</p>
<pre><code class="language-javascript">// components/lazy-loader.mjs

class LazyLoader extends HTMLElement {
  constructor() {
    super();
    this.loaded = false;
  }

  connectedCallback() {
    const componentName = this.getAttribute(&#039;component&#039;);
    const loadDistance = parseInt(this.getAttribute(&#039;load-distance&#039;) || &#039;600&#039;);

    if (!componentName) {
      console.error(&#039;LazyLoader: component attribute required&#039;);
      return;
    }

    // Observe element
    this.observer = new IntersectionObserver(
      (entries) =&gt; {
        entries.forEach(entry =&gt; {
          if (entry.isIntersecting &amp;&amp; !this.loaded) {
            this.loadComponent(componentName);
          }
        });
      },
      { rootMargin: `${loadDistance}px` }
    );

    this.observer.observe(this);
  }

  async loadComponent(componentName) {
    this.loaded = true;
    this.observer.disconnect();

    try {
      // Show loading state
      this.innerHTML = &#039;&lt;div class=&quot;loading&quot;&gt;Loading...&lt;/div&gt;&#039;;

      // Dynamically import component
      await import(`./components/${componentName}.mjs`);

      // Replace loader with actual component
      const component = document.createElement(componentName);

      // Copy attributes to component
      for (const attr of this.attributes) {
        if (attr.name !== &#039;component&#039; &amp;&amp; attr.name !== &#039;load-distance&#039;) {
          component.setAttribute(attr.name, attr.value);
        }
      }

      this.innerHTML = &#039;&#039;;
      this.appendChild(component);
    } catch (error) {
      console.error(`Failed to load component ${componentName}:`, error);
      this.innerHTML = &#039;&lt;div class=&quot;error&quot;&gt;Failed to load component&lt;/div&gt;&#039;;
    }
  }

  disconnectedCallback() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}

customElements.define(&#039;lazy-loader&#039;, LazyLoader);</code></pre>
<p>Use it:</p>
<pre><code class="language-html">&lt;!-- Component loads when it approaches viewport --&gt;
&lt;lazy-loader component=&quot;heavy-chart&quot; load-distance=&quot;400&quot;&gt;&lt;/lazy-loader&gt;

&lt;!-- Multiple lazy components --&gt;
&lt;lazy-loader component=&quot;user-profile&quot;&gt;&lt;/lazy-loader&gt;
&lt;lazy-loader component=&quot;activity-feed&quot;&gt;&lt;/lazy-loader&gt;
&lt;lazy-loader component=&quot;notifications-panel&quot;&gt;&lt;/lazy-loader&gt;</code></pre>
<h3>Code Splitting Routes</h3>
<p>Split application by routes:</p>
<pre><code class="language-javascript">// components/app-router.mjs

import { subscribe } from &#039;../pan.js&#039;;

class AppRouter extends HTMLElement {
  constructor() {
    super();
    this.currentRoute = null;
    this.loadedComponents = new Set();
  }

  connectedCallback() {
    this.unsubscribe = subscribe(&#039;route.change&#039;, async (msg) =&gt; {
      await this.loadRoute(msg.data.route);
    });
  }

  async loadRoute(route) {
    if (this.currentRoute === route) {
      return;
    }

    this.currentRoute = route;

    // Show loading state
    this.innerHTML = &#039;&lt;div class=&quot;route-loading&quot;&gt;Loading page...&lt;/div&gt;&#039;;

    try {
      // Lazy load route component
      const componentName = this.getComponentForRoute(route);

      if (!this.loadedComponents.has(componentName)) {
        await import(`./pages/${componentName}.mjs`);
        this.loadedComponents.add(componentName);
      }

      // Render route component
      this.innerHTML = `&lt;${componentName}&gt;&lt;/${componentName}&gt;`;
    } catch (error) {
      console.error(`Failed to load route ${route}:`, error);
      this.innerHTML = &#039;&lt;div class=&quot;error&quot;&gt;Page not found&lt;/div&gt;&#039;;
    }
  }

  getComponentForRoute(route) {
    const routeMap = {
      &#039;/&#039;: &#039;home-page&#039;,
      &#039;/profile&#039;: &#039;profile-page&#039;,
      &#039;/settings&#039;: &#039;settings-page&#039;,
      &#039;/dashboard&#039;: &#039;dashboard-page&#039;
    };

    return routeMap[route] || &#039;not-found-page&#039;;
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}

customElements.define(&#039;app-router&#039;, AppRouter);</code></pre>
<h2>Virtual Scrolling for Large Lists</h2>
<p>Rendering thousands of DOM elements is slow. Virtual scrolling renders only visible items.</p>
<p>Here's a robust virtual list implementation:</p>
<pre><code class="language-javascript">// components/virtual-list.mjs

import { subscribe } from &#039;../pan.js&#039;;

class VirtualList extends HTMLElement {
  constructor() {
    super();
    this.items = [];
    this.itemHeight = 50; // Default height
    this.visibleCount = 20;
    this.scrollTop = 0;
    this.startIndex = 0;
    this.endIndex = 20;
    this.containerHeight = 800;
  }

  static get observedAttributes() {
    return [&#039;item-height&#039;, &#039;container-height&#039;];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === &#039;item-height&#039;) {
      this.itemHeight = parseInt(newValue);
    } else if (name === &#039;container-height&#039;) {
      this.containerHeight = parseInt(newValue);
    }

    if (oldValue !== newValue) {
      this.render();
    }
  }

  connectedCallback() {
    const topic = this.getAttribute(&#039;topic&#039;) || &#039;list.items&#039;;

    this.unsubscribe = subscribe(topic, (msg) =&gt; {
      this.items = msg.data.items || [];
      this.render();
    });

    this.render();
  }

  render() {
    // Calculate visible range
    this.visibleCount = Math.ceil(this.containerHeight / this.itemHeight) + 2; // Buffer
    this.startIndex = Math.max(0, Math.floor(this.scrollTop / this.itemHeight) - 1);
    this.endIndex = Math.min(this.items.length, this.startIndex + this.visibleCount);

    const visibleItems = this.items.slice(this.startIndex, this.endIndex);
    const totalHeight = this.items.length * this.itemHeight;
    const offsetY = this.startIndex * this.itemHeight;

    this.innerHTML = `
      &lt;div class=&quot;virtual-list-container&quot; style=&quot;height: ${this.containerHeight}px; overflow-y: auto; position: relative;&quot;&gt;
        &lt;div class=&quot;virtual-list-spacer&quot; style=&quot;height: ${totalHeight}px; position: relative;&quot;&gt;
          &lt;div class=&quot;virtual-list-content&quot; style=&quot;position: absolute; top: ${offsetY}px; width: 100%;&quot;&gt;
            ${this.renderItems(visibleItems)}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;

    // Attach scroll handler
    const container = this.querySelector(&#039;.virtual-list-container&#039;);
    container.addEventListener(&#039;scroll&#039;, this.handleScroll.bind(this));

    // Restore scroll position
    container.scrollTop = this.scrollTop;
  }

  renderItems(items) {
    return items.map((item, index) =&gt; {
      const globalIndex = this.startIndex + index;
      return `
        &lt;div class=&quot;virtual-list-item&quot; style=&quot;height: ${this.itemHeight}px;&quot; data-index=&quot;${globalIndex}&quot;&gt;
          ${this.renderItem(item, globalIndex)}
        &lt;/div&gt;
      `;
    }).join(&#039;&#039;);
  }

  renderItem(item, index) {
    // Override this method to customize item rendering
    return `
      &lt;div style=&quot;padding: 12px; border-bottom: 1px solid #ddd;&quot;&gt;
        &lt;strong&gt;#${index + 1}&lt;/strong&gt;: ${item.name || item.title || JSON.stringify(item)}
      &lt;/div&gt;
    `;
  }

  handleScroll(event) {
    const newScrollTop = event.target.scrollTop;

    // Only re-render if we&#039;ve scrolled enough
    if (Math.abs(newScrollTop - this.scrollTop) &gt; this.itemHeight) {
      this.scrollTop = newScrollTop;
      this.render();
    } else {
      this.scrollTop = newScrollTop;
    }
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}

customElements.define(&#039;virtual-list&#039;, VirtualList);</code></pre>
<p>Use it:</p>
<pre><code class="language-html">&lt;virtual-list
  topic=&quot;users.list&quot;
  item-height=&quot;60&quot;
  container-height=&quot;600&quot;
&gt;&lt;/virtual-list&gt;</code></pre>
<p>Publish items:</p>
<pre><code class="language-javascript">import { publish } from &#039;./pan.js&#039;;

// Generate 10,000 items
const items = Array.from({ length: 10000 }, (_, i) =&gt; ({
  id: i,
  name: `User ${i}`,
  email: `user${i}@example.com`
}));

publish(&#039;users.list&#039;, { items });</code></pre>
<p>The virtual list renders only ~22 items at a time, regardless of whether there are 100 or 100,000 items.</p>
<h3>Dynamic Item Heights</h3>
<p>For variable-height items, maintain a height cache:</p>
<pre><code class="language-javascript">class DynamicVirtualList extends VirtualList {
  constructor() {
    super();
    this.itemHeights = new Map(); // Cache of measured heights
    this.averageHeight = 50;
  }

  render() {
    // Calculate positions using cached heights
    let offsetY = 0;
    let startIndex = 0;

    for (let i = 0; i &lt; this.items.length; i++) {
      const height = this.itemHeights.get(i) || this.averageHeight;

      if (offsetY + height &lt; this.scrollTop) {
        offsetY += height;
        startIndex = i + 1;
      } else if (offsetY &gt; this.scrollTop + this.containerHeight) {
        break;
      }
    }

    this.startIndex = startIndex;
    this.endIndex = Math.min(this.items.length, startIndex + this.visibleCount);

    // Rest of rendering...
    // After rendering, measure actual heights and cache them
    this.measureItemHeights();
  }

  measureItemHeights() {
    requestAnimationFrame(() =&gt; {
      const items = this.querySelectorAll(&#039;.virtual-list-item&#039;);
      items.forEach((item, index) =&gt; {
        const globalIndex = this.startIndex + index;
        const height = item.offsetHeight;
        this.itemHeights.set(globalIndex, height);
      });
    });
  }
}

customElements.define(&#039;dynamic-virtual-list&#039;, DynamicVirtualList);</code></pre>
<h2>Debouncing and Throttling</h2>
<p>We've seen throttling and debouncing briefly. Let's explore them deeply.</p>
<h3>Debounce Utility</h3>
<p>Create a reusable debounce utility:</p>
<pre><code class="language-javascript">// utils/debounce.js

/**
 * Debounce function - waits for delay after last call
 * @param {Function} fn - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} Debounced function
 */
export function debounce(fn, delay) {
  let timeoutId = null;

  const debounced = function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() =&gt; {
      fn.apply(this, args);
    }, delay);
  };

  // Add cancel method
  debounced.cancel = function() {
    clearTimeout(timeoutId);
  };

  return debounced;
}</code></pre>
<p>Use it:</p>
<pre><code class="language-javascript">import { debounce } from &#039;../utils/debounce.js&#039;;

class SearchBox extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `&lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot; /&gt;`;

    const input = this.querySelector(&#039;input&#039;);

    // Debounce search
    const debouncedSearch = debounce((value) =&gt; {
      publish(&#039;search.query&#039;, { query: value });
    }, 300);

    input.addEventListener(&#039;input&#039;, (e) =&gt; {
      debouncedSearch(e.target.value);
    });
  }
}</code></pre>
<h3>Throttle Utility</h3>
<p>Create a reusable throttle utility:</p>
<pre><code class="language-javascript">// utils/throttle.js

/**
 * Throttle function - ensures function runs at most once per interval
 * @param {Function} fn - Function to throttle
 * @param {number} interval - Minimum interval between calls
 * @returns {Function} Throttled function
 */
export function throttle(fn, interval) {
  let lastCall = 0;
  let timeoutId = null;

  const throttled = function(...args) {
    const now = Date.now();
    const timeSinceLastCall = now - lastCall;

    if (timeSinceLastCall &gt;= interval) {
      lastCall = now;
      fn.apply(this, args);
    } else {
      // Schedule call for end of interval
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() =&gt; {
        lastCall = Date.now();
        fn.apply(this, args);
      }, interval - timeSinceLastCall);
    }
  };

  // Add cancel method
  throttled.cancel = function() {
    clearTimeout(timeoutId);
  };

  return throttled;
}</code></pre>
<p>Use it:</p>
<pre><code class="language-javascript">import { throttle } from &#039;../utils/throttle.js&#039;;

class ScrollTracker extends HTMLElement {
  connectedCallback() {
    // Throttle scroll events to 100ms (10 FPS)
    const throttledScroll = throttle(() =&gt; {
      publish(&#039;scroll.position&#039;, {
        x: window.scrollX,
        y: window.scrollY
      });
    }, 100);

    window.addEventListener(&#039;scroll&#039;, throttledScroll);

    this.cleanup = () =&gt; {
      window.removeEventListener(&#039;scroll&#039;, throttledScroll);
    };
  }

  disconnectedCallback() {
    if (this.cleanup) {
      this.cleanup();
    }
  }
}</code></pre>
<h3>RequestAnimationFrame Throttling</h3>
<p>For animation-related events, use requestAnimationFrame:</p>
<pre><code class="language-javascript">class RAFThrottle {
  constructor(callback) {
    this.callback = callback;
    this.rafId = null;
    this.lastArgs = null;
  }

  trigger(...args) {
    this.lastArgs = args;

    if (this.rafId === null) {
      this.rafId = requestAnimationFrame(() =&gt; {
        this.callback.apply(null, this.lastArgs);
        this.rafId = null;
      });
    }
  }

  cancel() {
    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
  }
}</code></pre>
<p>Use it:</p>
<pre><code class="language-javascript">class SmoothScroller extends HTMLElement {
  connectedCallback() {
    this.rafThrottle = new RAFThrottle(() =&gt; {
      publish(&#039;scroll.position&#039;, {
        x: window.scrollX,
        y: window.scrollY
      });
    });

    window.addEventListener(&#039;scroll&#039;, () =&gt; {
      this.rafThrottle.trigger();
    });
  }

  disconnectedCallback() {
    if (this.rafThrottle) {
      this.rafThrottle.cancel();
    }
  }
}</code></pre>
<h2>Memory Management</h2>
<p>JavaScript has garbage collection, but you can still leak memory. Here's how to avoid it.</p>
<h3>Pattern: Clean Up Subscriptions</h3>
<p>Always unsubscribe in <code>disconnectedCallback</code>:</p>
<pre><code class="language-javascript">class LeakFreeComponent extends HTMLElement {
  connectedCallback() {
    this.subscriptions = [
      subscribe(&#039;topic.one&#039;, this.handleOne.bind(this)),
      subscribe(&#039;topic.two&#039;, this.handleTwo.bind(this)),
      subscribe(&#039;topic.three&#039;, this.handleThree.bind(this))
    ];
  }

  disconnectedCallback() {
    // Clean up all subscriptions
    this.subscriptions.forEach(unsub =&gt; unsub());
    this.subscriptions = [];
  }
}</code></pre>
<h3>Pattern: Remove Event Listeners</h3>
<p>Always remove event listeners:</p>
<pre><code class="language-javascript">class ClickTracker extends HTMLElement {
  connectedCallback() {
    this.handleClick = this.handleClick.bind(this);
    this.addEventListener(&#039;click&#039;, this.handleClick);
  }

  handleClick(event) {
    publish(&#039;click.tracked&#039;, { x: event.clientX, y: event.clientY });
  }

  disconnectedCallback() {
    this.removeEventListener(&#039;click&#039;, this.handleClick);
  }
}</code></pre>
<h3>Pattern: Clear Timers</h3>
<p>Clear all timers and intervals:</p>
<pre><code class="language-javascript">class PeriodicUpdater extends HTMLElement {
  connectedCallback() {
    this.intervalId = setInterval(() =&gt; {
      this.update();
    }, 5000);
  }

  disconnectedCallback() {
    clearInterval(this.intervalId);
  }
}</code></pre>
<h3>Pattern: Cancel Pending Promises</h3>
<p>Track and cancel pending async operations:</p>
<pre><code class="language-javascript">class DataFetcher extends HTMLElement {
  constructor() {
    super();
    this.abortController = null;
  }

  async connectedCallback() {
    await this.fetchData();
  }

  async fetchData() {
    // Cancel previous request if still pending
    if (this.abortController) {
      this.abortController.abort();
    }

    this.abortController = new AbortController();

    try {
      const response = await fetch(&#039;/api/data&#039;, {
        signal: this.abortController.signal
      });

      const data = await response.json();
      this.render(data);
    } catch (error) {
      if (error.name === &#039;AbortError&#039;) {
        console.log(&#039;Fetch cancelled&#039;);
      } else {
        console.error(&#039;Fetch failed:&#039;, error);
      }
    }
  }

  disconnectedCallback() {
    if (this.abortController) {
      this.abortController.abort();
    }
  }
}</code></pre>
<h3>Pattern: Weak References for Caches</h3>
<p>Use WeakMap for caches tied to object lifetimes:</p>
<pre><code class="language-javascript">class ComponentCache {
  constructor() {
    this.cache = new WeakMap();
  }

  get(element) {
    return this.cache.get(element);
  }

  set(element, data) {
    this.cache.set(element, data);
  }

  // No need for cleanup - garbage collected automatically
}

const componentCache = new ComponentCache();</code></pre>
<h2>Bundle Size Optimization</h2>
<p>Smaller bundles load faster. Here's how to minimize size.</p>
<h3>1. Tree Shaking</h3>
<p>Ensure your modules are tree-shakeable by using ES6 imports/exports:</p>
<pre><code class="language-javascript">// Good: named exports (tree-shakeable)
export function used() { /* ... */ }
export function unused() { /* ... */ }

// Consumer imports only what they need
import { used } from &#039;./utils.js&#039;;</code></pre>
<h3>2. Dynamic Imports</h3>
<p>Load code on demand:</p>
<pre><code class="language-javascript">class FeatureToggle extends HTMLElement {
  async enableFeature() {
    // Load feature code only when enabled
    const { AdvancedFeature } = await import(&#039;./advanced-feature.js&#039;);

    const feature = new AdvancedFeature();
    feature.activate();
  }
}</code></pre>
<h3>3. Avoid Large Dependencies</h3>
<p>Check dependency sizes before adding them:</p>
<pre><code class="language-bash"># Use bundlephobia to check size
npm install -g bundle-phobia-cli
bundle-phobia moment  # Shows: 231 kB minified</code></pre>
<p>Consider alternatives:</p>
<pre><code class="language-javascript">// Heavy: moment.js (231 kB)
import moment from &#039;moment&#039;;
const date = moment().format(&#039;YYYY-MM-DD&#039;);

// Light: native Intl API (0 kB)
const date = new Intl.DateTimeFormat(&#039;en-CA&#039;).format(new Date());</code></pre>
<h3>4. Code Splitting by Route</h3>
<p>We saw this earlier—split by route:</p>
<pre><code class="language-javascript">// pages/index.js - loads only home page code
export { default as HomePage } from &#039;./home-page.js&#039;;

// pages/dashboard.js - loads only dashboard code
export { default as DashboardPage } from &#039;./dashboard-page.js&#039;;</code></pre>
<h3>5. Minification</h3>
<p>Use a minifier for production:</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;esbuild src/app.js --bundle --minify --outfile=dist/app.js&quot;
  }
}</code></pre>
<h3>6. Compression</h3>
<p>Enable gzip or brotli compression on your server:</p>
<pre><code class="language-javascript">// server.js (Express example)
import compression from &#039;compression&#039;;
import express from &#039;express&#039;;

const app = express();

// Enable compression
app.use(compression());

app.use(express.static(&#039;dist&#039;));</code></pre>
<h2>Performance Monitoring</h2>
<p>Measure performance to know what to optimize:</p>
<pre><code class="language-javascript">// components/performance-monitor.mjs

class PerformanceMonitor extends HTMLElement {
  connectedCallback() {
    // Monitor navigation timing
    this.reportNavigationTiming();

    // Monitor long tasks
    this.observeLongTasks();

    // Monitor message bus performance
    this.monitorMessageBus();
  }

  reportNavigationTiming() {
    window.addEventListener(&#039;load&#039;, () =&gt; {
      const timing = performance.getEntriesByType(&#039;navigation&#039;)[0];

      console.log(&#039;Performance Metrics:&#039;, {
        &#039;DNS Lookup&#039;: `${timing.domainLookupEnd - timing.domainLookupStart}ms`,
        &#039;TCP Connection&#039;: `${timing.connectEnd - timing.connectStart}ms`,
        &#039;Request&#039;: `${timing.responseStart - timing.requestStart}ms`,
        &#039;Response&#039;: `${timing.responseEnd - timing.responseStart}ms`,
        &#039;DOM Processing&#039;: `${timing.domComplete - timing.domLoading}ms`,
        &#039;Total Load Time&#039;: `${timing.loadEventEnd - timing.fetchStart}ms`
      });

      publish(&#039;performance.navigation&#039;, {
        dnsLookup: timing.domainLookupEnd - timing.domainLookupStart,
        connection: timing.connectEnd - timing.connectStart,
        request: timing.responseStart - timing.requestStart,
        response: timing.responseEnd - timing.responseStart,
        domProcessing: timing.domComplete - timing.domLoading,
        totalLoadTime: timing.loadEventEnd - timing.fetchStart
      });
    });
  }

  observeLongTasks() {
    if (&#039;PerformanceObserver&#039; in window) {
      const observer = new PerformanceObserver((list) =&gt; {
        for (const entry of list.getEntries()) {
          console.warn(&#039;Long Task Detected:&#039;, {
            duration: `${entry.duration}ms`,
            startTime: entry.startTime
          });

          publish(&#039;performance.long-task&#039;, {
            duration: entry.duration,
            startTime: entry.startTime
          });
        }
      });

      observer.observe({ entryTypes: [&#039;longtask&#039;] });
    }
  }

  monitorMessageBus() {
    // Wrap publish to measure performance
    const originalPublish = window.publish;

    window.publish = function(topic, data) {
      const start = performance.now();
      const result = originalPublish.call(this, topic, data);
      const duration = performance.now() - start;

      if (duration &gt; 16) { // More than one frame
        console.warn(`Slow message publish: ${topic} took ${duration.toFixed(2)}ms`);
      }

      return result;
    };
  }
}

customElements.define(&#039;performance-monitor&#039;, PerformanceMonitor);</code></pre>
<h2>Wrapping Up</h2>
<p>Performance optimization in LARC applications comes down to a few key principles:</p>
<li><strong>Message efficiency</strong>: Subscribe specifically, unsubscribe aggressively, throttle/debounce high-frequency events</li>
<li><strong>Lazy loading</strong>: Load components and routes only when needed</li>
<li><strong>Virtual scrolling</strong>: Render only visible items for large lists</li>
<li><strong>Memory management</strong>: Clean up subscriptions, listeners, timers, and pending operations</li>
<li><strong>Bundle optimization</strong>: Tree shake, dynamic import, minimize dependencies, compress output</li>
<p>Performance isn't a one-time task—it's ongoing. Profile regularly, measure what matters (user-perceived performance), and optimize the bottlenecks, not the code you think might be slow.</p>
<p>In the next chapter, we'll tackle testing strategies—unit tests, integration tests, E2E tests, and how to test message-driven architectures without losing your mind. Because fast code that doesn't work is still useless.</p>
<p>Now go forth and optimize. And remember: the fastest code is code that never runs. But users expect your app to do something, so optimize the code that does run.</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/backup/building-with-larc-original-20251226/chapter-16-performance-optimization.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
  <pan-bus debug="false"></pan-bus>
  <pan-theme-provider></pan-theme-provider>
</body>
</html>