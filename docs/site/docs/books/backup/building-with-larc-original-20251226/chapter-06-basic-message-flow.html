<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- CRITICAL: Load theme BEFORE CSS to prevent flash -->
  <script src="../../../../../../playground/theme-init.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Basic Message Flow · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Basic Message Flow">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">backup</a> / <a href="#">building-with-larc-original-20251226</a> / <span>chapter-06-basic-message-flow</span>
      </div>
      <article class="docs-content">
        <h1>Basic Message Flow</h1>
<blockquote>"In the beginning was the Message, and the Message was with the Bus, and the Message was the Bus. And the Bus said, 'Let there be publish-subscribe,' and there was publish-subscribe, and it was good—mostly because it avoided callback hell."</blockquote>
>
<blockquote>— The Book of Reactive Programming, Chapter 1, Verse 1</blockquote>
<p>If you've made it through the previous chapters, you now understand the philosophical underpinnings of LARC, its architecture, and how to set up a basic application. But philosophy and architecture don't ship features. Messages do.</p>
<p>In this chapter, we'll dive deep into the beating heart of LARC: the message flow. We'll explore how messages are published, how components subscribe to topics, how to use wildcard patterns to listen for multiple message types at once, and how to clean up after yourself when the party's over. Think of this chapter as your field guide to the PAN bus—the communication backbone that makes LARC applications tick.</p>
<h2>The Anatomy of a Message</h2>
<p>Before we start slinging messages around like a caffeinated postal worker, let's understand what a message actually is in LARC.</p>
<p>A message in LARC is delightfully simple: it's a plain JavaScript object with two required properties:</p>
<pre><code class="language-javascript">{
  topic: &quot;user.login&quot;,
  data: {
    userId: &quot;12345&quot;,
    username: &quot;alice&quot;,
    timestamp: Date.now()
  }
}</code></pre>
<p>That's it. The <code>topic</code> is a string that categorizes the message, and <code>data</code> is whatever payload you want to send along for the ride. This simplicity is intentional—LARC doesn't impose schemas, validation, or type systems on your messages. It trusts you to be a responsible adult (though it secretly hopes you're using TypeScript).</p>
<p>The topic follows a hierarchical naming convention using dots as separators, much like DNS names or Java package names. This convention enables powerful pattern matching, as we'll see shortly.</p>
<h2>Publishing Your First Message</h2>
<p>Publishing a message is as straightforward as calling a function. In fact, it <em>is</em> calling a function:</p>
<pre><code class="language-javascript">import { publish } from &#039;@larc/core&#039;;

// Publish a message
publish(&#039;user.login&#039;, {
  userId: &#039;12345&#039;,
  username: &#039;alice&#039;,
  timestamp: Date.now()
});</code></pre>
<p>When you call <code>publish()</code>, LARC does several things:</p>
<li>It wraps your data in a message envelope with the specified topic</li>
<li>It routes the message to all subscribers interested in that topic</li>
<li>It optionally stores the message for later retrieval (more on this in a moment)</li>
<li>It returns immediately, because publishing is non-blocking</li>
<p>That last point is crucial. Publishing a message doesn't wait for subscribers to process it. It's fire-and-forget, like throwing a message in a bottle into the ocean, except the ocean is your application's memory space and the bottle is a JavaScript object. And unlike real bottles, these arrive instantly—or at least as instantly as the JavaScript event loop allows.</p>
<h3>Publishing from Components</h3>
<p>In most real applications, you'll publish messages from within web components. Here's a more realistic example:</p>
<pre><code class="language-javascript">class LoginForm extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      &lt;form id=&quot;login-form&quot;&gt;
        &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;Username&quot; /&gt;
        &lt;input type=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;Password&quot; /&gt;
        &lt;button type=&quot;submit&quot;&gt;Log In&lt;/button&gt;
      &lt;/form&gt;
    `;

    this.querySelector(&#039;#login-form&#039;).addEventListener(&#039;submit&#039;, (e) =&gt; {
      e.preventDefault();
      this.handleLogin();
    });
  }

  async handleLogin() {
    const username = this.querySelector(&#039;#username&#039;).value;
    const password = this.querySelector(&#039;#password&#039;).value;

    // Publish a login attempt message
    publish(&#039;auth.login.attempt&#039;, { username });

    try {
      const response = await fetch(&#039;/api/login&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify({ username, password })
      });

      if (response.ok) {
        const user = await response.json();

        // Publish success message
        publish(&#039;auth.login.success&#039;, {
          userId: user.id,
          username: user.username,
          roles: user.roles,
          timestamp: Date.now()
        });
      } else {
        // Publish failure message
        publish(&#039;auth.login.failure&#039;, {
          username,
          reason: &#039;Invalid credentials&#039;,
          timestamp: Date.now()
        });
      }
    } catch (error) {
      // Publish error message
      publish(&#039;auth.login.error&#039;, {
        username,
        error: error.message,
        timestamp: Date.now()
      });
    }
  }
}

customElements.define(&#039;login-form&#039;, LoginForm);</code></pre>
<p>Notice how we're publishing multiple messages at different stages of the login process. This granularity gives other parts of the application fine-grained awareness of what's happening. An analytics component might care about login attempts, while a notification component only cares about successes and failures.</p>
<h2>Subscribing to Topics</h2>
<p>Publishing messages into the void is about as useful as shouting into a pillow. To make messages meaningful, you need subscribers—components that listen for specific topics and react accordingly.</p>
<p>Subscribing is just as simple as publishing:</p>
<pre><code class="language-javascript">import { subscribe } from &#039;@larc/core&#039;;

// Subscribe to a topic
const unsubscribe = subscribe(&#039;user.login&#039;, (message) =&gt; {
  console.log(&#039;User logged in:&#039;, message.data);
});</code></pre>
<p>The <code>subscribe()</code> function takes two arguments: a topic pattern and a callback function. When a message matching that pattern is published, your callback is invoked with the message object.</p>
<p>Notice that <code>subscribe()</code> returns a function. That function, conventionally called <code>unsubscribe</code>, removes your subscription when called. More on cleanup later.</p>
<h3>Subscription Example: Notification System</h3>
<p>Let's build a component that displays notifications for authentication events:</p>
<pre><code class="language-javascript">class NotificationCenter extends HTMLElement {
  connectedCallback() {
    this.subscriptions = [];
    this.innerHTML = &#039;&lt;div id=&quot;notifications&quot;&gt;&lt;/div&gt;&#039;;

    // Subscribe to success messages
    this.subscriptions.push(
      subscribe(&#039;auth.login.success&#039;, (msg) =&gt; {
        this.showNotification(
          `Welcome back, ${msg.data.username}!`,
          &#039;success&#039;
        );
      })
    );

    // Subscribe to failure messages
    this.subscriptions.push(
      subscribe(&#039;auth.login.failure&#039;, (msg) =&gt; {
        this.showNotification(
          `Login failed: ${msg.data.reason}`,
          &#039;error&#039;
        );
      })
    );

    // Subscribe to error messages
    this.subscriptions.push(
      subscribe(&#039;auth.login.error&#039;, (msg) =&gt; {
        this.showNotification(
          `An error occurred: ${msg.data.error}`,
          &#039;error&#039;
        );
      })
    );
  }

  showNotification(message, type) {
    const notification = document.createElement(&#039;div&#039;);
    notification.className = `notification notification-${type}`;
    notification.textContent = message;

    this.querySelector(&#039;#notifications&#039;).appendChild(notification);

    // Auto-remove after 5 seconds
    setTimeout(() =&gt; notification.remove(), 5000);
  }

  disconnectedCallback() {
    // Clean up subscriptions
    this.subscriptions.forEach(unsub =&gt; unsub());
  }
}

customElements.define(&#039;notification-center&#039;, NotificationCenter);</code></pre>
<p>This component demonstrates several best practices:</p>
<li><strong>Store unsubscribe functions</strong>: Keep references to all your subscriptions so you can clean them up later</li>
<li><strong>React to messages</strong>: The callback functions update the UI in response to published messages</li>
<li><strong>Clean up in disconnectedCallback</strong>: When the component is removed from the DOM, unsubscribe from all topics</li>
<h2>Wildcard Patterns: The Power of Asterisks</h2>
<p>Subscribing to individual topics is fine for simple cases, but it gets tedious fast. Imagine subscribing to <code>auth.login.success</code>, <code>auth.login.failure</code>, <code>auth.logout.success</code>, <code>auth.logout.failure</code>, <code>auth.refresh.success</code>, <code>auth.refresh.failure</code>—you'd need six separate subscriptions!</p>
<p>Enter wildcard patterns. LARC supports two wildcard characters:</p>
<ul><li><code>*</code> matches a single topic segment</li>
<li><code>**</code> matches zero or more topic segments</li>
</ul>
Here are some examples:
<pre><code class="language-javascript">// Match any auth-related login message
subscribe(&#039;auth.login.*&#039;, (msg) =&gt; {
  console.log(&#039;Login event:&#039;, msg.topic, msg.data);
});

// Match any auth message at any depth
subscribe(&#039;auth.**&#039;, (msg) =&gt; {
  console.log(&#039;Auth event:&#039;, msg.topic, msg.data);
});

// Match any success message for any operation
subscribe(&#039;*.*.success&#039;, (msg) =&gt; {
  console.log(&#039;Success:&#039;, msg.topic, msg.data);
});

// Match all messages (use sparingly!)
subscribe(&#039;**&#039;, (msg) =&gt; {
  console.log(&#039;All messages:&#039;, msg.topic, msg.data);
});</code></pre>
<p>The single asterisk (<code><em></code>) matches exactly one segment. The pattern <code>auth.</em>.success</code> would match <code>auth.login.success</code> and <code>auth.logout.success</code>, but not <code>auth.success</code> (too few segments) or <code>auth.user.login.success</code> (too many segments).</p>
<p>The double asterisk (<code><strong></code>) is greedier. It matches any number of segments, including zero. The pattern <code>auth.</strong></code> matches <code>auth.login</code>, <code>auth.login.success</code>, <code>auth.user.profile.update</code>, and even just <code>auth</code> (though publishing a message with a single-segment topic is unusual).</p>
<h3>Practical Wildcard Example: Audit Logger</h3>
<p>Let's build an audit logger that records all authentication-related activities:</p>
<pre><code class="language-javascript">class AuditLogger extends HTMLElement {
  connectedCallback() {
    this.logs = [];

    // Subscribe to all auth events
    this.unsubscribe = subscribe(&#039;auth.**&#039;, (msg) =&gt; {
      this.logEvent(msg);
    });

    this.render();
  }

  logEvent(msg) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      topic: msg.topic,
      data: msg.data
    };

    this.logs.push(logEntry);

    // Persist to localStorage
    localStorage.setItem(&#039;audit-logs&#039;, JSON.stringify(this.logs));

    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;audit-logger&quot;&gt;
        &lt;h2&gt;Audit Log&lt;/h2&gt;
        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;Timestamp&lt;/th&gt;
              &lt;th&gt;Event&lt;/th&gt;
              &lt;th&gt;Details&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            ${this.logs.map(log =&gt; `
              &lt;tr&gt;
                &lt;td&gt;${log.timestamp}&lt;/td&gt;
                &lt;td&gt;${log.topic}&lt;/td&gt;
                &lt;td&gt;${JSON.stringify(log.data)}&lt;/td&gt;
              &lt;/tr&gt;
            `).join(&#039;&#039;)}
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/div&gt;
    `;
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}

customElements.define(&#039;audit-logger&#039;, AuditLogger);</code></pre>
<p>This component uses <code>auth.**</code> to capture every authentication-related message, regardless of its specific operation or outcome. It's a powerful pattern for cross-cutting concerns like logging, analytics, or debugging.</p>
<h2>Message Retention: The PAN Bus Remembers</h2>
<p>One of the more clever features of LARC's PAN bus is message retention. By default, the PAN bus retains the most recent message for each topic. This means that when a component subscribes to a topic, it immediately receives the last published message, if one exists.</p>
<p>This behavior solves a common problem in reactive systems: the "late subscriber" problem. Imagine a component that displays the current user's profile. If it subscribes to <code>user.profile</code> after the profile has already been loaded, it would normally miss that message and show stale or empty data. With message retention, it gets the current profile immediately upon subscribing.</p>
<p>Here's an example:</p>
<pre><code class="language-javascript">// Somewhere early in the app lifecycle
publish(&#039;user.profile&#039;, {
  userId: &#039;12345&#039;,
  username: &#039;alice&#039;,
  email: &#039;alice@example.com&#039;
});

// Later, a component subscribes
class UserProfile extends HTMLElement {
  connectedCallback() {
    this.unsubscribe = subscribe(&#039;user.profile&#039;, (msg) =&gt; {
      this.render(msg.data);
    });
    // The callback fires immediately with the retained message
  }

  render(profile) {
    this.innerHTML = `
      &lt;div class=&quot;user-profile&quot;&gt;
        &lt;h2&gt;${profile.username}&lt;/h2&gt;
        &lt;p&gt;${profile.email}&lt;/p&gt;
      &lt;/div&gt;
    `;
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}

customElements.define(&#039;user-profile&#039;, UserProfile);</code></pre>
<p>Even though <code>user-profile</code> subscribed after the message was published, it still receives the profile data immediately. This makes components more robust and eliminates race conditions.</p>
<h3>Controlling Retention</h3>
<p>Not all messages should be retained. Ephemeral events like <code>button.clicked</code> or <code>mouse.moved</code> would be pointless to retain—by the time a late subscriber arrives, the event is ancient history.</p>
<p>LARC allows you to control retention on a per-topic basis using a configuration object:</p>
<pre><code class="language-javascript">import { configure } from &#039;@larc/core&#039;;

configure({
  retention: {
    &#039;user.profile&#039;: true,        // Retain
    &#039;user.settings&#039;: true,        // Retain
    &#039;auth.login.attempt&#039;: false,  // Don&#039;t retain
    &#039;mouse.*&#039;: false,             // Don&#039;t retain any mouse events
    &#039;**&#039;: true                    // Default: retain everything else
  }
});</code></pre>
<p>The retention configuration uses the same wildcard pattern matching as subscriptions. More specific patterns override less specific ones.</p>
<h3>Retention Gotchas</h3>
<p>Message retention is powerful, but it has pitfalls:</p>
<li><strong>Memory Usage</strong>: Retained messages live in memory. If you're publishing thousands of unique topics, you'll accumulate thousands of messages. Consider using less granular topics or disabling retention for high-volume streams.</li>
<li><strong>Stale Data</strong>: Retained messages can be stale. If a component subscribes to <code>user.profile</code> but the profile was loaded five minutes ago, is that data still valid? Always consider whether you need to refresh data after receiving a retained message.</li>
<li><strong>Surprising Callbacks</strong>: Because subscriptions fire immediately if a retained message exists, your callback might execute synchronously during the <code>subscribe()</code> call. If your callback manipulates the DOM or performs side effects, ensure the component is fully initialized first.</li>
<h2>Message Ordering and Synchronization</h2>
<p>LARC processes messages synchronously in the order they're published. If you publish three messages in sequence:</p>
<pre><code class="language-javascript">publish(&#039;event.one&#039;, { value: 1 });
publish(&#039;event.two&#039;, { value: 2 });
publish(&#039;event.three&#039;, { value: 3 });</code></pre>
<p>All subscribers will receive them in that exact order: one, two, three. This guarantee simplifies reasoning about message flow and eliminates many race conditions.</p>
<p>However, this guarantee only applies within a single JavaScript execution context. If you publish a message, then await an asynchronous operation, then publish another message, other code may publish messages in between:</p>
<pre><code class="language-javascript">publish(&#039;step.one&#039;, {});
await fetch(&#039;/api/data&#039;); // Other code runs during this await
publish(&#039;step.two&#039;, {});</code></pre>
<p>If you need strict ordering across asynchronous boundaries, consider batching messages or using sequence numbers:</p>
<pre><code class="language-javascript">let sequenceNumber = 0;

async function performOperation() {
  const seq = ++sequenceNumber;

  publish(&#039;operation.start&#039;, { sequence: seq });

  try {
    const result = await doAsyncWork();
    publish(&#039;operation.complete&#039;, { sequence: seq, result });
  } catch (error) {
    publish(&#039;operation.error&#039;, { sequence: seq, error: error.message });
  }
}</code></pre>
<p>Subscribers can then use the sequence number to reorder messages if needed.</p>
<h2>Unsubscribing and Cleanup</h2>
<p>Every <code>subscribe()</code> call returns an unsubscribe function. Calling this function removes the subscription and prevents future messages from triggering the callback:</p>
<pre><code class="language-javascript">const unsubscribe = subscribe(&#039;user.login&#039;, (msg) =&gt; {
  console.log(&#039;User logged in:&#039;, msg.data);
});

// Later, when you&#039;re done listening
unsubscribe();</code></pre>
<p>Failing to unsubscribe is a common source of memory leaks and bugs. If a component subscribes to a topic but never unsubscribes, the callback remains in memory even after the component is removed from the DOM. This keeps the component alive, prevents garbage collection, and may cause the callback to fire unexpectedly.</p>
<h3>Cleanup Patterns</h3>
<p>The most reliable cleanup pattern is to unsubscribe in the component's <code>disconnectedCallback()</code>:</p>
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  connectedCallback() {
    this.unsubscribe = subscribe(&#039;some.topic&#039;, (msg) =&gt; {
      this.handleMessage(msg);
    });
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}</code></pre>
<p>For multiple subscriptions, store them in an array:</p>
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  connectedCallback() {
    this.subscriptions = [
      subscribe(&#039;topic.one&#039;, this.handleOne.bind(this)),
      subscribe(&#039;topic.two&#039;, this.handleTwo.bind(this)),
      subscribe(&#039;topic.three&#039;, this.handleThree.bind(this))
    ];
  }

  disconnectedCallback() {
    this.subscriptions.forEach(unsub =&gt; unsub());
    this.subscriptions = [];
  }
}</code></pre>
<p>Or, if you're feeling fancy, use a helper function:</p>
<pre><code class="language-javascript">class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.subscriptions = new Set();
  }

  subscribe(topic, callback) {
    const unsub = subscribe(topic, callback);
    this.subscriptions.add(unsub);
    return unsub;
  }

  connectedCallback() {
    this.subscribe(&#039;topic.one&#039;, this.handleOne.bind(this));
    this.subscribe(&#039;topic.two&#039;, this.handleTwo.bind(this));
    this.subscribe(&#039;topic.three&#039;, this.handleThree.bind(this));
  }

  disconnectedCallback() {
    this.subscriptions.forEach(unsub =&gt; unsub());
    this.subscriptions.clear();
  }
}</code></pre>
<p>This pattern wraps the <code>subscribe()</code> function and automatically tracks subscriptions, making cleanup effortless.</p>
<h2>Debugging Message Flow</h2>
<p>As your application grows, understanding message flow becomes increasingly important. LARC provides several tools to help debug and visualize messages.</p>
<h3>Console Logging</h3>
<p>The simplest debugging technique is to log all messages:</p>
<pre><code class="language-javascript">subscribe(&#039;**&#039;, (msg) =&gt; {
  console.log(`[${msg.topic}]`, msg.data);
});</code></pre>
<p>This logs every message published in your application. It's noisy, but invaluable when tracking down mysterious bugs or understanding component interactions.</p>
<h3>Conditional Logging</h3>
<p>For more targeted debugging, use patterns:</p>
<pre><code class="language-javascript">// Log only auth-related messages
subscribe(&#039;auth.**&#039;, (msg) =&gt; {
  console.log(`[AUTH] ${msg.topic}`, msg.data);
});

// Log only errors
subscribe(&#039;*.*.error&#039;, (msg) =&gt; {
  console.error(`[ERROR] ${msg.topic}`, msg.data);
});</code></pre>
<h3>Message Inspector Component</h3>
<p>For a more sophisticated approach, build a message inspector component:</p>
<pre><code class="language-javascript">class MessageInspector extends HTMLElement {
  constructor() {
    super();
    this.messages = [];
    this.maxMessages = 100;
    this.filter = &#039;&#039;;
  }

  connectedCallback() {
    this.unsubscribe = subscribe(&#039;**&#039;, (msg) =&gt; {
      this.messages.unshift({
        timestamp: new Date().toISOString(),
        topic: msg.topic,
        data: msg.data
      });

      if (this.messages.length &gt; this.maxMessages) {
        this.messages.pop();
      }

      this.render();
    });

    this.render();
  }

  render() {
    const filteredMessages = this.filter
      ? this.messages.filter(m =&gt; m.topic.includes(this.filter))
      : this.messages;

    this.innerHTML = `
      &lt;div class=&quot;message-inspector&quot;&gt;
        &lt;h2&gt;Message Inspector&lt;/h2&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Filter by topic...&quot;
          value=&quot;${this.filter}&quot;
          id=&quot;filter-input&quot;
        /&gt;
        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;Time&lt;/th&gt;
              &lt;th&gt;Topic&lt;/th&gt;
              &lt;th&gt;Data&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            ${filteredMessages.map(msg =&gt; `
              &lt;tr&gt;
                &lt;td&gt;${msg.timestamp}&lt;/td&gt;
                &lt;td&gt;&lt;code&gt;${msg.topic}&lt;/code&gt;&lt;/td&gt;
                &lt;td&gt;&lt;pre&gt;${JSON.stringify(msg.data, null, 2)}&lt;/pre&gt;&lt;/td&gt;
              &lt;/tr&gt;
            `).join(&#039;&#039;)}
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/div&gt;
    `;

    const input = this.querySelector(&#039;#filter-input&#039;);
    if (input) {
      input.addEventListener(&#039;input&#039;, (e) =&gt; {
        this.filter = e.target.value;
        this.render();
      });
    }
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}

customElements.define(&#039;message-inspector&#039;, MessageInspector);</code></pre>
<p>Add this component to your app during development, and you'll have a real-time view of all message traffic, complete with filtering capabilities.</p>
<h2>Performance Considerations</h2>
<p>The PAN bus is fast, but it's not magic. Publishing messages and invoking callbacks takes time. Here are some guidelines for keeping performance optimal:</p>
<li><strong>Publish sparingly</strong>: Don't publish messages inside tight loops or high-frequency events (like <code>mousemove</code>). If you must, throttle or debounce your publications.</li>
<li><strong>Keep callbacks fast</strong>: Subscriber callbacks are invoked synchronously. If a callback does heavy computation or DOM manipulation, it blocks message processing. Consider deferring work with <code>requestAnimationFrame()</code> or <code>setTimeout()</code>.</li>
<li><strong>Unsubscribe aggressively</strong>: Every active subscription consumes memory and adds overhead to message routing. Unsubscribe as soon as you no longer need messages.</li>
<li><strong>Use specific topics</strong>: Wildcard subscriptions are powerful but expensive. A subscription to <code>**</code> matches every message, so its callback runs for every publication. Use the most specific pattern that meets your needs.</li>
<li><strong>Avoid retained message bloat</strong>: If you have hundreds of unique topics, you'll have hundreds of retained messages. Consider whether retention is necessary for each topic.</li>
<h2>Common Patterns and Anti-Patterns</h2>
<h3>Pattern: Command-Query Separation</h3>
<p>Distinguish between commands (messages that request actions) and events (messages that announce completed actions):</p>
<pre><code class="language-javascript">// Command: requesting an action
publish(&#039;user.profile.update&#039;, { userId: &#039;12345&#039;, name: &#039;Alice&#039; });

// Event: announcing a completed action
publish(&#039;user.profile.updated&#039;, { userId: &#039;12345&#039;, name: &#039;Alice&#039; });</code></pre>
<p>Commands are typically imperatives ("update", "delete", "send"), while events are past tense ("updated", "deleted", "sent"). This distinction makes message flow clearer.</p>
<h3>Pattern: Namespacing</h3>
<p>Use a consistent namespace hierarchy for topics:</p>
<pre><code class="language-javascript">// Good: hierarchical namespacing
publish(&#039;app.user.profile.updated&#039;, { ... });
publish(&#039;app.ui.theme.changed&#039;, { ... });
publish(&#039;app.data.sync.complete&#039;, { ... });

// Bad: flat namespace
publish(&#039;profileUpdated&#039;, { ... });
publish(&#039;themeChanged&#039;, { ... });
publish(&#039;syncComplete&#039;, { ... });</code></pre>
<p>Hierarchical naming enables powerful wildcard subscriptions and makes the codebase easier to navigate.</p>
<h3>Anti-Pattern: Publishing Without Data</h3>
<p>Avoid publishing messages without meaningful data:</p>
<pre><code class="language-javascript">// Bad
publish(&#039;user.login&#039;, {});

// Good
publish(&#039;user.login&#039;, {
  userId: &#039;12345&#039;,
  username: &#039;alice&#039;,
  timestamp: Date.now()
});</code></pre>
<p>Even if subscribers don't currently need the data, they might in the future. Publishing rich data makes messages more useful and reduces the need for additional queries.</p>
<h3>Anti-Pattern: Overloading Topics</h3>
<p>Don't use the same topic for multiple purposes:</p>
<pre><code class="language-javascript">// Bad: same topic, different meanings
publish(&#039;user.action&#039;, { type: &#039;login&#039;, userId: &#039;12345&#039; });
publish(&#039;user.action&#039;, { type: &#039;logout&#039;, userId: &#039;12345&#039; });

// Good: distinct topics
publish(&#039;user.login&#039;, { userId: &#039;12345&#039; });
publish(&#039;user.logout&#039;, { userId: &#039;12345&#039; });</code></pre>
<p>Overloading topics forces subscribers to inspect message data to determine intent, which defeats the purpose of topic-based routing.</p>
<h2>Wrapping Up</h2>
<p>You've now mastered the basics of message flow in LARC. You can publish messages, subscribe to topics, use wildcard patterns, leverage message retention, and clean up subscriptions. These are the fundamental skills you'll use in every LARC application.</p>
<p>In the next chapter, we'll build on this foundation and explore how to create reusable, composable web components that communicate seamlessly via the PAN bus. You'll learn about component lifecycle, Shadow DOM considerations, and patterns for building complex UIs from simple, loosely-coupled components.</p>
<p>But before we move on, take a moment to experiment. Fire up a LARC application, add a <code>message-inspector</code> component, and publish some messages. Watch them flow through the system. Subscribe with different wildcard patterns and see how they match. The best way to internalize these concepts is to play with them.</p>
<p>Remember: messages are the lifeblood of a LARC application. Treat them with care, name them thoughtfully, and they'll reward you with a system that's easy to understand, extend, and debug. And when things inevitably go wrong, you'll have the tools to trace message flow and identify the problem.</p>
<p>Now, onward to components.</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/backup/building-with-larc-original-20251226/chapter-06-basic-message-flow.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
  <pan-bus debug="false"></pan-bus>
  <pan-theme-provider></pan-theme-provider>
</body>
</html>