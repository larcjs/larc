<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- CRITICAL: Load theme BEFORE CSS to prevent flash -->
  <script src="../../../../../../playground/theme-init.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Core Concepts · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - Core Concepts">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">backup</a> / <a href="#">building-with-larc-original-20251226</a> / <span>chapter-04-core-concepts</span>
      </div>
      <article class="docs-content">
        <h1>Core Concepts</h1>
<h2>Introduction: The Building Blocks</h2>
<p>If you're coming from a traditional framework background, LARC might seem... sparse. There's no virtual DOM, no reconciliation algorithm, no elaborate lifecycle methods. What you get instead is something arguably more powerful: a set of composable primitives that work together through a simple, consistent interface.</p>
<p>This chapter covers the core concepts that make LARC tick. If you understand these fundamentals, you'll understand 90% of what you need to build production applications. The remaining 10% is just knowing which components already exist so you don't reinvent the wheel.</p>
<p>Let's start at the heart of it all: the message bus.</p>
<h2>The Message Bus: Your Application's Nervous System</h2>
<h3>What Is a Message Bus?</h3>
<p>Think of the message bus as your application's nervous system. Just as your nervous system carries signals between different parts of your body without those parts needing to know about each other directly, the message bus carries messages between components without creating coupling between them.</p>
<p>Here's the elegant part: the entire bus is just a custom element sitting in your DOM:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;My App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;pan-bus&gt;&lt;/pan-bus&gt;

  &lt;!-- Your app goes here --&gt;
  &lt;my-dashboard&gt;&lt;/my-dashboard&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>That's it. No configuration files, no initialization boilerplate, no plugin registration. The <code><pan-bus></code> element listens for specific DOM events and routes them to interested parties. It's just HTML doing HTML things.</p>
<h3>How Does It Work?</h3>
<p>The bus operates using the browser's built-in event system. Components communicate by dispatching CustomEvents that bubble up through the DOM. The bus catches these events, processes them according to its routing rules, and dispatches delivery events to subscribers.</p>
<p>Here's the beautiful part: because it's all DOM events, it works across shadow DOM boundaries, through iframes (with appropriate setup), and with any framework that can dispatch events—which is to say, all of them.</p>
<p>Let's look at a concrete example:</p>
<pre><code class="language-javascript">// Component A publishes a message
document.dispatchEvent(new CustomEvent(&#039;pan:publish&#039;, {
  detail: {
    topic: &#039;user.logged-in&#039;,
    data: { userId: &#039;123&#039;, name: &#039;Alice&#039; }
  },
  bubbles: true,
  composed: true
}));

// Component B subscribes and receives it
document.addEventListener(&#039;pan:deliver&#039;, (e) =&gt; {
  if (e.detail.topic === &#039;user.logged-in&#039;) {
    console.log(&#039;User logged in:&#039;, e.detail.data.name);
  }
});</code></pre>
<p>But typing out CustomEvent constructors gets tedious fast. That's why LARC provides the PanClient helper:</p>
<pre><code class="language-javascript">import { PanClient } from &#039;@larc-app/core&#039;;

const client = new PanClient();
await client.ready();

// Publishing is now simple
client.publish({
  topic: &#039;user.logged-in&#039;,
  data: { userId: &#039;123&#039;, name: &#039;Alice&#039; }
});

// So is subscribing
client.subscribe(&#039;user.logged-in&#039;, (msg) =&gt; {
  console.log(&#039;User logged in:&#039;, msg.data.name);
});</code></pre>
<p>Much better. But we can do more.</p>
<h3>Configuration and Capabilities</h3>
<p>The <code><pan-bus></code> element accepts configuration through attributes:</p>
<pre><code class="language-html">&lt;pan-bus
  max-retained=&quot;1000&quot;
  max-message-size=&quot;1048576&quot;
  debug=&quot;true&quot;
  allow-global-wildcard=&quot;false&quot;&gt;
&lt;/pan-bus&gt;</code></pre>
<p>These settings control memory usage, security policies, and debugging output. In production, you'll want to tune these based on your app's needs. During development, <code>debug="true"</code> is invaluable for understanding message flow.</p>
<p>The bus also tracks statistics:</p>
<pre><code class="language-javascript">// Request stats
const response = await client.request(&#039;pan:sys.stats&#039;, {});
console.log(response.data);
// {
//   published: 1234,
//   delivered: 5678,
//   dropped: 0,
//   retained: 42,
//   subscriptions: 18,
//   clients: 5
// }</code></pre>
<p>These metrics help you understand your application's communication patterns and spot potential performance issues before they become problems.</p>
<h2>Pub/Sub Pattern: Fire and Forget (But Don't Actually Forget)</h2>
<h3>The Classic Pattern</h3>
<p>Publish/subscribe (pub/sub) is the bread and butter of message-based architectures. A component publishes a message about something that happened. Other components subscribe to messages they care about. Neither knows the other exists.</p>
<p>Here's a real-world example from an e-commerce app:</p>
<pre><code class="language-javascript">// Shopping cart component
class ShoppingCart extends HTMLElement {
  connectedCallback() {
    this.client = new PanClient(this);
    this.render();
  }

  async addItem(product) {
    this.items.push(product);

    // Tell the world what happened
    this.client.publish({
      topic: &#039;cart.item-added&#039;,
      data: {
        productId: product.id,
        name: product.name,
        price: product.price,
        quantity: 1
      }
    });

    this.render();
  }
}</code></pre>
<p>Now, anywhere in your application, components can react to items being added to the cart:</p>
<pre><code class="language-javascript">// Notification badge component
class CartBadge extends HTMLElement {
  connectedCallback() {
    this.client = new PanClient(this);
    this.count = 0;
    this.render();

    // Listen for cart changes
    this.client.subscribe(&#039;cart.item-added&#039;, () =&gt; {
      this.count++;
      this.render();
    });

    this.client.subscribe(&#039;cart.item-removed&#039;, () =&gt; {
      this.count--;
      this.render();
    });
  }
}

// Analytics component
class AnalyticsTracker extends HTMLElement {
  connectedCallback() {
    this.client = new PanClient(this);

    this.client.subscribe(&#039;cart.*&#039;, (msg) =&gt; {
      // Send to analytics service
      this.trackEvent(msg.topic, msg.data);
    });
  }

  trackEvent(action, data) {
    // Send to your analytics provider
    console.log(&#039;Analytics:&#039;, action, data);
  }
}</code></pre>
<p>Notice how neither the cart badge nor the analytics tracker needed to be registered anywhere or injected with dependencies. They just listen for messages they care about. Add them to the DOM, and they work. Remove them, and they stop working. No cleanup code needed (the bus automatically removes dead subscriptions).</p>
<h3>Wildcards: Subscribe to Patterns</h3>
<p>One of the most powerful features of LARC's pub/sub system is pattern matching. Instead of subscribing to individual topics, you can subscribe to patterns:</p>
<pre><code class="language-javascript">// Subscribe to all cart-related messages
client.subscribe(&#039;cart.*&#039;, (msg) =&gt; {
  console.log(&#039;Cart event:&#039;, msg.topic, msg.data);
});

// Subscribe to all user-related messages
client.subscribe(&#039;users.*&#039;, (msg) =&gt; {
  console.log(&#039;User event:&#039;, msg.topic, msg.data);
});

// Subscribe to everything (use sparingly!)
client.subscribe(&#039;*&#039;, (msg) =&gt; {
  console.log(&#039;Any event:&#039;, msg.topic, msg.data);
});</code></pre>
<p>The wildcard <code><em></code> matches any segment of a topic. So <code>cart.</em></code> matches <code>cart.item-added</code> and <code>cart.checkout-started</code>, but not <code>cart.items.updated</code> (which has multiple segments after <code>cart</code>).</p>
<p>This makes it trivial to build components that react to entire categories of events without knowing the specific topics ahead of time.</p>
<h3>The Global Wildcard Problem</h3>
<p>You might be wondering: "What about security? Can any component spy on all messages?"</p>
<p>Yes, by default. That's actually intentional for most applications—it makes debugging and monitoring much easier. But for sensitive applications, you can disable the global wildcard:</p>
<pre><code class="language-html">&lt;pan-bus allow-global-wildcard=&quot;false&quot;&gt;&lt;/pan-bus&gt;</code></pre>
<p>Now attempts to subscribe to <code><em></code> will be rejected. Components can still use specific wildcards like <code>users.</em></code>, just not the nuclear option.</p>
<h2>Topics and Routing: Addressing Your Messages</h2>
<h3>Naming Conventions</h3>
<p>Topics in LARC follow a hierarchical naming convention similar to DNS or Java packages. The convention is:</p>
<pre><code class="language-plaintext">entity.resource.action</code></pre>
<p>For example:</p>
<ul><li><code>users.list.state</code> - The current state of the user list</li>
<li><code>users.item.save</code> - Request to save a user item</li>
<li><code>cart.checkout.started</code> - Notification that checkout has started</li>
<li><code>api.users.error</code> - Error from the users API</li>
</ul>
This hierarchy serves two purposes:
<li><strong>Organization</strong>: It groups related topics together</li>
<li><strong>Routing</strong>: It enables wildcard subscriptions and routing rules</li>
<p>Here are some real-world examples:</p>
<pre><code class="language-javascript">// State management topics
&#039;users.list.state&#039;      // Current list of users
&#039;users.filter.state&#039;    // Current filter settings
&#039;users.pagination.state&#039; // Current page/offset

// Action topics
&#039;users.item.save&#039;       // Save a user
&#039;users.item.delete&#039;     // Delete a user
&#039;users.list.refresh&#039;    // Refresh the list

// Event topics
&#039;users.item.saved&#039;      // User was saved
&#039;users.item.deleted&#039;    // User was deleted
&#039;users.list.changed&#039;    // List has changed

// API topics
&#039;api.users.request&#039;     // API request initiated
&#039;api.users.success&#039;     // API request succeeded
&#039;api.users.error&#039;       // API request failed</code></pre>
<h3>Semantic Routing</h3>
<p>The beauty of hierarchical topics is that you can build semantic routing rules. For example, you might want to:</p>
<li>Log all API errors to your monitoring service</li>
<li>Cache all <code>*.state</code> messages for new components</li>
<li>Persist all <code>*.settings</code> changes to localStorage</li>
<li>Throttle high-frequency UI events</li>
<p>LARC's routing system (enabled with <code>enable-routing="true"</code>) lets you configure these behaviors declaratively. But even without routing, the topic structure helps you reason about message flow.</p>
<h3>Anti-Patterns to Avoid</h3>
<p>Some topic naming patterns to avoid:</p>
<strong>Too Generic:</strong>
<pre><code class="language-javascript">// Bad: What user? What data?
&#039;update&#039;
&#039;change&#039;
&#039;event&#039;

// Good: Specific and hierarchical
&#039;users.item.updated&#039;
&#039;settings.theme.changed&#039;
&#039;cart.item-added&#039;</code></pre>
<strong>Too Specific:</strong>
<pre><code class="language-javascript">// Bad: Can&#039;t subscribe to patterns
&#039;user-123-updated&#039;
&#039;product-abc-added-to-cart&#039;

// Good: Use data payload for specifics
&#039;users.item.updated&#039;  // data: { userId: &#039;123&#039; }
&#039;cart.item-added&#039;     // data: { productId: &#039;abc&#039; }</code></pre>
<strong>Mixed Concerns:</strong>
<pre><code class="language-javascript">// Bad: Mixing entity types
&#039;users-and-posts.updated&#039;

// Good: Separate topics
&#039;users.item.updated&#039;
&#039;posts.item.updated&#039;</code></pre>
<h2>Message Lifecycle: Birth, Death, and Resurrection</h2>
<h3>The Lifecycle of a Message</h3>
<p>When you publish a message, it goes through several stages:</p>
<li><strong>Creation</strong>: You publish the message via <code>client.publish()</code></li>
<li><strong>Validation</strong>: The bus validates message size and serializability</li>
<li><strong>Enrichment</strong>: The bus adds metadata (id, timestamp)</li>
<li><strong>Routing</strong>: The bus applies routing rules (if enabled)</li>
<li><strong>Delivery</strong>: The bus dispatches to all matching subscribers</li>
<li><strong>Retention</strong>: If marked <code>retain: true</code>, the message is cached</li>
<li><strong>Cleanup</strong>: After delivery, the message object is eligible for GC</li>
<p>Let's look at each stage in detail.</p>
<h3>Message Structure</h3>
<p>A complete message has this shape:</p>
<pre><code class="language-javascript">{
  topic: &#039;users.item.saved&#039;,        // Required: hierarchical topic
  data: { id: &#039;123&#039;, name: &#039;Alice&#039; }, // Required: the payload
  id: &#039;a1b2c3d4-...&#039;,               // Auto-generated UUID
  ts: 1698765432000,                 // Auto-generated timestamp
  retain: true,                      // Optional: cache this message
  replyTo: &#039;pan:$reply:...&#039;,        // Optional: for request/reply
  correlationId: &#039;req-123&#039;,         // Optional: for correlation
  headers: {                         // Optional: custom metadata
    &#039;x-user-id&#039;: &#039;123&#039;,
    &#039;x-trace-id&#039;: &#039;abc-def&#039;
  }
}</code></pre>
<p>You only provide <code>topic</code> and <code>data</code>. The bus fills in the rest.</p>
<h3>Validation and Size Limits</h3>
<p>The bus validates messages before processing them:</p>
<pre><code class="language-javascript">// This will be rejected
client.publish({
  topic: &#039;users.item.save&#039;,
  data: {
    name: &#039;Alice&#039;,
    profilePicture: gigabyteSizedBinaryBlob  // Too large!
  }
});</code></pre>
<p>Default limits:</p>
<ul><li>Max message size: 1MB</li>
<li>Max payload size: 512KB</li>
</ul>
Why two limits? The message size includes metadata, headers, and the payload. The payload limit is separate because payloads are what users control.
<p>If you need to send large data, don't send it through the bus. Instead, send a reference:</p>
<pre><code class="language-javascript">// Good: Send a reference
client.publish({
  topic: &#039;upload.completed&#039;,
  data: {
    fileId: &#039;abc-123&#039;,
    url: &#039;/api/files/abc-123&#039;,
    size: 10485760,  // 10MB
    type: &#039;image/jpeg&#039;
  }
});</code></pre>
<h3>Retained Messages: The Last Value Cache</h3>
<p>One of the most useful features of the message bus is message retention. When you publish a message with <code>retain: true</code>, the bus caches it:</p>
<pre><code class="language-javascript">// Publish current state
client.publish({
  topic: &#039;users.list.state&#039;,
  data: { users: [...], total: 100 },
  retain: true
});</code></pre>
<p>Now when a component subscribes to <code>users.list.state</code>, it immediately receives the last published value. This is perfect for state synchronization:</p>
<pre><code class="language-javascript">// New component gets current state immediately
class UserList extends HTMLElement {
  connectedCallback() {
    this.client = new PanClient(this);

    // Request retained messages
    this.client.subscribe(&#039;users.list.state&#039;, (msg) =&gt; {
      this.users = msg.data.users;
      this.render();
    }, { retained: true });  // &lt;- This is the key
  }
}</code></pre>
<p>The component doesn't need to know how to fetch the initial state. It doesn't need to make an API call. It just asks for retained messages and gets the current state instantly.</p>
<h3>Memory Management</h3>
<p>The bus limits retained messages to prevent memory leaks. By default, it keeps 1000 retained messages using an LRU (Least Recently Used) eviction policy. When the limit is reached, the oldest unused message is evicted.</p>
<p>You can tune this:</p>
<pre><code class="language-html">&lt;pan-bus max-retained=&quot;5000&quot;&gt;&lt;/pan-bus&gt;</code></pre>
<p>But be careful. Retained messages live in memory for the lifetime of the page. If you're retaining large objects or high-frequency updates, you can consume significant memory.</p>
<p>A good rule of thumb: only retain state snapshots, not events.</p>
<pre><code class="language-javascript">// Good: Retain state
client.publish({
  topic: &#039;users.list.state&#039;,
  data: { users: [...] },
  retain: true
});

// Bad: Don&#039;t retain events
client.publish({
  topic: &#039;users.item.clicked&#039;,  // Ephemeral event
  data: { userId: &#039;123&#039; },
  retain: false  // or just omit it
});</code></pre>
<h2>Components and Composition: Building Blocks</h2>
<h3>What Is a Component in LARC?</h3>
<p>In LARC, a component is just a Web Component—a custom element that follows the W3C standard. No special base class, no framework-specific lifecycle methods. Just plain JavaScript classes extending <code>HTMLElement</code>:</p>
<pre><code class="language-javascript">class UserCard extends HTMLElement {
  connectedCallback() {
    // Element was added to DOM
    this.client = new PanClient(this);
    this.render();
  }

  disconnectedCallback() {
    // Element was removed from DOM
    // (PanClient automatically cleans up subscriptions)
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;user-card&quot;&gt;
        &lt;h3&gt;${this.getAttribute(&#039;name&#039;)}&lt;/h3&gt;
        &lt;p&gt;${this.getAttribute(&#039;email&#039;)}&lt;/p&gt;
      &lt;/div&gt;
    `;
  }
}

customElements.define(&#039;user-card&#039;, UserCard);</code></pre>
<p>Use it like any HTML element:</p>
<pre><code class="language-html">&lt;user-card name=&quot;Alice&quot; email=&quot;alice@example.com&quot;&gt;&lt;/user-card&gt;</code></pre>
<h3>Communication Patterns</h3>
<p>Components in LARC communicate through three primary patterns:</p>
<strong>1. Attributes (Parent -> Child)</strong>
<p>The standard HTML way. Parent sets attributes, child reads them:</p>
<pre><code class="language-html">&lt;user-card user-id=&quot;123&quot;&gt;&lt;/user-card&gt;</code></pre>
<pre><code class="language-javascript">class UserCard extends HTMLElement {
  static get observedAttributes() {
    return [&#039;user-id&#039;];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === &#039;user-id&#039;) {
      this.loadUser(newValue);
    }
  }
}</code></pre>
<strong>2. Events (Child -> Parent)</strong>
<p>Components dispatch events to notify parents of changes:</p>
<pre><code class="language-javascript">class UserCard extends HTMLElement {
  handleClick() {
    this.dispatchEvent(new CustomEvent(&#039;user-selected&#039;, {
      detail: { userId: this.userId },
      bubbles: true
    }));
  }
}</code></pre>
<pre><code class="language-javascript">// Parent listens
document.querySelector(&#039;user-card&#039;).addEventListener(&#039;user-selected&#039;, (e) =&gt; {
  console.log(&#039;User selected:&#039;, e.detail.userId);
});</code></pre>
<strong>3. Messages (Anyone -> Anyone)</strong>
<p>For cross-cutting concerns, use the message bus:</p>
<pre><code class="language-javascript">class UserCard extends HTMLElement {
  connectedCallback() {
    this.client = new PanClient(this);

    // Listen for updates to this user
    this.client.subscribe(&#039;users.item.updated&#039;, (msg) =&gt; {
      if (msg.data.id === this.userId) {
        this.update(msg.data);
      }
    });
  }

  handleSave() {
    // Notify the world
    this.client.publish({
      topic: &#039;users.item.updated&#039;,
      data: { id: this.userId, ...this.getData() }
    });
  }
}</code></pre>
<h3>Composition Examples</h3>
<p>Here's how components compose in practice:</p>
<pre><code class="language-html">&lt;!-- Dashboard composed of smaller components --&gt;
&lt;user-dashboard&gt;
  &lt;header-bar&gt;
    &lt;user-menu&gt;&lt;/user-menu&gt;
    &lt;notification-badge&gt;&lt;/notification-badge&gt;
  &lt;/header-bar&gt;

  &lt;main-content&gt;
    &lt;user-list&gt;
      &lt;!-- user-card elements will be inserted here --&gt;
    &lt;/user-list&gt;

    &lt;user-details&gt;
      &lt;!-- Details shown when user is selected --&gt;
    &lt;/user-details&gt;
  &lt;/main-content&gt;
&lt;/user-dashboard&gt;</code></pre>
<p>Each component is independent. The <code><user-menu></code> publishes <code>user.logged-out</code> when the user logs out. The <code><user-list></code> subscribes to that message and clears itself. No direct coupling needed.</p>
<h3>The Autoloader: Zero-Config Imports</h3>
<p>One of LARC's killer features is the autoloader. Instead of explicitly importing every component:</p>
<pre><code class="language-javascript">// Traditional way (tedious!)
import &#039;./user-dashboard.js&#039;;
import &#039;./header-bar.js&#039;;
import &#039;./user-menu.js&#039;;
import &#039;./notification-badge.js&#039;;
import &#039;./main-content.js&#039;;
import &#039;./user-list.js&#039;;
import &#039;./user-details.js&#039;;</code></pre>
<p>Just load the autoloader and use components:</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot; src=&quot;/core/pan.mjs&quot;&gt;&lt;/script&gt;

&lt;!-- Components load automatically when used --&gt;
&lt;user-dashboard&gt;&lt;/user-dashboard&gt;</code></pre>
<p>The autoloader uses IntersectionObserver to progressively load components as they approach the viewport. Components not in view aren't loaded until needed, saving bandwidth and parse time.</p>
<h2>State Management Strategies</h2>
<h3>The Three Flavors of State</h3>
<p>State in LARC comes in three flavors:</p>
<li><strong>Local State</strong>: Confined to a single component</li>
<li><strong>Shared State</strong>: Accessed by multiple components</li>
<li><strong>Persistent State</strong>: Survives page reloads</li>
<p>Let's tackle each one.</p>
<h3>Local State: Keep It Simple</h3>
<p>For state that only matters to one component, use instance variables:</p>
<pre><code class="language-javascript">class Counter extends HTMLElement {
  constructor() {
    super();
    this.count = 0;  // Local state
  }

  increment() {
    this.count++;
    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;button onclick=&quot;this.parentElement.increment()&quot;&gt;
        Count: ${this.count}
      &lt;/button&gt;
    `;
  }
}</code></pre>
<p>No store needed. No reducers. Just regular JavaScript variables.</p>
<h3>Shared State: Use Retained Messages</h3>
<p>When multiple components need the same state, publish it as a retained message:</p>
<pre><code class="language-javascript">// Producer: Publishes state
class UserListProvider extends HTMLElement {
  async connectedCallback() {
    this.client = new PanClient(this);

    // Load users
    const users = await this.fetchUsers();

    // Publish as retained state
    this.client.publish({
      topic: &#039;users.list.state&#039;,
      data: { users },
      retain: true
    });
  }

  async fetchUsers() {
    const response = await fetch(&#039;/api/users&#039;);
    return response.json();
  }
}

// Consumer: Subscribes to state
class UserList extends HTMLElement {
  connectedCallback() {
    this.client = new PanClient(this);

    this.client.subscribe(&#039;users.list.state&#039;, (msg) =&gt; {
      this.users = msg.data.users;
      this.render();
    }, { retained: true });  // Get current value immediately
  }
}

// Another consumer: Also subscribes
class UserCount extends HTMLElement {
  connectedCallback() {
    this.client = new PanClient(this);

    this.client.subscribe(&#039;users.list.state&#039;, (msg) =&gt; {
      this.count = msg.data.users.length;
      this.render();
    }, { retained: true });
  }
}</code></pre>
<p>All three components are decoupled. The provider doesn't know about the consumers. The consumers don't know about each other. They just agree on a topic name.</p>
<h3>The State Publisher Pattern</h3>
<p>For complex state, create dedicated state publisher components:</p>
<pre><code class="language-javascript">class ShoppingCartState extends HTMLElement {
  connectedCallback() {
    this.client = new PanClient(this);
    this.items = [];

    // Listen for state changes
    this.client.subscribe(&#039;cart.item.add&#039;, (msg) =&gt; {
      this.items.push(msg.data);
      this.publishState();
    });

    this.client.subscribe(&#039;cart.item.remove&#039;, (msg) =&gt; {
      this.items = this.items.filter(i =&gt; i.id !== msg.data.id);
      this.publishState();
    });

    this.client.subscribe(&#039;cart.clear&#039;, () =&gt; {
      this.items = [];
      this.publishState();
    });

    // Publish initial state
    this.publishState();
  }

  publishState() {
    this.client.publish({
      topic: &#039;cart.state&#039;,
      data: {
        items: this.items,
        total: this.calculateTotal(),
        count: this.items.length
      },
      retain: true
    });
  }

  calculateTotal() {
    return this.items.reduce((sum, item) =&gt; sum + item.price, 0);
  }
}</code></pre>
<p>Now any component can:</p>
<ul><li>Read the cart state by subscribing to <code>cart.state</code></li>
<li>Modify the cart by publishing to <code>cart.item.add</code>, <code>cart.item.remove</code>, etc.</li>
</ul>
The state component acts as a single source of truth, similar to a Redux store, but without the boilerplate.
<h3>Persistent State: Add Storage</h3>
<p>For state that should survive page reloads, use the <code><pan-storage></code> component:</p>
<pre><code class="language-javascript">// Automatically persists to localStorage
class SettingsState extends HTMLElement {
  connectedCallback() {
    this.client = new PanClient(this);

    // Load from storage
    const stored = localStorage.getItem(&#039;settings&#039;);
    this.settings = stored ? JSON.parse(stored) : this.getDefaults();

    this.publishState();

    // Listen for changes
    this.client.subscribe(&#039;settings.update&#039;, (msg) =&gt; {
      this.settings = { ...this.settings, ...msg.data };
      this.save();
      this.publishState();
    });
  }

  save() {
    localStorage.setItem(&#039;settings&#039;, JSON.stringify(this.settings));
  }

  publishState() {
    this.client.publish({
      topic: &#039;settings.state&#039;,
      data: this.settings,
      retain: true
    });
  }

  getDefaults() {
    return {
      theme: &#039;light&#039;,
      language: &#039;en&#039;,
      notifications: true
    };
  }
}</code></pre>
<p>Or use LARC's built-in <code><pan-storage></code> component which handles persistence automatically:</p>
<pre><code class="language-html">&lt;pan-storage
  key=&quot;settings&quot;
  topic=&quot;settings.state&quot;
  storage=&quot;localStorage&quot;&gt;
&lt;/pan-storage&gt;</code></pre>
<p>Now any updates to <code>settings.state</code> are automatically persisted.</p>
<h2>Event Envelopes and Metadata</h2>
<h3>The Message Envelope</h3>
<p>Every message is wrapped in an envelope that carries metadata:</p>
<pre><code class="language-javascript">{
  topic: &#039;users.item.saved&#039;,
  data: { id: &#039;123&#039;, name: &#039;Alice&#039; },
  id: &#039;a1b2c3d4-5678-90ab-cdef-1234567890ab&#039;,
  ts: 1698765432000,
  headers: {
    &#039;x-user-id&#039;: &#039;123&#039;,
    &#039;x-trace-id&#039;: &#039;trace-abc-def&#039;
  }
}</code></pre>
<h3>Message IDs</h3>
<p>Every message gets a unique ID (UUID v4). This enables:</p>
<li><strong>Deduplication</strong>: Ignore messages you've already processed</li>
<li><strong>Tracing</strong>: Track messages through your system</li>
<li><strong>Debugging</strong>: Identify specific messages in logs</li>
<pre><code class="language-javascript">// Track processed messages
class DeduplicatingSubscriber extends HTMLElement {
  constructor() {
    super();
    this.processed = new Set();
  }

  connectedCallback() {
    this.client = new PanClient(this);

    this.client.subscribe(&#039;events.*&#039;, (msg) =&gt; {
      if (this.processed.has(msg.id)) {
        console.log(&#039;Duplicate message, ignoring:&#039;, msg.id);
        return;
      }

      this.processed.add(msg.id);
      this.process(msg);
    });
  }
}</code></pre>
<h3>Timestamps</h3>
<p>Messages include a timestamp (milliseconds since epoch). Use it for:</p>
<li><strong>Ordering</strong>: Process messages in chronological order</li>
<li><strong>TTL</strong>: Ignore stale messages</li>
<li><strong>Metrics</strong>: Measure message latency</li>
<pre><code class="language-javascript">// Ignore stale messages
this.client.subscribe(&#039;stock.price.updated&#039;, (msg) =&gt; {
  const age = Date.now() - msg.ts;

  if (age &gt; 5000) {  // More than 5 seconds old
    console.log(&#039;Ignoring stale price update&#039;);
    return;
  }

  this.updatePrice(msg.data);
});</code></pre>
<h3>Custom Headers</h3>
<p>Add your own metadata with headers:</p>
<pre><code class="language-javascript">client.publish({
  topic: &#039;api.request&#039;,
  data: { endpoint: &#039;/users&#039; },
  headers: {
    &#039;x-user-id&#039;: currentUser.id,
    &#039;x-trace-id&#039;: traceId,
    &#039;x-request-id&#039;: requestId
  }
});</code></pre>
<p>Headers are perfect for:</p>
<ul><li>Correlation across service boundaries</li>
<li>User context for multi-tenant systems</li>
<li>Debugging and tracing</li>
<li>Custom routing rules</li>
</ul>
<h3>The Request/Reply Pattern</h3>
<p>The envelope supports request/reply with <code>replyTo</code> and <code>correlationId</code>:</p>
<pre><code class="language-javascript">// Under the hood, client.request() does this:
const correlationId = crypto.randomUUID();
const replyTo = `pan:$reply:${clientId}:${correlationId}`;

// Publish request
client.publish({
  topic: &#039;users.get&#039;,
  data: { id: &#039;123&#039; },
  replyTo,
  correlationId
});

// Subscribe to reply
client.subscribe(replyTo, (msg) =&gt; {
  if (msg.correlationId === correlationId) {
    console.log(&#039;Got reply:&#039;, msg.data);
  }
});</code></pre>
<p>But you don't need to do this manually. Just use <code>client.request()</code>:</p>
<pre><code class="language-javascript">const response = await client.request(&#039;users.get&#039;, { id: &#039;123&#039; });
console.log(&#039;User:&#039;, response.data);</code></pre>
<p>The client handles correlation automatically and returns a Promise that resolves with the reply or rejects on timeout.</p>
<h2>Putting It All Together</h2>
<p>Let's build a complete example that demonstrates all these concepts:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Task Manager&lt;/title&gt;
  &lt;script type=&quot;module&quot; src=&quot;/core/pan.mjs&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;pan-bus debug=&quot;true&quot;&gt;&lt;/pan-bus&gt;

  &lt;task-app&gt;
    &lt;task-form&gt;&lt;/task-form&gt;
    &lt;task-list&gt;&lt;/task-list&gt;
    &lt;task-stats&gt;&lt;/task-stats&gt;
  &lt;/task-app&gt;

  &lt;script type=&quot;module&quot;&gt;
    import { PanClient } from &#039;/core/pan-client.mjs&#039;;

    // Task state manager
    class TaskState extends HTMLElement {
      connectedCallback() {
        this.client = new PanClient(this);
        this.tasks = [];

        // Listen for task operations
        this.client.subscribe(&#039;tasks.add&#039;, (msg) =&gt; {
          this.tasks.push({
            id: crypto.randomUUID(),
            ...msg.data,
            completed: false,
            createdAt: Date.now()
          });
          this.publishState();
        });

        this.client.subscribe(&#039;tasks.toggle&#039;, (msg) =&gt; {
          const task = this.tasks.find(t =&gt; t.id === msg.data.id);
          if (task) {
            task.completed = !task.completed;
            this.publishState();
          }
        });

        this.client.subscribe(&#039;tasks.delete&#039;, (msg) =&gt; {
          this.tasks = this.tasks.filter(t =&gt; t.id !== msg.data.id);
          this.publishState();
        });

        // Publish initial state
        this.publishState();
      }

      publishState() {
        this.client.publish({
          topic: &#039;tasks.state&#039;,
          data: {
            tasks: this.tasks,
            total: this.tasks.length,
            completed: this.tasks.filter(t =&gt; t.completed).length,
            pending: this.tasks.filter(t =&gt; !t.completed).length
          },
          retain: true
        });
      }
    }

    // Task form
    class TaskForm extends HTMLElement {
      connectedCallback() {
        this.client = new PanClient(this);
        this.render();
      }

      render() {
        this.innerHTML = `
          &lt;form&gt;
            &lt;input type=&quot;text&quot; id=&quot;title&quot; placeholder=&quot;Task title&quot; required&gt;
            &lt;button type=&quot;submit&quot;&gt;Add Task&lt;/button&gt;
          &lt;/form&gt;
        `;

        this.querySelector(&#039;form&#039;).addEventListener(&#039;submit&#039;, (e) =&gt; {
          e.preventDefault();
          const title = this.querySelector(&#039;#title&#039;).value;

          this.client.publish({
            topic: &#039;tasks.add&#039;,
            data: { title }
          });

          this.querySelector(&#039;#title&#039;).value = &#039;&#039;;
        });
      }
    }

    // Task list
    class TaskList extends HTMLElement {
      connectedCallback() {
        this.client = new PanClient(this);

        this.client.subscribe(&#039;tasks.state&#039;, (msg) =&gt; {
          this.tasks = msg.data.tasks;
          this.render();
        }, { retained: true });
      }

      render() {
        this.innerHTML = `
          &lt;ul&gt;
            ${(this.tasks || []).map(task =&gt; `
              &lt;li&gt;
                &lt;input
                  type=&quot;checkbox&quot;
                  ${task.completed ? &#039;checked&#039; : &#039;&#039;}
                  onclick=&quot;this.closest(&#039;task-list&#039;).toggle(&#039;${task.id}&#039;)&quot;&gt;
                &lt;span style=&quot;${task.completed ? &#039;text-decoration: line-through&#039; : &#039;&#039;}&quot;&gt;
                  ${task.title}
                &lt;/span&gt;
                &lt;button onclick=&quot;this.closest(&#039;task-list&#039;).delete(&#039;${task.id}&#039;)&quot;&gt;
                  Delete
                &lt;/button&gt;
              &lt;/li&gt;
            `).join(&#039;&#039;)}
          &lt;/ul&gt;
        `;
      }

      toggle(id) {
        this.client.publish({
          topic: &#039;tasks.toggle&#039;,
          data: { id }
        });
      }

      delete(id) {
        this.client.publish({
          topic: &#039;tasks.delete&#039;,
          data: { id }
        });
      }
    }

    // Task stats
    class TaskStats extends HTMLElement {
      connectedCallback() {
        this.client = new PanClient(this);

        this.client.subscribe(&#039;tasks.state&#039;, (msg) =&gt; {
          this.stats = msg.data;
          this.render();
        }, { retained: true });
      }

      render() {
        if (!this.stats) return;

        this.innerHTML = `
          &lt;div&gt;
            Total: ${this.stats.total} |
            Completed: ${this.stats.completed} |
            Pending: ${this.stats.pending}
          &lt;/div&gt;
        `;
      }
    }

    // Register components
    customElements.define(&#039;task-state&#039;, TaskState);
    customElements.define(&#039;task-form&#039;, TaskForm);
    customElements.define(&#039;task-list&#039;, TaskList);
    customElements.define(&#039;task-stats&#039;, TaskStats);

    // Create state manager
    document.body.appendChild(document.createElement(&#039;task-state&#039;));
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>This example demonstrates:</p>
<li><strong>Message Bus</strong>: Coordinates all communication</li>
<li><strong>Pub/Sub</strong>: Components publish and subscribe to topics</li>
<li><strong>Topics</strong>: Hierarchical naming (<code>tasks.add</code>, <code>tasks.state</code>)</li>
<li><strong>Retained Messages</strong>: State persists for new subscribers</li>
<li><strong>Component Composition</strong>: Independent components work together</li>
<li><strong>State Management</strong>: Centralized state with decoupled consumers</li>
<h2>What We've Learned</h2>
<p>You now understand the core concepts that make LARC work:</p>
<ul><li><strong>Message Bus</strong>: Your application's event-based nervous system</li>
<li><strong>Pub/Sub</strong>: Decoupled communication through topics</li>
<li><strong>Topics</strong>: Hierarchical addressing for organization and routing</li>
<li><strong>Message Lifecycle</strong>: Creation, validation, delivery, and retention</li>
<li><strong>Components</strong>: Standard Web Components using message passing</li>
<li><strong>State Management</strong>: Retained messages as distributed state</li>
<li><strong>Envelopes</strong>: Metadata for correlation, tracing, and debugging</li>
</ul>
These primitives combine to create a simple but powerful architecture. No elaborate state management libraries. No dependency injection frameworks. Just components communicating through a message bus.
<p>In the next chapter, we'll explore the component library and see how LARC provides higher-level abstractions on top of these primitives for common patterns like data binding, forms, and API integration.</p>
<h2>Key Takeaways</h2>
<li>The <code><pan-bus></code> element is just HTML—drop it in your page and it works</li>
<li>Use <code>PanClient</code> for a cleaner API than raw CustomEvents</li>
<li>Topic hierarchies enable pattern matching and semantic routing</li>
<li>Retained messages provide instant state synchronization</li>
<li>Components communicate via the bus, not direct references</li>
<li>State managers are just components that publish retained state</li>
<li>Message envelopes carry metadata for advanced patterns</li>
<p>Now you're ready to build real applications with LARC. Let's dive into the component library.</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/backup/building-with-larc-original-20251226/chapter-04-core-concepts.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
  <pan-theme-provider></pan-theme-provider>
</body>
</html>