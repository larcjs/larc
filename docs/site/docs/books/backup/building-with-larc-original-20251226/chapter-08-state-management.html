<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>State Management · PAN Documentation</title>
  <meta name="description" content="PAN (Page Area Network) Documentation - State Management">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/theme.css">
  <link rel="stylesheet" href="../assets/docs.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" integrity="sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH" crossorigin="anonymous">
</head>
<body>
  <header class="docs-header">
    <div class="docs-header-content">
      <a href="../index.html" class="logo">
        <span>PAN</span>
      </a>
      <nav class="docs-nav">
        <a href="../index.html">Home</a>
        <a href="index.html" class="active">Docs</a>
        <a href="../examples.html">Examples</a>
        <a href="../apps.html">Apps</a>
        <a href="https://github.com/chrisrobison/pan" target="_blank">GitHub</a>
      </nav>
    </div>
  </header>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="docs-sidebar-content">
        <h3>Documentation</h3>
        <nav class="docs-menu" id="docs-menu">
          <!-- Will be populated by JavaScript -->
        </nav>
      </div>
    </aside>

    <main class="docs-main">
      <div class="docs-breadcrumb">
        <a href="../index.html">Home</a> / <a href="#">books</a> / <a href="#">backup</a> / <a href="#">building-with-larc-original-20251226</a> / <span>chapter-08-state-management</span>
      </div>
      <article class="docs-content">
        <h1>State Management</h1>
<blockquote>"There are only two hard things in Computer Science: cache invalidation, naming things, and state management."</blockquote>
>
<blockquote>— Phil Karlton (updated for modern web development)</blockquote>
<p>State management is the art of keeping track of what's true about your application right now. Which user is logged in? What items are in the shopping cart? Is the modal open or closed? Has the data been saved or is it still dirty?</p>
<p>Get state management right, and your application feels solid, predictable, and reliable. Get it wrong, and you'll spend your days hunting down race conditions, stale data, and mysterious bugs that only reproduce on Tuesdays when Mercury is in retrograde.</p>
<p>In this chapter, we'll explore how LARC approaches state management. You'll learn the difference between local and shared state, strategies for persisting state to IndexedDB and OPFS (Origin Private File System), patterns for synchronizing state across components, and techniques for resolving conflicts when multiple sources of truth collide.</p>
<p>Fair warning: this chapter is dense. State management is hard, and anyone who tells you otherwise is selling something. But LARC's message-based architecture provides a solid foundation for tackling this complexity. By the end of this chapter, you'll have the tools to build applications that manage state gracefully, even under adverse conditions.</p>
<h2>Local vs. Shared State</h2>
<p>The first decision in state management is: where does this state live?</p>
<strong>Local state</strong> belongs to a single component. It's not shared, not synchronized, and not persisted. Examples include:
<ul><li>Whether a dropdown is expanded</li>
<li>The current input value in a form field</li>
<li>The selected tab in a tab panel</li>
<li>Animation state</li>
</ul>
Local state is simple. Store it in component properties:
<pre><code class="language-javascript">class DropdownMenu extends HTMLElement {
  constructor() {
    super();
    this.isOpen = false; // Local state
  }

  connectedCallback() {
    this.render();
  }

  toggle() {
    this.isOpen = !this.isOpen;
    this.render();
  }

  render() {
    this.innerHTML = `
      &lt;div class=&quot;dropdown&quot;&gt;
        &lt;button id=&quot;toggle-btn&quot;&gt;${this.isOpen ? &#039;Close&#039; : &#039;Open&#039;}&lt;/button&gt;
        ${this.isOpen ? `
          &lt;ul class=&quot;dropdown-menu&quot;&gt;
            &lt;li&gt;Option 1&lt;/li&gt;
            &lt;li&gt;Option 2&lt;/li&gt;
            &lt;li&gt;Option 3&lt;/li&gt;
          &lt;/ul&gt;
        ` : &#039;&#039;}
      &lt;/div&gt;
    `;

    this.querySelector(&#039;#toggle-btn&#039;).addEventListener(&#039;click&#039;, () =&gt; {
      this.toggle();
    });
  }
}

customElements.define(&#039;dropdown-menu&#039;, DropdownMenu);</code></pre>
<p>Local state requires no persistence, no synchronization, and no messaging. When the component is destroyed, the state disappears. This is fine—ephemeral state should be ephemeral.</p>
<strong>Shared state</strong> is accessed by multiple components. Examples include:
<ul><li>The current authenticated user</li>
<li>Items in a shopping cart</li>
<li>Application theme (light/dark mode)</li>
<li>Cached API responses</li>
</ul>
Shared state lives outside individual components and flows through the PAN bus. Components subscribe to state changes and publish updates.
<h2>The State Store Pattern</h2>
<p>For shared state, LARC applications typically use a "state store" component—a component whose sole job is to manage a piece of shared state.</p>
<p>Here's a minimal example:</p>
<pre><code class="language-javascript">class UserStore extends HTMLElement {
  constructor() {
    super();
    this.currentUser = null;
  }

  connectedCallback() {
    // Subscribe to login events
    this.subscriptions = [
      subscribe(&#039;auth.login.success&#039;, (msg) =&gt; {
        this.setUser(msg.data);
      }),

      subscribe(&#039;auth.logout&#039;, () =&gt; {
        this.setUser(null);
      }),

      subscribe(&#039;user.profile.updated&#039;, (msg) =&gt; {
        if (this.currentUser &amp;&amp; msg.data.userId === this.currentUser.userId) {
          this.setUser({ ...this.currentUser, ...msg.data });
        }
      })
    ];

    // Load persisted user from localStorage
    this.loadPersistedUser();
  }

  setUser(user) {
    this.currentUser = user;

    // Publish updated state
    publish(&#039;user.current&#039;, user);

    // Persist to localStorage
    if (user) {
      localStorage.setItem(&#039;currentUser&#039;, JSON.stringify(user));
    } else {
      localStorage.removeItem(&#039;currentUser&#039;);
    }
  }

  loadPersistedUser() {
    const stored = localStorage.getItem(&#039;currentUser&#039;);
    if (stored) {
      try {
        const user = JSON.parse(stored);
        this.setUser(user);
      } catch (error) {
        console.error(&#039;Failed to load persisted user:&#039;, error);
      }
    }
  }

  disconnectedCallback() {
    this.subscriptions.forEach(unsub =&gt; unsub());
  }
}

customElements.define(&#039;user-store&#039;, UserStore);</code></pre>
<p>This store:</p>
<li>Listens for events that change user state</li>
<li>Updates its internal state</li>
<li>Publishes the new state to <code>user.current</code></li>
<li>Persists the state to localStorage</li>
<p>Other components simply subscribe to <code>user.current</code>:</p>
<pre><code class="language-javascript">class UserGreeting extends HTMLElement {
  connectedCallback() {
    this.unsubscribe = subscribe(&#039;user.current&#039;, (msg) =&gt; {
      this.render(msg.data);
    });
  }

  render(user) {
    if (user) {
      this.textContent = `Hello, ${user.username}!`;
    } else {
      this.textContent = &#039;Please log in.&#039;;
    }
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}

customElements.define(&#039;user-greeting&#039;, UserGreeting);</code></pre>
<p>Notice the separation of concerns: <code>UserStore</code> manages state, <code>UserGreeting</code> displays it. Neither component knows about the other.</p>
<h2>State Persistence with localStorage</h2>
<p>For simple persistence, localStorage is hard to beat. It's synchronous, widely supported, and requires no setup.</p>
<pre><code class="language-javascript">class SettingsStore extends HTMLElement {
  constructor() {
    super();
    this.settings = this.loadSettings();
  }

  connectedCallback() {
    this.unsubscribe = subscribe(&#039;settings.update&#039;, (msg) =&gt; {
      this.updateSettings(msg.data);
    });

    // Publish initial state
    publish(&#039;settings.current&#039;, this.settings);
  }

  loadSettings() {
    const stored = localStorage.getItem(&#039;settings&#039;);
    const defaults = {
      theme: &#039;light&#039;,
      fontSize: 16,
      notifications: true
    };

    if (stored) {
      try {
        return { ...defaults, ...JSON.parse(stored) };
      } catch (error) {
        console.error(&#039;Failed to load settings:&#039;, error);
        return defaults;
      }
    }

    return defaults;
  }

  updateSettings(updates) {
    this.settings = { ...this.settings, ...updates };

    // Persist to localStorage
    localStorage.setItem(&#039;settings&#039;, JSON.stringify(this.settings));

    // Publish updated state
    publish(&#039;settings.current&#039;, this.settings);
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}

customElements.define(&#039;settings-store&#039;, SettingsStore);</code></pre>
<h3>localStorage Limitations</h3>
<p>localStorage is convenient but has limitations:</p>
<li><strong>Size limit</strong>: Typically 5-10 MB per origin</li>
<li><strong>Synchronous API</strong>: Blocks the main thread (though usually fast)</li>
<li><strong>String-only storage</strong>: Must serialize/deserialize data</li>
<li><strong>No structured queries</strong>: You can't query localStorage like a database</li>
<p>For larger datasets or structured data, use IndexedDB.</p>
<h2>State Persistence with IndexedDB</h2>
<p>IndexedDB is a powerful, asynchronous, transactional database built into browsers. It can store much larger amounts of data than localStorage (often hundreds of megabytes or more) and supports structured queries.</p>
<p>However, IndexedDB's API is notoriously verbose. Here's a wrapper to make it more palatable:</p>
<pre><code class="language-javascript">class IndexedDBStore {
  constructor(dbName, storeName) {
    this.dbName = dbName;
    this.storeName = storeName;
    this.db = null;
  }

  async open() {
    return new Promise((resolve, reject) =&gt; {
      const request = indexedDB.open(this.dbName, 1);

      request.onerror = () =&gt; reject(request.error);
      request.onsuccess = () =&gt; {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) =&gt; {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, { keyPath: &#039;id&#039; });
        }
      };
    });
  }

  async get(id) {
    if (!this.db) await this.open();

    return new Promise((resolve, reject) =&gt; {
      const transaction = this.db.transaction([this.storeName], &#039;readonly&#039;);
      const store = transaction.objectStore(this.storeName);
      const request = store.get(id);

      request.onerror = () =&gt; reject(request.error);
      request.onsuccess = () =&gt; resolve(request.result);
    });
  }

  async put(object) {
    if (!this.db) await this.open();

    return new Promise((resolve, reject) =&gt; {
      const transaction = this.db.transaction([this.storeName], &#039;readwrite&#039;);
      const store = transaction.objectStore(this.storeName);
      const request = store.put(object);

      request.onerror = () =&gt; reject(request.error);
      request.onsuccess = () =&gt; resolve(request.result);
    });
  }

  async delete(id) {
    if (!this.db) await this.open();

    return new Promise((resolve, reject) =&gt; {
      const transaction = this.db.transaction([this.storeName], &#039;readwrite&#039;);
      const store = transaction.objectStore(this.storeName);
      const request = store.delete(id);

      request.onerror = () =&gt; reject(request.error);
      request.onsuccess = () =&gt; resolve();
    });
  }

  async getAll() {
    if (!this.db) await this.open();

    return new Promise((resolve, reject) =&gt; {
      const transaction = this.db.transaction([this.storeName], &#039;readonly&#039;);
      const store = transaction.objectStore(this.storeName);
      const request = store.getAll();

      request.onerror = () =&gt; reject(request.error);
      request.onsuccess = () =&gt; resolve(request.result);
    });
  }
}</code></pre>
<p>Now use it in a store component:</p>
<pre><code class="language-javascript">class DocumentStore extends HTMLElement {
  constructor() {
    super();
    this.db = new IndexedDBStore(&#039;app-db&#039;, &#039;documents&#039;);
    this.documents = [];
  }

  async connectedCallback() {
    this.subscriptions = [
      subscribe(&#039;document.save&#039;, async (msg) =&gt; {
        await this.saveDocument(msg.data);
      }),

      subscribe(&#039;document.delete&#039;, async (msg) =&gt; {
        await this.deleteDocument(msg.data.id);
      }),

      subscribe(&#039;document.load&#039;, async (msg) =&gt; {
        await this.loadDocument(msg.data.id);
      })
    ];

    // Load all documents on startup
    await this.loadAllDocuments();
  }

  async loadAllDocuments() {
    try {
      this.documents = await this.db.getAll();
      publish(&#039;documents.loaded&#039;, { documents: this.documents });
    } catch (error) {
      console.error(&#039;Failed to load documents:&#039;, error);
      publish(&#039;documents.error&#039;, { error: error.message });
    }
  }

  async saveDocument(document) {
    try {
      await this.db.put(document);
      this.documents = await this.db.getAll();
      publish(&#039;document.saved&#039;, { document });
      publish(&#039;documents.loaded&#039;, { documents: this.documents });
    } catch (error) {
      console.error(&#039;Failed to save document:&#039;, error);
      publish(&#039;document.error&#039;, { error: error.message });
    }
  }

  async deleteDocument(id) {
    try {
      await this.db.delete(id);
      this.documents = await this.db.getAll();
      publish(&#039;document.deleted&#039;, { id });
      publish(&#039;documents.loaded&#039;, { documents: this.documents });
    } catch (error) {
      console.error(&#039;Failed to delete document:&#039;, error);
      publish(&#039;document.error&#039;, { error: error.message });
    }
  }

  async loadDocument(id) {
    try {
      const document = await this.db.get(id);
      publish(&#039;document.loaded&#039;, { document });
    } catch (error) {
      console.error(&#039;Failed to load document:&#039;, error);
      publish(&#039;document.error&#039;, { error: error.message });
    }
  }

  disconnectedCallback() {
    this.subscriptions.forEach(unsub =&gt; unsub());
  }
}

customElements.define(&#039;document-store&#039;, DocumentStore);</code></pre>
<p>This store persists documents to IndexedDB and publishes events when documents are saved, deleted, or loaded. Other components react to these events without knowing anything about IndexedDB.</p>
<h2>State Persistence with OPFS</h2>
<p>The Origin Private File System (OPFS) is a newer browser API that provides high-performance file storage. Unlike IndexedDB, which is designed for structured data, OPFS is designed for files—making it ideal for large binary data like images, videos, or application data files.</p>
<p>Here's how to use OPFS:</p>
<pre><code class="language-javascript">class OPFSStore {
  constructor() {
    this.root = null;
  }

  async init() {
    if (!this.root) {
      this.root = await navigator.storage.getDirectory();
    }
  }

  async writeFile(path, data) {
    await this.init();

    const fileHandle = await this.root.getFileHandle(path, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(data);
    await writable.close();
  }

  async readFile(path) {
    await this.init();

    try {
      const fileHandle = await this.root.getFileHandle(path);
      const file = await fileHandle.getFile();
      return await file.text();
    } catch (error) {
      if (error.name === &#039;NotFoundError&#039;) {
        return null;
      }
      throw error;
    }
  }

  async deleteFile(path) {
    await this.init();

    try {
      await this.root.removeEntry(path);
    } catch (error) {
      if (error.name !== &#039;NotFoundError&#039;) {
        throw error;
      }
    }
  }

  async listFiles() {
    await this.init();

    const files = [];
    for await (const entry of this.root.values()) {
      if (entry.kind === &#039;file&#039;) {
        files.push(entry.name);
      }
    }
    return files;
  }
}</code></pre>
<p>Use OPFS for storing large files:</p>
<pre><code class="language-javascript">class FileStore extends HTMLElement {
  constructor() {
    super();
    this.opfs = new OPFSStore();
  }

  async connectedCallback() {
    this.subscriptions = [
      subscribe(&#039;file.save&#039;, async (msg) =&gt; {
        await this.saveFile(msg.data);
      }),

      subscribe(&#039;file.load&#039;, async (msg) =&gt; {
        await this.loadFile(msg.data.path);
      }),

      subscribe(&#039;file.delete&#039;, async (msg) =&gt; {
        await this.deleteFile(msg.data.path);
      })
    ];

    // Publish list of available files
    const files = await this.opfs.listFiles();
    publish(&#039;files.list&#039;, { files });
  }

  async saveFile({ path, content }) {
    try {
      await this.opfs.writeFile(path, content);
      publish(&#039;file.saved&#039;, { path });

      const files = await this.opfs.listFiles();
      publish(&#039;files.list&#039;, { files });
    } catch (error) {
      console.error(&#039;Failed to save file:&#039;, error);
      publish(&#039;file.error&#039;, { error: error.message });
    }
  }

  async loadFile(path) {
    try {
      const content = await this.opfs.readFile(path);
      publish(&#039;file.loaded&#039;, { path, content });
    } catch (error) {
      console.error(&#039;Failed to load file:&#039;, error);
      publish(&#039;file.error&#039;, { error: error.message });
    }
  }

  async deleteFile(path) {
    try {
      await this.opfs.deleteFile(path);
      publish(&#039;file.deleted&#039;, { path });

      const files = await this.opfs.listFiles();
      publish(&#039;files.list&#039;, { files });
    } catch (error) {
      console.error(&#039;Failed to delete file:&#039;, error);
      publish(&#039;file.error&#039;, { error: error.message });
    }
  }

  disconnectedCallback() {
    this.subscriptions.forEach(unsub =&gt; unsub());
  }
}

customElements.define(&#039;file-store&#039;, FileStore);</code></pre>
<h3>When to Use OPFS vs. IndexedDB</h3>
<p>Use <strong>IndexedDB</strong> when:</p>
<ul><li>You need structured data with queries</li>
<li>You need transactions</li>
<li>Data is primarily JSON or small blobs</li>
</ul>
Use <strong>OPFS</strong> when:
<ul><li>You're working with large files (>1 MB)</li>
<li>You need high-performance sequential access</li>
<li>You're building a file-based application (e.g., document editor, media player)</li>
</ul>
Use <strong>localStorage</strong> when:
<ul><li>Data is small (<100 KB)</li>
<li>Simplicity matters more than performance</li>
<li>You need synchronous access</li>
</ul>
<h2>Synchronization Patterns</h2>
<p>When multiple components interact with shared state, synchronization becomes critical. Here are common patterns:</p>
<h3>Pattern: Optimistic Updates</h3>
<p>Update the UI immediately, then sync with the server in the background:</p>
<pre><code class="language-javascript">class TodoStore extends HTMLElement {
  constructor() {
    super();
    this.todos = [];
  }

  connectedCallback() {
    this.subscriptions = [
      subscribe(&#039;todo.add&#039;, async (msg) =&gt; {
        await this.addTodo(msg.data);
      }),

      subscribe(&#039;todo.complete&#039;, async (msg) =&gt; {
        await this.completeTodo(msg.data.id);
      })
    ];

    this.loadTodos();
  }

  async loadTodos() {
    try {
      const response = await fetch(&#039;/api/todos&#039;);
      this.todos = await response.json();
      publish(&#039;todos.loaded&#039;, { todos: this.todos });
    } catch (error) {
      console.error(&#039;Failed to load todos:&#039;, error);
    }
  }

  async addTodo(todo) {
    // Optimistic update: add to local state immediately
    const optimisticTodo = { id: `temp-${Date.now()}`, ...todo };
    this.todos.push(optimisticTodo);
    publish(&#039;todos.loaded&#039;, { todos: this.todos });

    try {
      // Sync with server
      const response = await fetch(&#039;/api/todos&#039;, {
        method: &#039;POST&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify(todo)
      });

      const savedTodo = await response.json();

      // Replace optimistic todo with server response
      this.todos = this.todos.map(t =&gt;
        t.id === optimisticTodo.id ? savedTodo : t
      );

      publish(&#039;todos.loaded&#039;, { todos: this.todos });
      publish(&#039;todo.synced&#039;, { todo: savedTodo });
    } catch (error) {
      // Rollback on error
      this.todos = this.todos.filter(t =&gt; t.id !== optimisticTodo.id);
      publish(&#039;todos.loaded&#039;, { todos: this.todos });
      publish(&#039;todo.error&#039;, { error: error.message });
    }
  }

  async completeTodo(id) {
    // Optimistic update: mark complete immediately
    const originalTodos = [...this.todos];
    this.todos = this.todos.map(t =&gt;
      t.id === id ? { ...t, completed: true } : t
    );
    publish(&#039;todos.loaded&#039;, { todos: this.todos });

    try {
      // Sync with server
      await fetch(`/api/todos/${id}`, {
        method: &#039;PATCH&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify({ completed: true })
      });

      publish(&#039;todo.synced&#039;, { id });
    } catch (error) {
      // Rollback on error
      this.todos = originalTodos;
      publish(&#039;todos.loaded&#039;, { todos: this.todos });
      publish(&#039;todo.error&#039;, { error: error.message });
    }
  }

  disconnectedCallback() {
    this.subscriptions.forEach(unsub =&gt; unsub());
  }
}

customElements.define(&#039;todo-store&#039;, TodoStore);</code></pre>
<p>Optimistic updates make the UI feel instant while handling network latency gracefully.</p>
<h3>Pattern: Debounced Sync</h3>
<p>For high-frequency updates, debounce synchronization to reduce server load:</p>
<pre><code class="language-javascript">class EditorStore extends HTMLElement {
  constructor() {
    super();
    this.content = &#039;&#039;;
    this.syncTimer = null;
    this.syncDelay = 1000; // 1 second
  }

  connectedCallback() {
    this.unsubscribe = subscribe(&#039;editor.content.changed&#039;, (msg) =&gt; {
      this.updateContent(msg.data.content);
    });

    this.loadContent();
  }

  async loadContent() {
    try {
      const response = await fetch(&#039;/api/document/current&#039;);
      const data = await response.json();
      this.content = data.content;
      publish(&#039;editor.content.loaded&#039;, { content: this.content });
    } catch (error) {
      console.error(&#039;Failed to load content:&#039;, error);
    }
  }

  updateContent(content) {
    this.content = content;

    // Publish immediately for reactive UI
    publish(&#039;editor.content.updated&#039;, { content });

    // Debounce server sync
    clearTimeout(this.syncTimer);
    this.syncTimer = setTimeout(() =&gt; {
      this.syncToServer();
    }, this.syncDelay);
  }

  async syncToServer() {
    try {
      await fetch(&#039;/api/document/current&#039;, {
        method: &#039;PUT&#039;,
        headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },
        body: JSON.stringify({ content: this.content })
      });

      publish(&#039;editor.content.synced&#039;, { timestamp: Date.now() });
    } catch (error) {
      console.error(&#039;Failed to sync content:&#039;, error);
      publish(&#039;editor.sync.error&#039;, { error: error.message });
    }
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }

    // Flush pending sync on disconnect
    clearTimeout(this.syncTimer);
    this.syncToServer();
  }
}

customElements.define(&#039;editor-store&#039;, EditorStore);</code></pre>
<h3>Pattern: Polling</h3>
<p>For real-time-ish updates without WebSockets, poll the server periodically:</p>
<pre><code class="language-javascript">class NotificationStore extends HTMLElement {
  constructor() {
    super();
    this.notifications = [];
    this.pollInterval = 30000; // 30 seconds
    this.pollTimer = null;
  }

  connectedCallback() {
    this.startPolling();
  }

  startPolling() {
    this.fetchNotifications();

    this.pollTimer = setInterval(() =&gt; {
      this.fetchNotifications();
    }, this.pollInterval);
  }

  async fetchNotifications() {
    try {
      const response = await fetch(&#039;/api/notifications&#039;);
      const notifications = await response.json();

      // Check for new notifications
      const newNotifications = notifications.filter(n =&gt;
        !this.notifications.some(existing =&gt; existing.id === n.id)
      );

      if (newNotifications.length &gt; 0) {
        publish(&#039;notifications.new&#039;, { notifications: newNotifications });
      }

      this.notifications = notifications;
      publish(&#039;notifications.updated&#039;, { notifications });
    } catch (error) {
      console.error(&#039;Failed to fetch notifications:&#039;, error);
    }
  }

  disconnectedCallback() {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
    }
  }
}

customElements.define(&#039;notification-store&#039;, NotificationStore);</code></pre>
<h2>Conflict Resolution</h2>
<p>When multiple sources can update the same state, conflicts arise. Here are strategies for resolving them:</p>
<h3>Strategy: Last Write Wins</h3>
<p>The simplest strategy: the most recent write wins, earlier writes are lost:</p>
<pre><code class="language-javascript">class SimpleStore extends HTMLElement {
  constructor() {
    super();
    this.data = {};
  }

  connectedCallback() {
    this.unsubscribe = subscribe(&#039;data.update&#039;, (msg) =&gt; {
      // Last write wins
      this.data = { ...this.data, ...msg.data };
      publish(&#039;data.current&#039;, this.data);
    });
  }
}</code></pre>
<p>This works when conflicts are rare or unimportant.</p>
<h3>Strategy: Timestamps</h3>
<p>Use timestamps to determine which update is newer:</p>
<pre><code class="language-javascript">class TimestampedStore extends HTMLElement {
  constructor() {
    super();
    this.data = {};
    this.timestamps = {};
  }

  connectedCallback() {
    this.unsubscribe = subscribe(&#039;data.update&#039;, (msg) =&gt; {
      const { key, value, timestamp } = msg.data;

      // Only apply update if it&#039;s newer
      if (!this.timestamps[key] || timestamp &gt; this.timestamps[key]) {
        this.data[key] = value;
        this.timestamps[key] = timestamp;
        publish(&#039;data.current&#039;, this.data);
      }
    });
  }
}</code></pre>
<p>This handles out-of-order updates gracefully.</p>
<h3>Strategy: Version Vectors</h3>
<p>For distributed systems, use version vectors to track causality:</p>
<pre><code class="language-javascript">class VersionedStore extends HTMLElement {
  constructor() {
    super();
    this.data = {};
    this.version = {}; // { clientId: sequence }
  }

  connectedCallback() {
    this.unsubscribe = subscribe(&#039;data.update&#039;, (msg) =&gt; {
      const { key, value, version } = msg.data;

      if (this.isNewer(version)) {
        this.data[key] = value;
        this.version = this.mergeVersions(this.version, version);
        publish(&#039;data.current&#039;, { data: this.data, version: this.version });
      }
    });
  }

  isNewer(incomingVersion) {
    // Check if incoming version is causally newer
    for (const clientId in incomingVersion) {
      if (incomingVersion[clientId] &gt; (this.version[clientId] || 0)) {
        return true;
      }
    }
    return false;
  }

  mergeVersions(v1, v2) {
    const merged = { ...v1 };
    for (const clientId in v2) {
      merged[clientId] = Math.max(merged[clientId] || 0, v2[clientId]);
    }
    return merged;
  }
}</code></pre>
<p>This is overkill for most applications, but essential for offline-first or collaborative apps.</p>
<h3>Strategy: Conflict Detection and User Intervention</h3>
<p>When conflicts matter, detect them and let the user decide:</p>
<pre><code class="language-javascript">class ConflictAwareStore extends HTMLElement {
  constructor() {
    super();
    this.data = {};
    this.version = 0;
  }

  connectedCallback() {
    this.unsubscribe = subscribe(&#039;data.update&#039;, (msg) =&gt; {
      const { key, value, expectedVersion } = msg.data;

      if (expectedVersion !== this.version) {
        // Conflict detected
        publish(&#039;data.conflict&#039;, {
          key,
          currentValue: this.data[key],
          incomingValue: value,
          currentVersion: this.version,
          expectedVersion
        });
      } else {
        // No conflict, apply update
        this.data[key] = value;
        this.version++;
        publish(&#039;data.current&#039;, { data: this.data, version: this.version });
      }
    });
  }
}</code></pre>
<p>A UI component can subscribe to <code>data.conflict</code> and show a dialog asking the user which value to keep.</p>
<h2>State Snapshots and Time Travel</h2>
<p>For debugging and undo/redo functionality, maintain a history of state snapshots:</p>
<pre><code class="language-javascript">class HistoryStore extends HTMLElement {
  constructor() {
    super();
    this.history = [];
    this.currentIndex = -1;
    this.maxHistory = 50;
  }

  connectedCallback() {
    this.subscriptions = [
      subscribe(&#039;state.update&#039;, (msg) =&gt; {
        this.addSnapshot(msg.data);
      }),

      subscribe(&#039;state.undo&#039;, () =&gt; {
        this.undo();
      }),

      subscribe(&#039;state.redo&#039;, () =&gt; {
        this.redo();
      })
    ];
  }

  addSnapshot(state) {
    // Remove any history after current index (user made changes after undo)
    this.history = this.history.slice(0, this.currentIndex + 1);

    // Add new snapshot
    this.history.push(JSON.parse(JSON.stringify(state)));
    this.currentIndex++;

    // Limit history size
    if (this.history.length &gt; this.maxHistory) {
      this.history.shift();
      this.currentIndex--;
    }

    publish(&#039;state.current&#039;, state);
    publish(&#039;state.history.updated&#039;, {
      canUndo: this.canUndo(),
      canRedo: this.canRedo()
    });
  }

  undo() {
    if (this.canUndo()) {
      this.currentIndex--;
      const state = this.history[this.currentIndex];
      publish(&#039;state.current&#039;, state);
      publish(&#039;state.history.updated&#039;, {
        canUndo: this.canUndo(),
        canRedo: this.canRedo()
      });
    }
  }

  redo() {
    if (this.canRedo()) {
      this.currentIndex++;
      const state = this.history[this.currentIndex];
      publish(&#039;state.current&#039;, state);
      publish(&#039;state.history.updated&#039;, {
        canUndo: this.canUndo(),
        canRedo: this.canRedo()
      });
    }
  }

  canUndo() {
    return this.currentIndex &gt; 0;
  }

  canRedo() {
    return this.currentIndex &lt; this.history.length - 1;
  }

  disconnectedCallback() {
    this.subscriptions.forEach(unsub =&gt; unsub());
  }
}

customElements.define(&#039;history-store&#039;, HistoryStore);</code></pre>
<h2>Derived State</h2>
<p>Sometimes state is computed from other state. Rather than storing derived state redundantly, compute it on demand:</p>
<pre><code class="language-javascript">class CartStore extends HTMLElement {
  constructor() {
    super();
    this.items = [];
  }

  connectedCallback() {
    this.unsubscribe = subscribe(&#039;cart.item.added&#039;, (msg) =&gt; {
      this.items.push(msg.data);
      this.publishDerivedState();
    });
  }

  publishDerivedState() {
    const itemCount = this.items.reduce((sum, item) =&gt; sum + item.quantity, 0);
    const subtotal = this.items.reduce((sum, item) =&gt; sum + (item.price * item.quantity), 0);
    const tax = subtotal * 0.08;
    const total = subtotal + tax;

    publish(&#039;cart.state&#039;, {
      items: this.items,
      itemCount,
      subtotal,
      tax,
      total
    });
  }

  disconnectedCallback() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
}</code></pre>
<p>Components receive the fully computed state and don't need to recalculate it.</p>
<h2>Performance Considerations</h2>
<p>State management can be expensive. Here are tips for keeping it performant:</p>
<li><strong>Minimize state updates</strong>: Only publish when state actually changes</li>
<li><strong>Batch updates</strong>: If updating multiple fields, batch them into a single message</li>
<li><strong>Use immutable updates</strong>: Create new objects rather than mutating existing ones</li>
<li><strong>Debounce high-frequency updates</strong>: Don't publish on every keystroke</li>
<li><strong>Lazy load large datasets</strong>: Load data on demand rather than upfront</li>
<li><strong>Prune old data</strong>: Remove stale data from stores to prevent memory bloat</li>
<h2>Wrapping Up</h2>
<p>State management is hard, but LARC's message-based architecture provides a solid foundation. By separating state stores from UI components, using the PAN bus for state synchronization, and choosing the right persistence strategy (localStorage, IndexedDB, or OPFS), you can build applications that manage state gracefully even under complex conditions.</p>
<p>The key insights:</p>
<ul><li>Local state lives in components; shared state lives in stores</li>
<li>Stores subscribe to commands and publish state updates</li>
<li>Components subscribe to state updates and render accordingly</li>
<li>Persistence strategies vary by data size and access patterns</li>
<li>Conflicts are inevitable; plan your resolution strategy</li>
<li>Derived state should be computed, not stored</li>
</ul>
In the next chapter, we'll explore advanced topics like routing, code splitting, and progressive enhancement. But state management is the foundation—get this right, and everything else becomes easier.
<p>Now go forth and manage some state. And when you inevitably encounter a conflict on a Tuesday when Mercury is in retrograde, you'll know exactly what to do.</p>
      </article>
      <footer class="docs-footer">
        <a href="https://github.com/chrisrobison/pan/edit/main/books/backup/building-with-larc-original-20251226/chapter-08-state-management.md" target="_blank">
          Edit this page on GitHub
        </a>
      </footer>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha384-F/bZzf7p3Joyp5psL90p/p89AZJsndkSoGwRpXcZhleCWhd8SnRuoYo4d0yirjJp" crossorigin="anonymous"></script>
  <script src="../assets/docs.js"></script>
</body>
</html>