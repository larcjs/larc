/**
 * @fileoverview PAN Client - Simple API for interacting with the PAN bus
 *
 * PanClient provides a clean, promise-based API for publish/subscribe messaging
 * and request/reply patterns. It handles the low-level CustomEvent details and
 * provides convenient methods for common operations.
 *
 * @example
 * // Basic usage
 * import { PanClient } from './pan-client.mjs';
 *
 * const client = new PanClient();
 * await client.ready();
 *
 * // Publish a message
 * client.publish({
 *   topic: 'users.list.state',
 *   data: { users: [...] },
 *   retain: true
 * });
 *
 * // Subscribe to messages
 * const unsubscribe = client.subscribe('users.*', (msg) => {
 *   console.log('Received:', msg.topic, msg.data);
 * });
 *
 * // Request/reply
 * const response = await client.request('users.get', { id: 123 });
 * console.log('User:', response.data);
 */

/**
 * @typedef {Object} PanMessage
 * @property {string} topic - Topic name (e.g., "users.list.state")
 * @property {*} data - Message payload (any JSON-serializable value)
 * @property {string} [id] - Unique message ID (UUID, auto-generated by bus)
 * @property {number} [ts] - Timestamp in milliseconds (auto-generated by bus)
 * @property {boolean} [retain] - If true, message is retained by bus for new subscribers
 * @property {string} [replyTo] - Topic to send reply to (for request/reply pattern)
 * @property {string} [correlationId] - Correlation ID for matching requests and replies
 * @property {Object<string, string>} [headers] - Optional metadata headers
 */

/**
 * @typedef {Object} SubscribeOptions
 * @property {boolean} [retained] - If true, receive retained messages immediately
 * @property {AbortSignal} [signal] - AbortSignal to automatically unsubscribe
 */

/**
 * @typedef {Object} RequestOptions
 * @property {number} [timeoutMs=5000] - Request timeout in milliseconds
 */

/**
 * @callback MessageHandler
 * @param {PanMessage} message - Received message
 * @returns {void}
 */

/**
 * @callback UnsubscribeFunction
 * @returns {void}
 */

/**
 * PAN Client - Simplified API for PAN bus interaction
 *
 * Provides a clean interface for:
 * - Publishing messages
 * - Subscribing to topics (with wildcard support)
 * - Request/reply pattern with automatic correlation
 * - Retained message support
 * - Automatic cleanup with AbortSignal
 *
 * @class
 * @example
 * // Create client for the document
 * const client = new PanClient();
 *
 * // Or create client for a specific element
 * const myElement = document.querySelector('#my-component');
 * const client = new PanClient(myElement);
 */
export class PanClient {
  /**
   * Creates a new PAN client
   *
   * @param {HTMLElement|Document} [host=document] - Element to dispatch/receive events from
   * @param {string} [busSelector='pan-bus'] - CSS selector for bus element (for compatibility)
   *
   * @example
   * // Default: use document
   * const client = new PanClient();
   *
   * // Use custom element
   * const myComponent = document.querySelector('my-component');
   * const client = new PanClient(myComponent);
   */
  constructor(host = document, busSelector = 'pan-bus') {
    /**
     * Host element for event dispatch/receive
     * @type {HTMLElement|Document}
     * @private
     */
    this.host = host;

    /**
     * Reference to pan-bus element
     * @type {HTMLElement|null}
     * @private
     */
    this.bus = /** @type {HTMLElement|null} */(document.querySelector(busSelector));

    // Generate unique client ID
    const tag = host instanceof HTMLElement
      ? host.tagName.toLowerCase() + (host.id ? ('#' + host.id) : '')
      : 'doc';

    /**
     * Unique client identifier
     * @type {string}
     * @private
     */
    this.clientId = `${tag}#${crypto.randomUUID()}`;

    /**
     * Queue for operations before bus is ready
     * @type {Array<Function>}
     * @private
     */
    this._pendingOps = [];

    /**
     * Whether the bus is ready
     * @type {boolean}
     * @private
     */
    this._isReady = false;

    /**
     * Promise that resolves when PAN bus is ready
     * @type {Promise<void>}
     * @private
     */
    this._ready = new Promise((res) => {
      const onReady = () => {
        document.removeEventListener('pan:sys.ready', onReady, true);
        res();
      };

      // Check if already ready
      if (globalThis.window && window.__panReady) return res();

      // Wait for ready event
      document.addEventListener('pan:sys.ready', onReady, true);
    }).then(() => {
      this._isReady = true;

      // Announce presence to bus
      this._dispatchImmediate('pan:hello', { id: this.clientId, caps: ['client'] });

      // Flush any pending operations
      const ops = this._pendingOps.slice();
      this._pendingOps = [];
      ops.forEach(op => op());
    });
  }

  /**
   * Returns a promise that resolves when the PAN bus is ready
   * Safe to use before bus exists - will wait for pan:sys.ready event
   *
   * @returns {Promise<void>} Resolves when bus is ready
   *
   * @example
   * const client = new PanClient();
   * await client.ready();
   * client.publish({ topic: 'app.started', data: {} });
   */
  ready() {
    return this._ready;
  }

  /**
   * Dispatches a CustomEvent immediately (no queuing)
   * Use this only when you know the bus is ready
   *
   * @param {string} type - Event type (e.g., 'pan:publish')
   * @param {*} detail - Event detail payload
   * @private
   */
  _dispatchImmediate(type, detail) {
    this.host.dispatchEvent(
      new CustomEvent(type, { detail, bubbles: true, composed: true })
    );
  }

  /**
   * Dispatches a CustomEvent on the host element
   * If bus is not ready, queues the operation for later
   * Events bubble and are composed to cross shadow DOM
   *
   * @param {string} type - Event type (e.g., 'pan:publish')
   * @param {*} detail - Event detail payload
   * @private
   */
  _dispatch(type, detail) {
    if (this._isReady) {
      this._dispatchImmediate(type, detail);
    } else {
      // Queue the operation until bus is ready
      this._pendingOps.push(() => this._dispatchImmediate(type, detail));
    }
  }

  /**
   * Publishes a message to the PAN bus
   * Message will be delivered to all matching subscribers
   *
   * @param {PanMessage} msg - Message to publish
   * @param {string} msg.topic - Topic name (required)
   * @param {*} msg.data - Message payload (required)
   * @param {boolean} [msg.retain] - Retain message for late subscribers
   * @param {string} [msg.replyTo] - Topic for replies
   * @param {string} [msg.correlationId] - Correlation ID for request/reply
   *
   * @example
   * // Simple publish
   * client.publish({
   *   topic: 'user.updated',
   *   data: { id: 123, name: 'Alice' }
   * });
   *
   * // Retained message (last value cached)
   * client.publish({
   *   topic: 'users.list.state',
   *   data: { users: [...] },
   *   retain: true
   * });
   */
  publish(msg) {
    this._dispatch('pan:publish', msg);
  }

  /**
   * Subscribes to one or more topic patterns
   * Returns an unsubscribe function to stop receiving messages
   *
   * @param {string|string[]} topics - Topic pattern(s) to subscribe to
   * @param {MessageHandler} handler - Function to handle received messages
   * @param {SubscribeOptions} [opts] - Subscription options
   * @param {boolean} [opts.retained] - Receive retained messages immediately
   * @param {AbortSignal} [opts.signal] - AbortSignal for automatic cleanup
   * @returns {UnsubscribeFunction} Function to unsubscribe
   *
   * @example
   * // Subscribe to single topic
   * const unsub = client.subscribe('users.updated', (msg) => {
   *   console.log('User updated:', msg.data);
   * });
   *
   * // Subscribe to multiple topics with wildcard
   * client.subscribe(['users.*', 'posts.*'], (msg) => {
   *   console.log('Received:', msg.topic, msg.data);
   * });
   *
   * // Get retained messages immediately
   * client.subscribe('app.state', (msg) => {
   *   console.log('Current state:', msg.data);
   * }, { retained: true });
   *
   * // Automatic cleanup with AbortController
   * const controller = new AbortController();
   * client.subscribe('events.*', handler, { signal: controller.signal });
   * // Later: controller.abort(); // Unsubscribes automatically
   */
  subscribe(topics, handler, opts = {}) {
    // Normalize to array
    topics = Array.isArray(topics) ? topics : [topics];

    // Create delivery handler
    const onDeliver = (ev) => {
      const m = ev.detail;
      if (!m || !m.topic) return;

      // Check if message matches any of our topic patterns
      if (topics.some((t) => PanClient.matches(m.topic, t))) {
        handler(m);
      }
    };

    // Listen for deliveries
    this.host.addEventListener('pan:deliver', onDeliver);

    // Subscribe on bus
    this._dispatch('pan:subscribe', {
      clientId: this.clientId,
      topics,
      options: { retained: !!opts.retained }
    });

    // Create unsubscribe function
    const off = () => {
      this.host.removeEventListener('pan:deliver', onDeliver);
      this._dispatch('pan:unsubscribe', { clientId: this.clientId, topics });
    };

    // Handle AbortSignal if provided
    if (opts.signal) {
      const onAbort = () => {
        off();
        opts.signal?.removeEventListener('abort', onAbort);
      };
      opts.signal.addEventListener('abort', onAbort, { once: true });
    }

    return off;
  }

  /**
   * Sends a request and waits for a reply
   * Implements request/reply pattern with automatic correlation and timeout
   *
   * @param {string} topic - Request topic
   * @param {*} data - Request payload
   * @param {RequestOptions} [options] - Request options
   * @param {number} [options.timeoutMs=5000] - Timeout in milliseconds
   * @returns {Promise<PanMessage>} Promise that resolves with reply message
   * @throws {Error} If request times out
   *
   * @example
   * // Simple request
   * try {
   *   const response = await client.request('users.get', { id: 123 });
   *   console.log('User:', response.data);
   * } catch (err) {
   *   console.error('Request failed:', err);
   * }
   *
   * // Custom timeout
   * const response = await client.request('slow.operation', { ... }, {
   *   timeoutMs: 10000  // 10 second timeout
   * });
   */
  request(topic, data, { timeoutMs = 5000 } = {}) {
    // Generate unique correlation ID
    const correlationId = crypto.randomUUID();

    // Create unique reply topic for this request
    const replyTo = `pan:$reply:${this.clientId}:${correlationId}`;

    return new Promise((resolve, reject) => {
      // Subscribe to reply topic
      const off = this.subscribe(replyTo, (m) => {
        clearTimeout(timer);
        off();
        resolve(m);
      });

      // Setup timeout
      const timer = setTimeout(() => {
        off();
        reject(new Error('PAN request timeout'));
      }, timeoutMs);

      // Publish request
      this.publish({ topic, data, replyTo, correlationId });
    });
  }

  /**
   * Checks if a topic matches a pattern
   * Supports exact match, global wildcard (*), and segment wildcards (users.*)
   *
   * @param {string} topic - Topic to test (e.g., "users.list.state")
   * @param {string} pattern - Pattern to match (e.g., "users.*" or "*")
   * @returns {boolean} True if topic matches pattern
   * @static
   *
   * @example
   * PanClient.matches('users.list.state', 'users.*')  // true
   * PanClient.matches('users.list.state', 'users.list.state')  // true
   * PanClient.matches('users.list.state', '*')  // true
   * PanClient.matches('users.list.state', 'posts.*')  // false
   * PanClient.matches('users.item.123', 'users.item.*')  // true
   */
  static matches(topic, pattern) {
    // Exact match or global wildcard
    if (pattern === '*' || topic === pattern) return true;

    // Pattern contains wildcards
    if (pattern && pattern.includes('*')) {
      // Escape regex special chars, replace * with segment matcher
      const esc = (s) => s
        .replace(/[|\\{}()\[\]^$+?.]/g, '\\$&')
        .replace(/\*/g, '[^.]+');

      const rx = new RegExp(`^${esc(pattern)}$`);
      return rx.test(topic);
    }

    return false;
  }
}

export default PanClient;
