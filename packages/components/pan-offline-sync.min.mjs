class l extends HTMLElement{static observedAttributes=["storage","retry-max","retry-delay","topics","strategy","debug"];constructor(){super(),this._db=null,this._dbName="pan-offline-sync",this._queue=[],this._processing=!1,this._online=navigator.onLine,this._subscriptions=new Map,this._retryQueue=new Map,this._panClient=null,this._boundHandleOnline=this._handleOnline.bind(this),this._boundHandleOffline=this._handleOffline.bind(this)}connectedCallback(){this._waitForPanBus().then(()=>{this._initialize()}),window.addEventListener("online",this._boundHandleOnline),window.addEventListener("offline",this._boundHandleOffline)}disconnectedCallback(){this._cleanup(),window.removeEventListener("online",this._boundHandleOnline),window.removeEventListener("offline",this._boundHandleOffline)}attributeChangedCallback(e,t,n){t!==n&&(e==="topics"||e==="storage")&&(this._cleanup(),this._initialize())}async _waitForPanBus(){let e=document.querySelector("pan-bus");if(!(e&&e.panClient))return new Promise(t=>{const n=setInterval(()=>{e=document.querySelector("pan-bus"),e&&e.panClient&&(clearInterval(n),t())},50);setTimeout(()=>{clearInterval(n),t()},5e3)})}async _initialize(){this._dbName=this.getAttribute("storage")||"pan-offline-sync";try{await this._initDB()}catch(t){console.error("Failed to initialize offline sync database:",t);return}if(await this._loadQueue(),this._panClient=this._getPanClient(),!this._panClient){console.error("pan-offline-sync could not find pan-client or pan-bus");return}const e=this.getAttribute("topics");if(e){const t=e.split(",").map(n=>n.trim());for(const n of t)this._subscribeToTopic(n)}this._online&&this._queue.length>0&&this._processQueue(),this._log("Initialized",{dbName:this._dbName,queueLength:this._queue.length,online:this._online})}_cleanup(){for(const[e,t]of this._subscriptions.entries())this._panClient?.unsubscribe(e,t);this._subscriptions.clear(),this._db&&(this._db.close(),this._db=null)}async _initDB(){return new Promise((e,t)=>{const n=indexedDB.open(this._dbName,1);n.onerror=()=>t(n.error),n.onsuccess=()=>{this._db=n.result,e()},n.onupgradeneeded=s=>{const i=s.target.result;if(!i.objectStoreNames.contains("queue")){const o=i.createObjectStore("queue",{keyPath:"id",autoIncrement:!0});o.createIndex("timestamp","timestamp",{unique:!1}),o.createIndex("status","status",{unique:!1})}}})}async _loadQueue(){return new Promise((e,t)=>{const i=this._db.transaction(["queue"],"readonly").objectStore("queue").getAll();i.onsuccess=()=>{this._queue=i.result.filter(o=>o.status==="pending"),this._log("Loaded queue",{count:this._queue.length}),e()},i.onerror=()=>t(i.error)})}_subscribeToTopic(e){if(this._subscriptions.has(e))return;const t=n=>{const s=n.topic;/\.(add|update|delete|save|create|remove|set)/.test(s)&&!this._online&&this._queueMutation({topic:s,data:n.data,meta:n.meta,timestamp:Date.now()})};this._panClient.subscribe(e,t),this._subscriptions.set(e,t),this._log("Subscribed to topic",{pattern:e})}async _queueMutation(e){const t={...e,status:"pending",retries:0,queuedAt:Date.now()};try{const i=this._db.transaction(["queue"],"readwrite").objectStore("queue").add(t);i.onsuccess=()=>{t.id=i.result,this._queue.push(t),this._publishEvent("queue.add",{id:t.id,topic:t.topic,queueLength:this._queue.length}),this._log("Queued mutation",{id:t.id,topic:t.topic})},i.onerror=()=>{console.error("Failed to queue mutation:",i.error)}}catch(n){console.error("Failed to queue mutation:",n)}}_handleOnline(){this._online=!0,this._publishEvent("network.online",{timestamp:Date.now(),queueLength:this._queue.length}),this._log("Network online",{queueLength:this._queue.length}),this._queue.length>0&&this._processQueue()}_handleOffline(){this._online=!1,this._publishEvent("network.offline",{timestamp:Date.now()}),this._log("Network offline")}async _processQueue(){if(this._processing||!this._online||this._queue.length===0)return;this._processing=!0,this._publishEvent("queue.sync",{timestamp:Date.now(),queueLength:this._queue.length}),this._log("Processing queue",{count:this._queue.length});const e=[];for(let t=0;t<this._queue.length;t++){const n=this._queue[t];if(!this._online){this._log("Network went offline during sync");break}try{await this._syncMutation(n),await this._removeMutation(n.id),this._queue.splice(t,1),t--,this._publishEvent("queue.success",{id:n.id,topic:n.topic,remaining:this._queue.length}),this._log("Synced mutation",{id:n.id,topic:n.topic})}catch(s){e.push({mutation:n,error:s});const i=(this._retryQueue.get(n.id)||0)+1,o=parseInt(this.getAttribute("retry-max")||"3",10);if(i>=o)await this._updateMutationStatus(n.id,"failed",s.message),this._queue.splice(t,1),t--,this._publishEvent("queue.error",{id:n.id,topic:n.topic,error:s.message,retries:i}),this._log("Mutation failed after retries",{id:n.id,topic:n.topic,retries:i});else{this._retryQueue.set(n.id,i);const r=parseInt(this.getAttribute("retry-delay")||"1000",10)*Math.pow(2,i-1);this._log("Retrying mutation",{id:n.id,attempt:i,delay:r}),await new Promise(u=>setTimeout(u,r))}}}this._processing=!1,e.length>0?this._log("Queue processing completed with errors",{errors:e.length}):this._log("Queue processing completed successfully")}async _syncMutation(e){return new Promise((t,n)=>{this._panClient.publish(e.topic,e.data,{retain:e.meta?.retain||!1,meta:{...e.meta,syncedAt:Date.now(),queuedAt:e.queuedAt,source:"offline-sync"}});const s=this._getSyncEndpoint(e.topic);s?fetch(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e.data)}).then(i=>{if(!i.ok)throw new Error(`HTTP ${i.status}: ${i.statusText}`);return i.json()}).then(i=>{i.conflict?(this._handleConflict(e,i),n(new Error("Conflict detected"))):t(i)}).catch(i=>n(i)):t()})}_getSyncEndpoint(e){const t=this.getAttribute("endpoints");if(!t)return null;try{const n=JSON.parse(t);for(const[s,i]of Object.entries(n))if(new RegExp("^"+s.replace(/\*/g,".*")+"$").test(e))return i}catch{}return null}_handleConflict(e,t){const n=this.getAttribute("strategy")||"server-wins";this._publishEvent("queue.conflict",{id:e.id,topic:e.topic,local:e.data,server:t.data,strategy:n});let s;n==="server-wins"?s=t.data:n==="client-wins"?s=e.data:n==="merge"&&(s=this._mergeData(e.data,t.data)),this._panClient.publish(e.topic+".resolved",s,{retain:!0,meta:{source:"conflict-resolution",strategy:n}})}_mergeData(e,t){return typeof e!="object"||typeof t!="object"?t:{...e,...t}}async _removeMutation(e){return new Promise((t,n)=>{const o=this._db.transaction(["queue"],"readwrite").objectStore("queue").delete(e);o.onsuccess=()=>t(),o.onerror=()=>n(o.error)})}async _updateMutationStatus(e,t,n=null){return new Promise((s,i)=>{const a=this._db.transaction(["queue"],"readwrite").objectStore("queue"),r=a.get(e);r.onsuccess=()=>{const u=r.result;if(u){u.status=t,n&&(u.error=n);const c=a.put(u);c.onsuccess=()=>s(),c.onerror=()=>i(c.error)}else s()},r.onerror=()=>i(r.error)})}_publishEvent(e,t){const n=this._getPanClient();if(!n)return;const i=`${this.getAttribute("storage")||"pan-offline-sync"}.${e}`;n.publish(i,t,{retain:!1})}_getPanClient(){if(this._panClient)return this._panClient;const t=document.querySelector("pan-bus")?.panClient||document.querySelector("pan-client");return t&&(this._panClient=t.client||t),this._panClient}_log(...e){this.hasAttribute("debug")&&console.log("[pan-offline-sync]",...e)}get online(){return this._online}get queueLength(){return this._queue.length}get queue(){return[...this._queue]}async syncNow(){if(this._online)await this._processQueue();else throw new Error("Cannot sync while offline")}async clearQueue(){const t=this._db.transaction(["queue"],"readwrite").objectStore("queue");return new Promise((n,s)=>{const i=t.clear();i.onsuccess=()=>{this._queue=[],this._retryQueue.clear(),this._log("Queue cleared"),n()},i.onerror=()=>s(i.error)})}async getFailedMutations(){return new Promise((e,t)=>{const o=this._db.transaction(["queue"],"readonly").objectStore("queue").index("status").getAll("failed");o.onsuccess=()=>e(o.result),o.onerror=()=>t(o.error)})}}customElements.define("pan-offline-sync",l);export{l as PanOfflineSync};
