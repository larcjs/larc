class r extends HTMLElement{static observedAttributes=["sources","output","debounce","retain","async","debug","memo"];constructor(){super(),this._subscriptions=new Map,this._sourceData=new Map,this._computeFunction=null,this._debounceTimer=null,this._computing=!1,this._lastResult=void 0,this._lastHash=null,this._panClient=null,this._initialized=!1}connectedCallback(){this._waitForPanBus().then(()=>{this._initialize()})}disconnectedCallback(){this._cleanup()}attributeChangedCallback(t,s,e){s===e||!this._initialized||(t==="sources"||t==="output"?(this._cleanup(),this._initialize()):t==="debounce"&&this._log("Debounce updated",{debounce:e}))}async _waitForPanBus(){let t=document.querySelector("pan-bus");if(!(t&&t.panClient))return new Promise(s=>{const e=setInterval(()=>{t=document.querySelector("pan-bus"),t&&t.panClient&&(clearInterval(e),s())},50);setTimeout(()=>{clearInterval(e),s()},5e3)})}_initialize(){const t=this.getAttribute("sources"),s=this.getAttribute("output");if(!t||!s){console.error('pan-computed-state requires both "sources" and "output" attributes');return}if(this._computeFunction=this._extractComputeFunction(),!this._computeFunction){console.error("pan-computed-state requires a compute function in a <script> element");return}if(this._panClient=this._getPanClient(),!this._panClient){console.error("pan-computed-state could not find pan-client or pan-bus");return}const e=t.split(",").map(i=>i.trim());for(const i of e)this._subscribeToSource(i);this._initialized=!0,this._log("Initialized",{sources:e,output:s})}_cleanup(){for(const[t,s]of this._subscriptions.entries())this._panClient?.unsubscribe(t,s);this._subscriptions.clear(),this._sourceData.clear(),this._debounceTimer&&(clearTimeout(this._debounceTimer),this._debounceTimer=null),this._initialized=!1}_subscribeToSource(t){if(this._subscriptions.has(t))return;const s=e=>{this._handleSourceUpdate(t,e.data)};this._panClient.subscribe(t,s),this._subscriptions.set(t,s),this._panClient.publish(`${t}.get`,null,{retain:!1,replyTo:`${t}.current`}),this._log("Subscribed to source",{topic:t})}_handleSourceUpdate(t,s){this._sourceData.set(t,s),this._log("Source updated",{topic:t,data:s}),this._scheduleComputation()}_scheduleComputation(){const t=parseInt(this.getAttribute("debounce")||"0",10);t>0?(this._debounceTimer&&clearTimeout(this._debounceTimer),this._debounceTimer=setTimeout(()=>{this._compute()},t)):this._compute()}async _compute(){if(this._computing){this._log("Already computing, skipping");return}const t=this.getAttribute("sources").split(",").map(e=>e.trim());if(!t.every(e=>this._sourceData.has(e))){this._log("Not all sources ready",{ready:Array.from(this._sourceData.keys()),waiting:t.filter(e=>!this._sourceData.has(e))});return}this._computing=!0;try{const e=t.map(u=>this._sourceData.get(u));if(this._shouldSkipComputation(e)){this._log("Skipping computation (memoized)",{args:e}),this._computing=!1;return}const i=this.hasAttribute("async");let n;i?n=await this._computeFunction(...e):n=this._computeFunction(...e),this._resultChanged(n)?(this._lastResult=n,this._publishResult(n),this._log("Computed and published",{result:n})):this._log("Result unchanged, skipping publish",{result:n})}catch(e){console.error("Error computing state:",e),this._publishError(e)}finally{this._computing=!1}}_shouldSkipComputation(t){const s=this.getAttribute("memo")||"shallow";if(s==="none")return!1;const e=this._hashArgs(t,s);return this._lastHash!==null&&this._lastHash===e?!0:(this._lastHash=e,!1)}_hashArgs(t,s){return s==="shallow"?JSON.stringify(t.map(e=>e==null?e:typeof e=="object"?Object.keys(e).sort().join(","):e)):s==="deep"?JSON.stringify(t):null}_resultChanged(t){if(this._lastResult===void 0)return!0;try{return JSON.stringify(this._lastResult)!==JSON.stringify(t)}catch{return this._lastResult!==t}}_publishResult(t){const s=this.getAttribute("output"),e=this.hasAttribute("retain");this._panClient.publish(s,t,{retain:e,meta:{source:"computed",sources:this.getAttribute("sources").split(",").map(i=>i.trim()),timestamp:Date.now()}})}_publishError(t){const s=this.getAttribute("output");this._panClient.publish(`${s}.error`,{error:t.message,stack:t.stack,timestamp:Date.now()},{retain:!1})}_extractComputeFunction(){const t=this.querySelector("script:not([src])");if(!t)return null;const s=t.textContent.trim();if(t.type==="application/json")try{const e=JSON.parse(s);if(e.compute)return new Function(`return ${e.compute}`)()}catch(e){return console.error("Failed to parse JSON compute function:",e),null}try{return new Function(`return ${s}`)()}catch(e){return console.error("Failed to parse compute function:",e),null}}_getPanClient(){if(this._panClient)return this._panClient;const s=document.querySelector("pan-bus")?.panClient||document.querySelector("pan-client");return s&&(this._panClient=s.client||s),this._panClient}_log(...t){this.hasAttribute("debug")&&console.log("[pan-computed-state]",...t)}get sources(){return this.getAttribute("sources").split(",").map(t=>t.trim())}get output(){return this.getAttribute("output")}get lastResult(){return this._lastResult}async recompute(){await this._compute()}clearMemo(){this._lastHash=null,this._log("Memo cleared")}getSourceData(){return new Map(this._sourceData)}}customElements.define("pan-computed-state",r);export{r as PanComputedState};
